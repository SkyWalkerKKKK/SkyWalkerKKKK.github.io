<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2FDatabase%2FMySQL%2F</url>
    <content type="text"><![CDATA[数据库的基本概念 数据库的英文单词： DataBase 简称 ： DB 什么数据库？ 用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 – SQL 常见的关系型数据库软件 Oracle MySQL SQL Server DB2 MySQL数据库软件 安装 如果勾选Enable root access from remote machines选项，则可以使用root用户进行远程访问本MySQL服务器。 卸载 （1）去mysql的安装目录找到my.ini文件，复制 datadir=”C:/ProgramData/MySQL/MySQL Server 5.5/Data/“ （2）在控制面板卸载MySQL （3）删除C:/ProgramData目录下的MySQL文件夹。 配置 MySQL服务启动 cmd–&gt; services.msc 打开服务的窗口 使用管理员打开cmd net start mysql : 启动mysql的服务net stop mysql:关闭mysql服务 MySQL登录 mysql -uroot -p密码 mysql -h连接目标ip -uroot -p连接目标的密码 mysql –host=连接目标ip –user=root –password=连接目标的密码 MySQL退出 exit quit MySQL目录结构 MySQL安装目录：basedir=”D:/develop/MySQL/“ 配置文件 my.ini MySQL数据目录：datadir=”C:/ProgramData/MySQL/MySQL Server 5.5/Data/“ * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据 SQL 什么是SQL？Structured Query Language：结构化查询语言其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 SQL分类 （1）DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 （2）DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 （3）DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 （4）DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表操作数据库：CRUD C(Create):创建 创建数据库： create database 数据库名称; 创建数据库，判断不存在，再创建： create database if not exists 数据库名称; 创建数据库，并指定字符集 create database 数据库名称 character set 字符集名; 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk create database if not exists db4 character set gbk; R(Retrieve)：查询 查询所有数据库的名称: show databases; 查询某个数据库的字符集:查询某个数据库的创建语句 show create database 数据库名称; U(Update):修改 修改数据库的字符集 alter database 数据库名称 character set 字符集名称; D(Delete):删除 删除数据库 drop database 数据库名称; 判断数据库存在，存在再删除 drop database if exists 数据库名称; 使用数据库 查询当前正在使用的数据库名称 select database(); 使用数据库 use 数据库名称; 操作表C(Create):创建 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); 注意：最后一列，不需要加逗号（,） 数据库类型： int：整数类型 age int, double:小数类型 score double(5,2) date:日期，只包含年月日，yyyy-MM-dd datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp:时间戳类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar：字符串 name varchar(20):姓名最大20个字符 zhangsan 8个字符 张三 2个字符 创建表 ​ create table student(​ id int,​ name varchar(32),​ age int ,​ score double(4,1),​ birthday date,​ insert_time timestamp​ ); 复制表： create table 表名 like 被复制的表名; R(Retrieve)：查询 查询某个数据库中所有的表名称 show tables; 查询表结构 desc 表名; U(Update):修改 修改表名 alter table 表名 rename to 新的表名; 修改表的字符集 alter table 表名 character set 字符集名称; 添加一列 alter table 表名 add 列名 数据类型; 修改列名称 类型 alter table 表名 change 列名 新列名 新数据类型; alter table 表名 modify 列名 新数据类型; 删除列 alter table 表名 drop 列名; D(Delete):删除 drop table 表名; drop table if exists 表名 ; 客户端图形化工具：SQLYog DML：增删改表中数据 添加数据： 语法： insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n); 注意： 列名和值要一一对应。 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,…值n); 除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据： 语法： delete from 表名 [where 条件] 注意： 如果不加条件，则删除表中所有记录。 如果要删除所有记录 delete from 表名; – 不推荐使用。有多少条记录就会执行多少次删除操作 TRUNCATE TABLE 表名; – 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 修改数据： 语法： update 表名 set 列名1 = 值1, 列名2 = 值2,… [where 条件]; 注意： 如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 基础查询 多个字段的查询 select 字段名1，字段名2… from 表名； 注意： 如果查询所有字段，则可以使用*来替代字段列表。 去除重复： distinct 计算列 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1：哪个字段需要判断是否为null 如果该字段为null后的替换值。 起别名： as：as也可以省略 条件查询 where子句后跟条件 运算符 >、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; BETWEEN…AND IN( 集合) LIKE：模糊查询 占位符： _:单个任意字符 %：多个任意字符 IS NULL and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &apos;___&apos;; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;]]></content>
      <categories>
        <category>Database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaSE Error Log]]></title>
    <url>%2FJava%2FJavaSE-Error-Log%2F</url>
    <content type="text"><![CDATA[Java中protected方法访问权限的问题在cn.skywalker.test05包下的Student类： 123456789101112package cn.skywalker.test05;/** * @author SkyWalker * @create 2019 - 06 - 29 - 19:40 */public class Student &#123; protected void display()&#123; System.out.println("display....."); &#125;&#125; 在cn.skywalker.test06包下的Test类： 12345678910111213141516171819package cn.skywalker.test06;import cn.skywalker.test05.Student;/** * @author SkyWalker * @create 2019 - 06 - 29 - 20:13 */public class Test extends Student&#123; public static void main(String[] args) &#123; Student student = new Student();// student.display(); //在不同包实例化Student类对象，该对象对Student类中声明的protected方法的调用不属于本类调用 Test t = new Test(); t.display(); &#125;&#125; 这里我用cn.skywalker.test06包下的Test类继承了cn.skywalker.test05包下的Student类，但是在Test类中的main()函数中实例化了一个Student对象，该对象却无法调用Student类中使用protected修饰的方法。 这里再给出《java in a nutshell》中的一段话： protected access requires a little more elaboration. Suppose class A declares a protected field x and is extended by a class B, which is defined in a different package (this last point is important). Class B inherits the protected field x, and its code can access that field in the current instance of B or in any other instances of B that the code can refer to. This does not mean, however, that the code of class B can start reading the protected fields of arbitrary instances of A! If an object is an instance of A but is not an instance of B, its fields are obviously not inherited by B, and the code of class B cannot read them. 翻译：protected访问是需要一些准备的。假如类A定义了一个protected的属性x，并且被定义在不同包中的类B扩展了类A。A和B不再同一个包内这一点非常重要。从而，B继承了A的protected属性x，而且在当前B 的实例中这个属性是能够被访问的又或者其他代码中涉及到访问这个属性的B的实例中也是可以访问这个属性的。然而，这并不表示B 的代码可以任意访问A的实例中protected修饰的属性！如果一个对象是A而不是B的实例，显然B是没有继承该对象的属性的，从而B的代码无法访问它们。 方法的访问控制： public protected default private 同类 ✔ ✔ ✔ ✔ 同包 ✔ ✔ ✔ 子类（不同包） ✔ ✔ 不同包中无继承关系的类 ✔ 使用同名局部变量的问题话不多说，直接上代码： 12345678910111213141516171819public class Test &#123; public int age = 5; //成员变量age，默认初始化值为5 public void setAge(int age)&#123; //成员方法，有一个局部变量形参age age = age; &#125; public int getAge()&#123; //成员方法，返回成员变量age的值 return this.age; &#125; public static void main(String[] args)&#123; //主函数 //创建对象，进行测试 Test t = new Test(); t.setAge(10); System.out.println(t.getAge()); //运行结果为5 &#125;&#125; 很明显，我们能看到在Test类中的setAge(int age)方法中，没有使用this关键字对成员变量age进行赋值。而且从运行结果来看，不难发现，在setAge(int age)方法中age = age;这句代码，两个age均指的是形参age这个局部变量。如没有用this显式指明age，则会遵循就近原则，就会发生局部变量age对自己赋值的情况。 局部变量使用范围问题123456789101112131415161718class Demo&#123; String s = "Outer"; public static void main(String[] args)&#123; S2 s2 = new S2(); s2.display(); &#125;&#125;class S1&#123; String s = "S1"; public void display()&#123; System.out.println(s); &#125;&#125;class S2 extends S1&#123; String s = "S2";&#125; 代码如上所示，最终运行结果为S1。 可以总结出：就近原则在使用时，应注意方法对变量的调用也是遵循就近原则的。 多态中关于变量的使用1234567891011121314151617181920212223public class Demo&#123; public static void main(String[] args)&#123; Fu f = new Zi(); System.out.println(f.a); f.method;//这是子类的method方法 &#125;&#125;class Fu&#123; int a = 1; public void method()&#123; System.out,println("这是父类的method方法"); &#125;&#125;class Zi extends Fu&#123; int a = 2; public void method()&#123; System.out.println("这是子类的method方法"); &#125;&#125; 代码如上所示。 我的错误选项： 如果将父类中的成员变量a删除，修改代码如下： 12345class Fu&#123; public void method()&#123; System.out,println("这是父类的method方法"); &#125;&#125; 则运行结果为： 122这是子类的method方法 上面的选项是错误的。正确的运行结果为：编译器报错。 因为如果将Fu类中的成员变量a删除后，在Demo的主函数中f.a的用法将会无法通过编译。 关于println()与toString()的联系12345678910111213141516public class ToStringTest &#123; static int i = 1; public static void main(String args[]) &#123; // 调用ToStringTest的 toString方法 System.out.println("love " + new ToStringTest()); ToStringTest a = new ToStringTest(); a.i++; System.out.println("me " + a.i); &#125; public String toString() &#123; System.out.print("I "); return "java "; &#125;&#125; 运行结果： 12I love java me 2 从结果中，猛一下似乎看不太明白，但静下心来仔细分析，我们会发现在主函数的第一句代码 System.out.println(&quot;love &quot; + new ToStringTest()); 执行过程中，JVM优先解析了 “ + “后面的new ToStringTest()，而我们知道，在JVM调用println()时，底层是调用了该Object对象的toString()方法，所以会最先执行ToStringTest类中重写的toString()方法。结果也就在逻辑之中了。 String类型的深度解析String的本质打开String的源码，类注释中有这么一段话 “Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings.Because String objects are immutable they can be shared.”。 这句话总结归纳了String的一个最重要的特点： String是值不可变(immutable)的常量，是线程安全的(can be shared)。 接下来，String类使用了final修饰符，表明了String类的第二个特点：String类是不可继承的。 下面是String类的成员变量定义，从类的实现上阐明了String值是不可变的(immutable)。 private final char value[]; private final int count; 因此，我们看String类的concat方法。实现该方法第一步要做的肯定是扩大成员变量value的容量，扩容的方法重新定义一个大容量的字符数组buf。第二步就是把原来value中的字符copy到buf中来，再把需要concat的字符串值也copy到buf中来，这样子，buf中就包含了concat之后的字符串值。下面就是问题的关键了，如果value不是final的，直接让value指向buf，然后返回this，则大功告成，没有必要返回一个新的String对象。但是。。。可惜。。。由于value是final型的，所以无法指向新定义的大容量数组buf，那怎么办呢？“return new String(0, count + otherLen, buf);”，这是String类concat实现方法的最后一条语句，重新new一个String对象返回。这下真相大白了吧！ ​ 总结：String实质是字符数组，两个特点： 该类不可被继承 不可变性(immutable)。 12345String s1 = "ab";String s2 = "abc";String s3 = s1 + "c";System.out.println(s3 == s2); //falseSystem.out.println(s3.equals(s2)); //true 1234String s1 = "a" + "b" + "c";String s2 = "abc";System.out.println(s1 == s2);//trueSystem.out.println(s1.equals(s2));//true java网络编程Socket文件上传过程中的中文乱码问题文件上传功能的实现 要求 1、开启文件上传服务器后，侦听TCP连接，若有新连接，则创建一条新的线程去处理连接。 2、文件上传的流程： 123456789101112131415161718192021222324（1） 客户端要求用户录入一个文件路径。客户端对路径进行合理性判断。 （2） 第一次通信： 如果路径正确，则客户端将文件名（getName()方法）发送给服务器。服务器进行接收。 （3） 第二次通信： 服务器接收到文件名后，判断给定的目录中是否存在该文件（exists()方法）， 如果不存在，则反馈false;如果存在则反馈true。 客户端等待反馈结果。 （4） 第三次通信（文件复制的核心部分）： if (反馈为false) &#123; 客户端：将文件读入，通过socket输出流传递 服务器端：通过socket输入流接收，将文件写出 &#125; else &#123; 提示文件已存在，上传失败 &#125; （5） 第四次通信： 复制成功后，服务器反馈复制成功信息。 问题解决很简单（突然感觉自己好蠢）： 不要使用windows自带的鼠标右键新建-&gt;新建文本文档。因为会默认使用GBK格式。 需要使用一些UTF-8编码格式的或者其他格式的都可以识别，只要编码解码格式相同，就不会出现乱码问题。 关于java中true和false是否为Object类型的问题在调用方法时，形参要求的是Object类型，我传了一个false进去，没报错也运行出来了，然后就有点小疑惑，仔细想了想，想到了boolean的包装类Boolean。在参数传进去的时候，应该是把false当作一个Boolean类型了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-ErrorLog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE]]></title>
    <url>%2FJava%2FJavaSE%2F</url>
    <content type="text"><![CDATA[环境变量的配置 右键 “我的电脑” – “属性” – “高级系统设置” – “高级” – “环境变量” 打开环境变量设置。 新建系统变量“JAVA_HOME”，值的内容为JDK的根目录。 在“Path”环境变量的值中，增加“%JAVA_HOME%\bin;” 此时再使用cmd即可直接使用javac和java命令。 JDK9的JShell的简单使用直接在cmd中输入jshell，回车，即可启动JShell。 JShell一般用于极其简单、轻量的情况。 编译器的两点优化（对于变量的赋值）第一个优化对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。 如果没有超过左侧的范围，编译器补上强转。 如果右侧超过了左侧范围，那么直接编译器报错。 123456789101112131415public class Demo01 &#123; public static void main(String[] args) &#123; // 右侧确实是一个int数字，但是没有超过左侧的范围，就是正确的。 // int --&gt; byte, 不是自动类型转换 byte num1 = /*(byte)*/ 30; // 右侧没有超过左侧范围 System.out.println(num1); // 30 // byte num2 = 128; // 右侧超过了左侧的范围，编译器报错 // int --&gt; char, 没有超过范围 // 编译器将会自动补上一个隐含的(char) char c1 = /*(char)*/ 65; System.out.println(c1); // A &#125; &#125; 第二个优化在给变量进行赋值的时候，如果右侧的表达式当中全部都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。 short result = 5 + 8; // 等号右边全部都是常量，没有任何变量参与运算 编译之后，得到的.class字节码文件当中相当于【直接就是】： short result = 13; 右侧的常量结果数值，没有超过左侧范围，所以正确。 这称为“编译器的常量优化” 但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。 12345678910111213141516public class Demo02 &#123; public static void main(String[] args) &#123; short num1 = 10; // 正确写法，右侧没有超过左侧范围 short a = 5; short b = 8; // short + short --&gt; int + int --&gt; int // short result = a + b; // 错误写法！左侧需要是int类型 // 右侧不用变量，而是采用常量，而且只有两个常量，没有别人 short result = 5 + 8; System.out.println(result); short result2 = 5 + a + 8; // 结果应该是18，但是编译器报错 &#125;&#125; switch语句使用的注意事项 多个case后面的数值不可以重复 switch后面小括号当中只能是下列数据类型： 基本数据类型：byte / short / char / int 引用数据类型：String字符串 / enum枚举 switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。 匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者switch的整体结束为止。 关于switch的穿透代码示例： 123456789101112131415public class Debug01 &#123; public static void main(String[] args) &#123; int a = 1; switch (a) &#123; case 1: System.out.println("1."); case 2: case 3: default: // switch的穿透，所以会执行下面的输出语句。 System.out.println("default."); &#125; &#125;&#125; 代码的运行结果为： 121.default. 数组的定义 方式1： 动态初始化：数据类型[] 数组名称 = new 数据类型[数组长度]; 方式2： 标准的静态初始化：数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … }; 方式3： 省略的静态初始化：数据类型[] 数组名称 = { 元素1, 元素2, … }; 注意事项： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。 静态初始化标准格式可以拆分成为两个步骤。 动态初始化也可以拆分成为两个步骤。 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。 使用建议：如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。 1234567891011121314151617181920public class Demo03 &#123; public static void main(String[] args) &#123; // 省略格式的静态初始化 int[] arrayA = &#123; 10, 20, 30 &#125;; // 静态初始化的标准格式，可以拆分成为两个步骤 int[] arrayB; arrayB = new int[] &#123; 11, 21, 31 &#125;; // 动态初始化也可以拆分成为两个步骤 int[] arrayC; arrayC = new int[5]; // 静态初始化的省略格式，不能拆分成为两个步骤。// int[] arrayD;// arrayD = &#123; 10, 20, 30 &#125;; &#125;&#125; 数组中的内存图 Random类 作用：用于产生一个随机数 所属包：java.util.Random 格式： 12Random random = new Random();int number = random.nextInt(int index); // 获取数据的范围：[0,index) 左闭右开的一个区间。 拓展： Math类下的static double random()方法的返回值为double。值为正号，大于等于 0.0 ，小于 1.0 。 即获取数据的范围：[0.0, 1.0) 左闭右开的一个区间。 常用案例： 生成一个1~100的随机数字 1234int num = (int)(Math.random() * 100) + 1; // 使用Math类下的random()静态方法Random r = new Random();int num1 = r.nextInt(100) + 1; // 使用Random类生成 方法重载的注意点 与返回值类型无关 123456789public class MethodDemo&#123; public static void fn(int a)&#123; //method body &#125; public static int fn(int a)&#123; //method body &#125;&#125; 上面的代码不构成方法的重载：因为形参列表相同。虽然返回值类型不同，但方法重载与返回值类型无关。 集成开发环境IntelliJ IDEA IDE（Integrated Development Environment）集成开发环境。 至于本章主题描述 一句话 IDEA牛逼。。。OK就这样233 IDEA中Debug的使用如何加断点选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可。 如何运行加了断点的程序在代码区域右键Debug执行。 看哪里看Debugger窗口 点哪里点Step Into（F7）这个箭头，也可以直接按F7，运行完之后，点击Stop结束。 如何删除断点选择要删除的断点，单击鼠标左键即可。 如果是多个断点，可以每一个再点击一次，也可以一次性全部删除。 注意事项如果数据来自于键盘输入（Scanner），一定要记住输入数据，不然就不能继续往下查看了。 Java中的内存分配JVM简介 Java虚拟机（Java Virtual Machine 简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 一个运行时的Java虚拟机实例的天职是：负责运行一个java程序。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。 JVM的体系结构包含几个主要的子系统和内存区： 垃圾回收器（Garbage Collection）：负责回收堆内存（Heap）中没有被使用的对象，即这些对象已经没有被引用了。 类装载子系统（ClassLoader Sub-System）：除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。 执行引擎（Execution Engine）：负责执行那些包含在被装载类的方法中的指令。 运行时数据区（Java Memory Allocation Area）：又叫虚拟机内存或者Java内存，虚拟机运行时需要从整个计算机内存划分一块内存区域存储许多东西。例如：字节码、从已装载的class文件中得到的其他信息、程序创建的对象、传递给方法的参数，返回值、局部变量等等。 Java内存分区从上节知道，运行时数据区即是java内存，而且数据区要存储的东西比较多，如果不对这块内存区域进行划分管理，会显得比较杂乱无章。 根据存储数据的不同，java内存通常被划分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Method Area）、栈（Stack）、堆（Heap）。 程序计数器（Program Count Register）：又叫程序寄存器。JVM支持多个线程同时运行，当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）。如果线程正在执行的是一个Java方法（非native），那么PC寄存器的值将总是指向下一条将被执行的指令，如果方法是 native的，程序计数器寄存器的值不会被定义。 JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。 栈（Stack）：又叫堆栈。JVM为每个新创建的线程都分配一个栈。也就是说,对于一个Java程序来说，它的运行就是通过对栈的操作来完成的。栈以帧为单位保存线程的状态。JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。我们知道,某个线程正在执行的方法称为此线程的当前方法。我们可能不知道，当前方法使用的帧称为当前帧。当线程激活一个Java方法，JVM就会在线程的 Java堆栈里新压入一个帧，这个帧自然成为了当前帧。在此方法执行期间，这个帧将用来保存参数、局部变量、中间计算过程和其他数据。从Java的这种分配机制来看,堆栈又可以这样理解：栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。 方法区（Method Area）：当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，如下图所示。本地方法区存在一块特殊的内存区域，叫常量池（Constant Pool），这块内存将与String类型的分析密切相关。 堆（Heap）：Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。在此区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存，但是这个对象的引用却是在栈（Stack）中分配。因此，执行String s = new String(“s”)时，需要从两个地方分配内存：在堆中为String对象分配内存，在栈中为引用（这个堆对象的内存地址，即指针）分配内存。 继承 格式：public class 子类名 extends 父类名 { } 范例：public class Zi extends Fu { } 代码范例： 1234567891011121314151617181920212223public class Demo04 &#123; public static void main(String[] args) &#123; //创建对象，调用方法 Fu f = new Fu(); f.show(); Zi z = new Zi(); z.method(); z.show();//调用继承于父类的show方法 &#125;&#125;class Fu &#123; public void show()&#123; System.out.println("父类的show方法"); &#125;&#125;class Zi extends Fu &#123; public void method()&#123; System.out.println("子类的method方法"); &#125;&#125; 注意：父类的构造器无法继承下来，如需调用，使用super关键字即可。 继承的好处与弊端 好处： 提高了代码的 复用性（多个类相同的成员可以放到同一个类中） 提高了代码的 维护性（如果方法的代码需要修改，修改一处即可） 弊端： 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性 继承体现的关系： is a 继承中成员变量的访问特点通过子类对象访问一个变量 ，遵循就近原则： 先找局部范围 再找子类成员范围 再找父类成员范围 如果都没有就报错(不考虑父亲的父亲…) 继承中成员方法的访问特点与成员变量的“就近原则”类似。 再找子类成员范围 再找父类成员范围 如果都没有就报错(不考虑父亲的父亲…) 继承中构造函数的访问特点 子类会继承父类的数据，可能还会使用父类的数据。所以子类初始化之前，一定要先完成父类的初始化。 每一个子类构造方法的第一条语句默认都是：super(); 如果想要控制子类的构造方法调用父类的哪一个构造方法，使用super进行调用即可。 示例代码： 1234567891011121314151617181920212223242526272829public class Demo05 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); &#125;&#125;class Fu &#123; public Fu() &#123; System.out.println("Fu的无参"); &#125; public Fu(int age) &#123; System.out.println("Fu的有参"); &#125;&#125;class Zi extends Fu &#123; public Zi() &#123;// super();//调用父类的无参构造函数 super(10);//调用父类的有参构造函数 System.out.println("Zi的无参"); &#125; public Zi(int age) &#123; //默认调用super();即无参构造函数，可以使用super(int值)显式调用父类的有参构造函数 super(10); System.out.println("Zi的有参"); &#125;&#125; Super内存图 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 方法重写 在重写方法时，可以在声明前加入@Override注解，可以帮助我们检查我们要重写的方法声明是否错误 父类中私有的方法不能被重写 子类的方法的声明和父类的方法的声明一般一致，但是有些地方可以不一致，遵循以下原则： 一大：子类重写的方法的权限修饰符必须大于或者等于父类方法的权限修饰符 private &lt; default &lt; protected &lt; public 两同： 方法名必须相同 参数列表必须相同 两小： 子类重写的方法的返回值类型必须小于等于父类方法的返回值类型（针对的是引用类型，一般小于说的是子类与父类的关系，对基本类型无效） 子类重写的方法抛出的异常必须小于等于或者少于等于父类的方法抛出的异常，如果父类方法没有抛出异常，则子类重写之后的方法绝对不能抛出异常 继承的注意事项 Java中的类只支持单继承，不支持多继承（一个类只能有一个父类） Java中的类支持多层继承 final、static修饰符 final修饰符： 修饰方法：该方法无法被重写 修饰变量：该变量无法被赋值 修饰类：该类无法被继承 static修饰符： 被类的所有对象共享 可以通过类名调用 非静态的成员方法 能访问静态的成员变量 能访问非静态的成员变量 能访问静态的成员方法 能访问非静态的成员方法 静态的成员方法 能访问静态的成员变量 能访问静态的成员方法 总结成一句话就是：静态成员方法只能访问静态成员 示例代码： 123456789101112131415161718192021222324class Student &#123; public String name; //姓名 public int age; //年龄 public static String university; //学校 共享数据！所以设计为静态！ public void show() &#123; System.out.println(name + "," + age + "," + university); &#125;&#125;public class Demo06 &#123; public static void main(String[] args) &#123; // 为对象的共享数据赋值 Student.university = "Tsinghua"; Student s1 = new Student(); s1.name = "lcw"; s1.age = 30; s1.show(); Student s2 = new Student(); s2.name = "ld"; s2.age = 33; s2.show(); &#125;&#125; 多态 概念 一个事物在不同情况下表现出的多种形态 前提 有继承/实现关系 有方法的重写（不一定是必须有） 父类的引用指向子类的对象 多态中成员访问的特点 成员变量：编译看左边（父类），运行看左边（父类） 成员方法：编译看左边（父类），运行看右边（子类） 总结：编译都看左边，运行也都看左边（非静态的成员方法除外）。 多态的好处与弊端 好处：提高了程序的扩展性 弊端：不能使用子类的特有属性、功能 多态的转型（引用类型的转换） 向上转型：小类型（子类）转为大类型（父类），自动转 格式：父类类型 变量名 = 子类对象; 比如：Animal a = new Cat(); 其实多态的体现就是向上转型 向下转型：大类型（父类）转为小类型（子类），强制转 格式：子类类型 对象名 = （子类类型）父类类型的对象名; 比如：Cat c = (Cat)a; 抽象类 概念：使用abstract关键字修饰的类 格式：public abstract class 类名 { } 抽象类的特点 抽象类和抽象方法必须使用 abstract 关键字修饰 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类 抽象类不能实例化 抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态 抽象类的子类 要么重写抽象类中的所有抽象方法 要么是抽象类 抽象类的成员特点 成员变量 既可以是变量 也可以是常量 构造方法 空参构造 有参构造 成员方法 抽象方法 普通方法 接口 概念：公共的规范和标准，只要按照这些规范来就可以正确使用 接口的特点 接口用关键字interface修饰 1public interface 接口名 &#123;&#125; 类实现接口用implements表示 1public class 类名 implements 接口名 &#123;&#125; 接口不能实例化 接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。 多态的形式：具体类多态，抽象类多态，接口多态。 接口的子类 要么重写接口中的所有抽象方法 要么子类也是抽象类 内部类 概念：就是在一个类中定义一个类 格式 ： 1234public class 类名&#123; 修饰符 class 类名&#123; &#125;&#125; ​ 内部类的访问特点 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 分类 成员内部类 局部内部类 匿名内部类 常用API工具类设计思想 构造方法用 private 修饰 成员用 public static 修饰 java.util.Arrays public static String toString(int[] a) ：将指定给定数组以指定格式的字符串返回 [元素1, 元素2, 元素3] 如果直接使用System.out.println()打印一个数组，其实得到的是地址值（字符数组除外，字符数组打印出来的是元素内容） public static void sort(int[] a) ：将指定的数组元素进行排序，默认升序排列 java.util.Math 1、Math类概述 Math 包含执行基本数字运算的方法 2、Math中方法的调用方式 Math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用 3、Math类的常用方法 | 方法名 方法名 | 说明 || ———————————————- | ———————————————- || public static int abs(int a) | 返回参数的绝对值 || public static double ceil(double a) | 返回大于或等于参数的最小double值，等于一个整数 || public static double floor(double a) | 返回小于或等于参数的最大double值，等于一个整数 || public static int round(float a) | 按照四舍五入返回最接近参数的int || public static int max(int a,int b) | 返回两个int值中的较大值 || public static int min(int a,int b) | 返回两个int值中的较小值 || public static double pow (double a,double b) | 返回a的b次幂的值 || public static double random() | 返回值为double的正值，[0.0,1.0) | java.lang.Object toString() equals() java.lang.System System类的常用方法 方法名 说明 public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前时间(以毫秒为单位) java.util.Date void setTime(long millis) long getTime() Date()：代表的当前系统时间 Date(long millis)：代表基准时间+毫秒值落到的时间 java.text.SimpleDateFormat SimpleDateFormat(String str) String format(Date d) Date parse(String str) java.util.Calendar get(int field) void set(int year, int month, int date) setTime(Date date) add(int field,int amount) 注意： 月份是从0~11 ，0表示1月，1表示2月，以此类推… 星期是从1-7，1表示星期日，2表示星期一，以此类推… 包装类 基本类型包装类的作用 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 基本类型对应的包装类 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean Integer经典使用案例（String与int类型转换） int —&gt; String 方式一： 123int num = 100;String s1 = num + "";System.out.println(s1); 方式二： 123int num = 100;String s2 = String.valueOf(num);System.out.println(s2); 方式三： 123int num = 100;String s3 = Integer.toString(num);System.out.println(s3); String —&gt; int 方式一： 1234String s = "100";Integer i = Integer.valueOf(s);int x = i.intValue();System.out.println(x); 方式二： 123String s = "100";int y = Integer.parseInt(s);System.out.println(s); 案例： 需求：有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：“27 38 46 50 91” 思路： 定义一个字符串 把字符串中的数字数据存储到一个int类型的数组中 得到字符串中每一个数字数据？ public String[] split(String regex) 定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中 public static int parseInt(String s) 对 int 数组进行排序 把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现 输出结果 代码： 1234567891011121314151617181920212223242526public class IntegerTest &#123; public static void main(String[] args) &#123; //定义一个字符串 String s = "91 27 46 38 50"; //把字符串中的数字数据存储到一个int类型的数组中 String[] strArray = s.split(" "); int arr[] = new int[strArray.length]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = Integer.parseInt(strArray[i]); &#125; //对 int 数组进行排序 Arrays.sort(arr); //把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现 StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; if (i == arr.length - 1) &#123; sb.append(arr[i]); &#125; else &#123; sb.append(arr[i]).append(" "); &#125; &#125; //输出结果 System.out.println(sb); &#125;&#125; Integer的注意点：在自动装箱与自动拆箱的过程中，同样的赋值语句，可能对应不同的地址。例如： 1234567Integer i1 = Integer.valueOf(100);Integer i2 = Integer.valueOf(100);System.out.println(i1 == i2); // trueInteger i3 = Integer.valueOf(200);Integer i4 = Integer.valueOf(200);System.out.println(i3 == i4); // false 然后我们扒Integer的源码，发现： 123456789101112131415public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; int h = 127; high = h; //然后是其他部分的源码，不再赘述，只取部分说明 ...&#125; 异常异常的概念 程序在编译或者运行的过程中出现的错误 Java中的异常指的都是异常类 异常类的体系 Throwable Error：不研究 Exception 编译时异常（检查异常）：Exception下除了RuntimeException及其子类之外的都是编译时异常 运行时异常（非检查异常）：RuntimeException及其子类都是运行时异常 集合 集合的体系结构： 单列集合： Collection接口 List接口：可以存储重复元素、存取有序、有索引可以根据索引操作元素 ArrayList类 LinkedList类 Set接口：不可以存储重复元素、存取无序、无索引不可以根据索引操作元素 HashSet类 TreeSet类 双列集合： Map接口 HashMap类 单列集合Collection常用方法： 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定的元素 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合中是否存在指定的元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中元素的个数 List接口存储的数据是可重复的、与添加顺序一致的（存取有序） ArrayList集合 ​ 底层是数组结构实现，查询快、增删慢 LinkedList集合 ​ 底层是链表结构实现，查询慢、增删快 ArrayList特有的常用方法： 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 List中，使用迭代器Iterator可能会导致并发修改异常的情况： 出现的原因 ​ 迭代器遍历的过程中，通过集合对象修改了集合中的元素 （添加和删除），造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：ConcurrentModificationException 解决的方案 ​ 用for循环遍历，然后用集合对象做对应的操作即可 示例代码 123456789101112131415161718192021222324252627282930public class ListDemo &#123; public static void main(String[] args) &#123; //创建集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add("hello"); list.add("world"); list.add("java"); //遍历集合，得到每一个元素，看有没有"world"这个元素，如果有，我就添加一个"javaee"元素，请写代码实现// Iterator&lt;String&gt; it = list.iterator();// while (it.hasNext()) &#123;// String s = it.next();// if(s.equals("world")) &#123;// list.add("javaee");// &#125;// &#125; for(int i=0; i&lt;list.size(); i++) &#123; String s = list.get(i); if(s.equals("world")) &#123; list.add("javaee"); &#125; &#125; //输出集合对象 System.out.println(list); &#125;&#125; 列表迭代器 ListIterator介绍 通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器 用于允许程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置 示例代码 1234567891011121314151617181920212223public class ListIteratorDemo &#123; public static void main(String[] args) &#123; //创建集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add("hello"); list.add("world"); list.add("java"); //获取列表迭代器 ListIterator&lt;String&gt; lit = list.listIterator(); while (lit.hasNext()) &#123; String s = lit.next(); if(s.equals("world")) &#123; lit.add("javaee"); &#125; &#125; System.out.println(list); &#125;&#125; LinkedList集合的特有功能 特有方法 | 方法名 | 说明 || ————————- | ——————————– || public void addFirst(E e) | 在该列表开头插入指定的元素 || public void addLast(E e) | 将指定的元素追加到此列表的末尾 || public E getFirst() | 返回此列表中的第一个元素 || public E getLast() | 返回此列表中的最后一个元素 || public E removeFirst() | 从此列表中删除并返回第一个元素 || public E removeLast() | 从此列表中删除并返回最后一个元素 | Set接口方法与List接口几乎一模一样。 主要实现类有HashSet、TreeSet、LinkedHashSet。 存储的数据是不可重复的、不保证与添加顺序一致的（存取无序）。 双列集合MapMap集合的特点 键值对映射关系 一个键对应一个值 键不能重复，值可以重复 元素存取无序 方法介绍 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 根据键删除键值对元素 void clear() 移除所有的键值对元素 boolean containsKey(Object key) 判断集合是否包含指定的键 boolean containsValue(Object value) 判断集合是否包含指定的值 boolean isEmpty() 判断集合是否为空 int size() 两种遍历方式： keySet() entrySet() Collections工具类常用方法： shuffle() reverse() sort() IOFile类构造方法 File(String pathname) File(String parent , String child) File(File parent , String child) 常用方法 创建文件 boolean createNewFile() 创建文件 创建文件夹 boolean mkdir() 创建目录 boolean mkdirs() 创建多级目录 判断 boolean isDirectory() boolean isFile() boolean exists() 获取 String getAbsolutePath() String getPath() String getName() String[] list 获取当前文件夹下，所有的文件或者单级子文件夹名称数组 File[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 删除 boolean delete() API中没有直接提供级联删除方法，只提供了这一个删除方法，如果调用此方法的File是非空目录，则会拒绝删除请求，返回false。 IO流的体系【IO重点】 字节流 InputStream FileInputStream BufferedInputStream OutputStream FileOutputStream BufferedOutputStream 字符流 Reader InputStreamReader FileReader BufferedReader Writer OutputStreamWriter FileWriter BufferedWriter Properties（集合与IO相结合）Properties作为Map集合的使用 Properties介绍 是一个Map体系的集合类 Properties可以保存到流中或从流中加载 属性列表中的每个键及其对应的值都是一个字符串 Properties基本使用 12345678910111213141516171819public class PropertiesDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象// Properties&lt;String,String&gt; prop = new Properties&lt;String,String&gt;(); //错误 Properties prop = new Properties(); //存储元素 prop.put("it001", "lcw"); prop.put("it002", "ld"); prop.put("it003", "lgl"); //遍历集合 Set&lt;Object&gt; keySet = prop.keySet(); for (Object key : keySet) &#123; Object value = prop.get(key); System.out.println(key + "," + value); &#125; &#125;&#125; Properties作为Map集合的特有方法 特有方法 | 方法名 | 说明 || ———————————————- | ———————————————————— || Object setProperty(String key, String value) | 设置集合的键和值，都是String类型，底层调用 Hashtable方法 put || String getProperty(String key) | 使用此属性列表中指定的键搜索属性 || Set stringPropertyNames() | 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 | 示例代码 12345678910111213141516171819202122232425262728293031323334public class PropertiesDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Properties prop = new Properties(); //Object setProperty(String key, String value)：设置集合的键和值，都是String类型，底层调用Hashtable方法put prop.setProperty("it001", "lcw"); /* Object setProperty(String key, String value) &#123; return put(key, value); &#125; Object put(Object key, Object value) &#123; return map.put(key, value); &#125; */ prop.setProperty("it002", "ld"); prop.setProperty("it003", "lgl"); //String getProperty(String key)：使用此属性列表中指定的键搜索属性// System.out.println(prop.getProperty("it001"));// System.out.println(prop.getProperty("it0011"));// System.out.println(prop); //Set&lt;String&gt; stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 Set&lt;String&gt; names = prop.stringPropertyNames(); for (String key : names) &#123;// System.out.println(key); String value = prop.getProperty(key); System.out.println(key + "," + value); &#125; &#125;&#125; Properties和IO流相结合的方法 和IO流结合的方法 | 方法名 | 说明 || ———————————————– | ———————————————————— || void load(InputStream inStream) | 从输入字节流读取属性列表（键和元素对） || void load(Reader reader) | 从输入字符流读取属性列表（键和元素对） || void store(OutputStream out, String comments) | 将此属性列表（键和元素对）写入此 Properties表中，以适合于使用 load(InputStream)方法的格式写入输出字节流 || void store(Writer writer, String comments) | 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 | 示例代码 12345678910111213141516171819202122232425262728293031323334public class PropertiesDemo03 &#123; public static void main(String[] args) throws IOException &#123; //把集合中的数据保存到文件// myStore(); //把文件中的数据加载到集合 myLoad(); &#125; private static void myLoad() throws IOException &#123; Properties prop = new Properties(); //void load(Reader reader)： FileReader fr = new FileReader("myOtherStream\\fw.txt"); prop.load(fr); fr.close(); System.out.println(prop); &#125; private static void myStore() throws IOException &#123; Properties prop = new Properties(); prop.setProperty("it001","lcw"); prop.setProperty("it002","ld"); prop.setProperty("it003","lgl"); //void store(Writer writer, String comments)： FileWriter fw = new FileWriter("myOtherStream\\fw.txt"); prop.store(fw,null); fw.close(); &#125;&#125; 游戏次数案例 案例需求 实现猜数字小游戏只能试玩3次，如果还想玩，提示：游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn) 分析步骤 写一个游戏类，里面有一个猜数字的小游戏 写一个测试类，测试类中有main()方法，main()方法中写如下代码： ​ 从文件中读取数据到Properties集合，用load()方法实现 文件已经存在：game.txt 里面有一个数据值：count=0 ​ 通过Properties集合获取到玩游戏的次数 ​ 判断次数是否到到3次了 如果到了，给出提示：游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn) 如果不到3次： 次数+1，重新写回文件，用Properties的store()方法实现玩游戏 代码实现 123456789101112131415161718192021222324252627282930public class PropertiesTest &#123; public static void main(String[] args) throws IOException &#123; //从文件中读取数据到Properties集合，用load()方法实现 Properties prop = new Properties(); FileReader fr = new FileReader("myOtherStream\\game.txt"); prop.load(fr); fr.close(); //通过Properties集合获取到玩游戏的次数 String count = prop.getProperty("count"); int number = Integer.parseInt(count); //判断次数是否到到3次了 if(number &gt;= 3) &#123; //如果到了，给出提示：游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn) System.out.println("游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn)"); &#125; else &#123; //玩游戏 GuessNumber.start(); //次数+1，重新写回文件，用Properties的store()方法实现 number++; prop.setProperty("count",String.valueOf(number)); FileWriter fw = new FileWriter("myOtherStream\\game.txt"); prop.store(fw,null); fw.close(); &#125; &#125;&#125; 对象序列化流 对象序列化介绍 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化 对象序列化流： ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 构造方法 | 方法名 | 说明 || ———————————— | ————————————————– || ObjectOutputStream(OutputStream out) | 创建一个写入指定的OutputStream的ObjectOutputStream | 序列化对象的方法 | 方法名 | 说明 || —————————- | ———————————- || void writeObject(Object obj) | 将指定的对象写入ObjectOutputStream | 示例代码 学生类 123456789101112131415161718192021222324252627282930313233343536public class Student implements Serializable &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 测试类 123456789101112131415public class ObjectOutputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\oos.txt")); //创建对象 Student s = new Student("lcw",34); //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream oos.writeObject(s); //释放资源 oos.close(); &#125;&#125; 注意事项 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 Serializable是一个标记接口，实现该接口，不需要重写任何方法 对象反序列化流 对象反序列化流： ObjectInputStream ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象 构造方法 | 方法名 | 说明 || ——————————— | ———————————————- || ObjectInputStream(InputStream in) | 创建从指定的InputStream读取的ObjectInputStream | 反序列化对象的方法 | 方法名 | 说明 || ——————- | ——————————- || Object readObject() | 从ObjectInputStream读取一个对象 | 示例代码 1234567891011121314public class ObjectInputStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\oos.txt")); //Object readObject()：从ObjectInputStream读取一个对象 Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + "," + s.getAge()); ois.close(); &#125;&#125; serialVersionUID&amp;transient serialVersionUID 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ 会出问题，会抛出InvalidClassException异常 如果出问题了，如何解决呢？ 重新序列化 给对象所属的类加一个serialVersionUID private static final long serialVersionUID = 42L; transient 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？ 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程 示例代码 学生类 1234567891011121314151617181920212223242526272829303132333435363738public class Student implements Serializable &#123; private static final long serialVersionUID = 42L; private String name;// private int age; private transient int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;// @Override// public String toString() &#123;// return "Student&#123;" +// "name='" + name + '\'' +// ", age=" + age +// '&#125;';// &#125;&#125; 测试类 1234567891011121314151617181920212223public class ObjectStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123;// write(); read(); &#125; //反序列化 private static void read() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\oos.txt")); Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + "," + s.getAge()); ois.close(); &#125; //序列化 private static void write() throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\oos.txt")); Student s = new Student("lcw", 30); oos.writeObject(s); oos.close(); &#125;&#125; 多线程 概念： 进程：正在运行的应用程序 线程：是进程中的单个顺序控制流，是一条执行路径 实现多线程实现多线程方式一：继承Thread类 方法介绍 | 方法名 | 说明 || ———— | ——————————————- || void run() | 在线程开启后，此方法将被调用执行 || void start() | 使此线程开始执行，Java虚拟机会调用run方法() | 实现步骤 定义一个类MyThread继承Thread类 在MyThread类中重写run()方法 创建MyThread类的对象 启动线程 实现多线程方式二：实现Runnable接口 Thread构造方法 | 方法名 | 说明 || ———————————— | ———————- || Thread(Runnable target) | 分配一个新的Thread对象 || Thread(Runnable target, String name) | 分配一个新的Thread对象 | 实现步骤 定义一个类MyRunnable实现Runnable接口 在MyRunnable类中重写run()方法 创建MyRunnable类的对象 创建Thread类的对象，把MyRunnable对象作为构造方法的参数 启动线程 设置和获取线程名称 方法介绍 | 方法名 | 说明 || ————————– | ———————————- || void setName(String name) | 将此线程的名称更改为等于参数name || String getName() | 返回此线程的名称 || Thread currentThread() | 返回对当前正在执行的线程对象的引用 | 线程优先级 线程调度 两种调度方式 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些 Java使用的是抢占式调度模型 随机性 假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的 优先级相关方法 | 方法名 | 说明 || ————————————— | ———————————————————— || final int getPriority() | 返回此线程的优先级 || final void setPriority(int newPriority) | 更改此线程的优先级。线程默认优先级是5；线程优先级的范围是：1-10 | 线程控制 相关方法 | 方法名 | 说明 || —————————— | ———————————————————— || static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 || void join() | 等待这个线程死亡（如果某个线程调用了此方法，则其他并发的线程必须等待这个线程死亡后才有机会调用） || void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 | 线程的生命周期 线程同步卖票 案例需求 某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票 实现步骤 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100; 在SellTicket类中重写run()方法实现卖票，代码步骤如下 判断票数大于0，就卖票，并告知是哪个窗口卖的 卖了票之后，总票数要减1 票没有了，也可能有人来问，所以这里用死循环让卖票的动作一直执行 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下 创建SellTicket类的对象 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 启动线程 卖票案例的问题 卖票出现了问题 相同的票出现了多次 出现了负数的票 问题产生原因 线程执行的随机性导致的 网络编程入门网络编程概述 计算机网络 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统 网络编程 在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换 网络编程三要素 IP地址 要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识 端口 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识 协议 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议 IP地址IP地址：是网络中设备的唯一标识 IP地址分为两大类 IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题 DOS常用命令： ipconfig：查看本机IP地址 ping IP地址：检查网络是否连通 特殊IP地址： 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用 InetAddressInetAddress：此类表示Internet协议（IP）地址 相关方法 | 方法名 | 说明 || —————————————– | ———————————————————— || static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 || String getHostName() | 获取此IP地址的主机名 || String getHostAddress() | 返回文本显示中的IP地址字符串 | 代码演示 1234567891011121314public class InetAddressDemo &#123; public static void main(String[] args) throws UnknownHostException &#123; //InetAddress address = InetAddress.getByName("skywalker"); InetAddress address = InetAddress.getByName("192.168.1.66"); //public String getHostName()：获取此IP地址的主机名 String name = address.getHostName(); //public String getHostAddress()：返回文本显示中的IP地址字符串 String ip = address.getHostAddress(); System.out.println("主机名：" + name); System.out.println("IP地址：" + ip); &#125;&#125; 端口和协议 端口 设备上应用程序的唯一标识 端口号 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败 协议 计算机网络中，连接和通信的规则被称为网络通信协议 UDP协议 用户数据报协议(User Datagram Protocol) UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议 TCP协议 传输控制协议 (Transmission Control Protocol) TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手” 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 第一次握手，客户端向服务器端发出连接请求，等待服务器确认 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 第三次握手，客户端再次向服务器端发送确认信息，确认连接 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等 UDP通信程序UDP发送数据 Java中的UDP通信 UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念 Java提供了DatagramSocket类作为基于UDP协议的Socket 构造方法 | 方法名 | 说明 || ———————————————————– | —————————————————- || DatagramSocket() | 创建数据报套接字并将其绑定到本机地址上的任何可用端口 || DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 | 相关方法 | 方法名 | 说明 || —————————— | ———————- || void send(DatagramPacket p) | 发送数据报包 || void close() | 关闭数据报套接字 || void receive(DatagramPacket p) | 从此套接字接受数据报包 | 发送数据的步骤 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包 调用DatagramSocket对象的方法发送数据 关闭发送端 代码演示 12345678910111213141516171819202122public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口 DatagramSocket ds = new DatagramSocket(); //创建数据，并把数据打包 //DatagramPacket(byte[] buf, int length, InetAddress address, int port) //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。 byte[] bys = "hello,udp,我来了".getBytes(); DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName("192.168.1.66"),10086); //调用DatagramSocket对象的方法发送数据 //void send(DatagramPacket p) 从此套接字发送数据报包 ds.send(dp); //关闭发送端 //void close() 关闭此数据报套接字 ds.close(); &#125;&#125; UDP接收数据 接收数据的步骤 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 构造方法 | 方法名 | 说明 || ———————————– | ———————————————– || DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 | 相关方法 | 方法名 | 说明 || —————– | —————————————- || byte[] getData() | 返回数据缓冲区 || int getLength() | 返回要发送的数据的长度或接收的数据的长度 | 示例代码 123456789101112131415161718public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength())); &#125; &#125;&#125; UDP通信程序练习 案例需求 UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束 UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* UDP发送数据： 数据来自于键盘录入，直到输入的数据是886，发送数据结束 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); //自己封装键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) &#123; //输入的数据是886，发送数据结束 if ("886".equals(line)) &#123; break; &#125; //创建数据，并把数据打包 byte[] bys = line.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345); //调用DatagramSocket对象的方法发送数据 ds.send(dp); &#125; //关闭发送端 ds.close(); &#125;&#125;/* UDP接收数据： 因为接收端不知道发送端什么时候停止发送，故采用死循环接收 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength())); &#125; //关闭接收端// ds.close(); &#125;&#125; TCP通信程序TCP发送数据 Java中的TCP通信 Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。 Java为客户端提供了Socket类，为服务器端提供了ServerSocket类 构造方法 | 方法名 | 说明 || ———————————— | ———————————————- || Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号 || Socket(String host, int port) | 创建流套接字并将其连接到指定主机上的指定端口号 | 相关方法 | 方法名 | 说明 || —————————— | ——————– || InputStream getInputStream() | 返回此套接字的输入流 || OutputStream getOutputStream() | 返回此套接字的输出流 | 示例代码 123456789101112131415public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; //创建客户端的Socket对象(Socket) //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 Socket s = new Socket("192.168.1.66",10000); //获取输出流，写数据 //OutputStream getOutputStream() 返回此套接字的输出流 OutputStream os = s.getOutputStream(); os.write("hello,tcp,我来了".getBytes()); //释放资源 s.close(); &#125;&#125; TCP接收数据 构造方法 | 方法名 | 说明 || ———————– | ——————————– || ServletSocket(int port) | 创建绑定到指定端口的服务器套接字 | 相关方法 | 方法名 | 说明 || ————— | —————————— || Socket accept() | 监听要连接到此的套接字并接受它 | 示例代码 123456789101112131415161718192021public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //创建服务器端的Socket对象(ServerSocket) //ServerSocket(int port) 创建绑定到指定端口的服务器套接字 ServerSocket ss = new ServerSocket(10000); //Socket accept() 侦听要连接到此套接字并接受它 Socket s = ss.accept(); //获取输入流，读数据，并把数据显示在控制台 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); String data = new String(bys,0,len); System.out.println("数据是：" + data); //释放资源 s.close(); ss.close(); &#125;&#125; TCP通信程序练习 案例需求 客户端：数据来自于文本文件，接收服务器反馈 服务器：接收到的数据写入文本文件，给出反馈，代码用线程进行封装，为每一个客户端开启一个线程 案例分析 创建客户端对象，创建输入流对象指向文件，每读入一行数据就给服务器输出一行数据，输出结束后使用shutdownOutput()方法告知服务端传输结束 创建多线程类，在run()方法中读取客户端发送的数据，为了防止文件重名，使用计数器给文件名编号，接受结束后使用输出流给客户端发送反馈信息。 创建服务端对象，每监听到一个客户端则开启一个新的线程接受数据。 客户端接受服务端的回馈信息 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; //创建客户端Socket对象 Socket s = new Socket("192.168.1.66",10000); //封装文本文件的数据 BufferedReader br = new BufferedReader(new FileReader("myNet\\InetAddressDemo.java")); //封装输出流写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); String line; while ((line=br.readLine())!=null) &#123; bw.write(line); bw.newLine(); bw.flush(); &#125; s.shutdownOutput(); //接收反馈 BufferedReader brClient = new BufferedReader(new InputStreamReader(s.getInputStream())); String data = brClient.readLine(); //等待读取数据 System.out.println("服务器的反馈：" + data); //释放资源 br.close(); s.close(); &#125;&#125;public class ServerThread implements Runnable &#123; private Socket s; public ServerThread(Socket s) &#123; this.s = s; &#125; @Override public void run() &#123; try &#123; //接收数据写到文本文件 BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream())); //解决名称冲突问题 int count = 0; File file = new File("myNet\\Copy["+count+"].java"); while (file.exists()) &#123; count++; file = new File("myNet\\Copy["+count+"].java"); &#125; BufferedWriter bw = new BufferedWriter(new FileWriter(file)); String line; while ((line=br.readLine())!=null) &#123; bw.write(line); bw.newLine(); bw.flush(); &#125; //给出反馈 BufferedWriter bwServer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); bwServer.write("文件上传成功"); bwServer.newLine(); bwServer.flush(); //释放资源 s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //创建服务器Socket对象 ServerSocket ss = new ServerSocket(10000); while (true) &#123; //监听客户端连接，返回一个对应的Socket对象 Socket s = ss.accept(); //为每一个客户端开启一个线程 new Thread(new ServerThread(s)).start(); &#125; &#125;&#125; Lambda&amp;方法引用 Lambda表达式为JDK1.8的新特性。 Lambda表达式：简化匿名内部类的一种方式，只能用于有且只有一个抽象方法的接口。 由这三部分组成：(形式参数) -&gt; {代码块} (形式参数): 括号中是参数列表，如果是空参方法，不需要传参。比如Runnable接口中的run()方法。 参数类型可以省略，但是有多个参数的情况下，不能只省略一个。 而且，如果参数有且只有一个那么小括号可以省略。 -&gt;: 固定用法，表示传递 {代码块}: 重写的方法的方法体 如果代码块的语句只有一条，可以省略大括号和分号（如果有return，return也得省略掉） 接口新特性 静态方法（JDK1.8） 格式 public static 返回值类型 方法名(参数列表) { } 范例 12public static void show() &#123;&#125; 注意事项 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 默认方法（JDK1.8） 格式 public default 返回值类型 方法名(参数列表) { } 范例 12public default void show3() &#123; &#125; 注意事项 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字 public可以省略，default不能省略 私有方法（JDK1.9） 主要作用：抽取接口中共性的代码 私有方法产生原因 Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java 9增加私有方法的必然性 定义格式 格式1 private 返回值类型 方法名(参数列表) { } 范例1 12private void show() &#123; &#125; 格式2 private static 返回值类型 方法名(参数列表) { } 范例2 12private static void method() &#123; &#125; 注意事项 默认方法可以调用私有的静态方法和非静态方法 静态方法只能调用私有的静态方法 函数式接口@FunctionalInterface注解：用于检测一个接口是否是函数式接口。 常用的函数式接口： Supplier 属于生产型接口。 接口中只有一个方法 T get(); 获得结果。 Consumer 属于消费型接口 接口中有两个方法： void accept(T t); 对给定的参数执行此操作。 default Consumer andThen(Consumer &lt;? super T&gt; after); 返回一个组合的 Consumer ，按顺序执行该操作，然后执行 after操作。 Predicate 表示一个参数的谓词（布尔值函数）。 五个常用方法，其中boolean test( T t )是该FunctionalInterface的功能方法 Modifier and Type Method and Description default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) 返回一个组合的谓词，表示该谓词与另一个谓词的短路逻辑AND。 static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) 返回根据 Objects.equals(Object, Object)测试两个参数是否相等的 谓词 。 default Predicate&lt;T&gt; negate() 返回表示此谓词的逻辑否定的谓词。 default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) 返回一个组合的谓词，表示该谓词与另一个谓词的短路逻辑或。 boolean test(T t) 在给定的参数上评估这个谓词。 Function 表示接受一个参数并产生结果的函数。 Modifier and Type Method and Description default &lt;V&gt; Function&lt;T,V&gt; andThen(Function&lt;? super R,? extends V&gt; after) 返回一个组合函数，首先将该函数应用于其输入，然后将 after函数应用于结果。 R apply(T t) 将此函数应用于给定的参数。 default &lt;V&gt; Function&lt;V,R&gt; compose(Function&lt;? super V,? extends T&gt; before) 返回一个组合函数，首先将 before函数应用于其输入，然后将此函数应用于结果。 static &lt;T&gt; Function&lt;T,T&gt; identity() 返回一个总是返回其输入参数的函数。 Stream流 类似于车间的生产线，可以更加方便的对集合或者数组中的元素进行操作 操作步骤 1、根据数据源（集合或者数组）生成Stream流对象 2、流操作（使用Stream接口中的方法） 如何将集合或者数组转为Stream流对象（集合/数组-&gt;Stream流） 单列集合通过Collection接口的默认方法stream()，比如：List list = new ArrayList();Stream listStream = list.stream(); Set set = new HashSet();Stream setStream = set.stream(); 双列集合不能直接转为Stream流对象，需要先转为单列集合，然后再调用stream()方法转为流对象，比如：Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); Stream keyStream = map.keySet().stream(); Stream valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream(); 数组通过Stream接口的静态方法of(T… values)，比如： String[] strArray = {“hello”,”world”,”java”};Stream strArrayStream = Stream.of(strArray);或者Stream strArrayStream2 = Stream.of(“hello”, “world”, “java”); Stream接口中的方法 延迟方法（中间操作）：如果一个方法的返回还是Stream流对象，则称之为延迟方法Stream filter(Predicate&lt;? super T&gt; predicate)：用于过滤流中不满足条件的数据Stream limit(long n) :截取流中的前n个数据Stream skip(long n)：跳过流中的前n个数据，截取剩余的数据public static Stream concat(Stream a, Stream b)：用于合并两个流Stream distinct() ：将流中重复的元素去除Stream sorted()：按照自然顺序对流中的数据进行排序Stream sorted(Comparator&lt;? super T&gt; comparator):按照指定的比较器规则对流中的数据进行排序 Stream map(Function&lt;? super T, ? extends R&gt; mapper) ：将流中的元素从一种类型转换为另一种类型的数据IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper) :将流中的数据转为int类型返回一个新的流（IntStream）&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector) ：将流中的数据收集到集合中终结方法（终结操作）：如果一个方法的返回不是Stream流对象，则称之为终结方法void forEach(Consumer&lt;? super T&gt; action) ：用于遍历流中的数据long count()：用于统计流中数据的个数 Stream流的收集（Stream流-&gt;集合/数组）收集到集合收集到List集合 stream.collect(Collectors.toList()); 比如： List&lt;String&gt; names = listStream.collect(Collectors.toList()); 收集到Set集合 stream.collect(Collectors.toSet()); 比如： Set&lt;Integer&gt; ages = setStream.collect(Collectors.toSet()); 收集到Map集合 stream.collect(Collectors.toMap(Function fun1,Function fun2)); 比如： Map&lt;String, Integer&gt; map = arrayStream.collect(Collectors.toMap( s -&gt; s.split(&quot;,&quot;)[0], s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1]) ) ); 收集到数组Stream stream = Stream.of(“hello”, “world”, “java”, “php”, “mysql”);// 只要后三个元素Stream skipStream = stream.skip(2);//String[] strings = skipStream.toArray(length-&gt;new String[length]);String[] strings = skipStream.toArray(String[]::new); for (String s : strings) { System.out.println(s); } 类加载器类加载 类加载的描述 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化 类的加载 就是指将class文件读入内存，并为之创建一个 java.lang.Class 对象 任何类被使用时，系统都会为之建立一个 java.lang.Class 对象 类的连接 验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致 准备阶段：负责为类的类变量分配内存，并设置默认初始化值 解析阶段：将类的二进制数据中的符号引用替换为直接引用 类的初始化 在该阶段，主要就是对类变量进行初始化 类的初始化步骤 假如类还未被加载和连接，则程序先加载并连接该类 假如该类的直接父类还未被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 注意：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3 类的初始化时机 创建类的实例 调用类的类方法 访问类或者接口的类变量，或者为该类变量赋值 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 类加载器类加载器的作用 负责将.class文件加载到内存中，并为之生成对应的 java.lang.Class 对象。虽然我们不用过分关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行！ JVM的类加载机制 全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区 Java中的内置类加载器 Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为null ，并且没有父null Platform class loader：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类 System class loader：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap ClassLoader 中的两个方法 方法分类 | 方法名 | 说明 || —————————————– | ————————– || static ClassLoader getSystemClassLoader() | 返回用于委派的系统类加载器 || ClassLoader getParent() | 返回父类加载器进行委派 | 示例代码 1234567891011121314public class ClassLoaderDemo &#123; public static void main(String[] args) &#123; //static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器 ClassLoader c = ClassLoader.getSystemClassLoader(); System.out.println(c); //AppClassLoader //ClassLoader getParent()：返回父类加载器进行委派 ClassLoader c2 = c.getParent(); System.out.println(c2); //PlatformClassLoader ClassLoader c3 = c2.getParent(); System.out.println(c3); //null &#125;&#125; 反射 概念 将类封装成一个Class对象，然后将类的各个组成部分也封装成对象，然后在运行阶段可以获取各个组成部分并且操作它们。 成员变量 -&gt; Filed类 构造方法 -&gt; Constructor类 成员方法 -&gt; Method类 反射称之为Java中的解剖学，反射相当于是对Java中的类进行解剖 获取Class对象 类名.class 比如：Class clazz = Student.class; 对象名.getClass() 比如：Class clazz = stu.getClass(); Class.forName(“全类名”) 比如：Class.forName(&quot;cn.skywalker.Student&quot;); 以上三种方式获取的字节码对象是同一个。 Class类 123456789101112131415 Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：获取指定参数的public修饰的构造方法 Constructor&lt;?&gt;[] getConstructors()：获取所有public修饰的构造方法 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) ：获取指定参数的构造方法，权限修饰符不限 Constructor&lt;?&gt;[] getDeclaredConstructors() ：获取所有的构造方法，权限修饰符不限T newInstance() ：使用空参构造创建对象 Field getField(String name) Field[] getFields() Field getDeclaredField(String name) Field[] getDeclaredFields() Method getMethod(String name, Class&lt;?&gt;... parameterTypes) Method[] getMethods() Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) Method[] getDeclaredMethods() Constructor类 如何获取 如何操作 public修饰的构造方法使用空参构造创建对象方式一：（1）获取字节码对象（Class对象）（2）调用Class类中的getConstructor()方法获取Constructor对象（3）调用Constructor类中的newInstance()方法创建对象 Class&lt;?&gt; c = Class.forName(“com.itheima_02.Student”);Constructor&lt;?&gt; con = c.getConstructor();Object obj = con.newInstance(); 方式二：（1）获取字节码对象（Class对象）（2）调用Class类中的newInstance()方法创建对象 Class&lt;?&gt; clazz = Class.forName(“com.myReflect.itheima_02.Student”); Object obj = clazz.newInstance(); 使用有参构造创建对象 （1）获取字节码对象（Class对象） （2）调用Class类中的getConstructor(参数类型)方法获取Constructor对象 （3）调用Constructor类中的newInstance(实参)方法创建对象 Class&lt;?&gt; c = Class.forName(“com.itheima_02.Student”);Constructor&lt;?&gt; con = c.getConstructor(String.class, int.class, String.class);Object obj = con.newInstance(“林青霞”, 30, “西安”); 非public修饰的构造方法（1）获取字节码对象（Class对象）（2）调用Class类中的getDeclaredConstructor(参数类型)方法获取Constructor对象（3）调用Constructor类中的setAccessible(true)方法（4）调用Constructor类中的newInstance(实参)方法创建对象 ​ Filed类 如何获取 如何操作 1、获取Class对象 2、使用Class类中的getField(String name)获取指定的成员变量的Field对象 3、反射创建对象 4、调用Field类中的set给指定对象的该成员变量赋指定的值 模块化 在不同模块之间建立模块依赖关系，可以使用不同模块的资源。 使用不同模块的类： exports 包名; requires 模块名; 使用不同模块提供的接口（包含实现类，主要思想是面向接口编程）服务： 提供服务端： exports 接口所在的包; provides 接口名 with 实现类名; 使用服务端： uses 接口名;（使用编译器会自动帮你导包）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2Fmarkdown%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 再一次感谢您花费时间阅读，祝您在这里记录、阅读、分享愉快！]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>-markdown -笔记 -工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML/CSS学习笔记]]></title>
    <url>%2FHTML-CSS%2FHTML-CSS%2F</url>
    <content type="text"><![CDATA[HTML/CSS笔记123456789&lt;html&gt; &lt;!--这是根标签 --&gt; &lt;head&gt; &lt;title&gt;这里是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这里是页面体 &lt;/body&gt;&lt;/html&gt; 外部样式表格式： 1&lt;link rel = "stylesheet" type = "text/css" href = "css文件路径" /&gt; 文本标签 1234567891011121314&lt;em&gt;&lt;/em&gt;表示语义上的强调（自动斜体）&lt;strong&gt;&lt;/strong&gt;表示内容上的强调（自动加粗）&lt;i&gt;&lt;/i&gt;i标签的内容会以斜体显示&lt;b&gt;&lt;/b&gt;b标签的内容会以加粗显示&lt;small&gt;&lt;/small&gt;内容以细小的字体显示&lt;cite&gt;&lt;/cite&gt;引用（加书名号的）&lt;q&gt;&lt;/q&gt;行引用&lt;blockquote&gt;&lt;/blockquote&gt;块儿引用&lt;sup&gt;&lt;/sup&gt;上标&lt;sub&gt;&lt;/sub&gt;下标&lt;del&gt;&lt;/del&gt;删除线&lt;ins&gt;&lt;/ins&gt;插入内容&lt;pre&gt;&lt;/pre&gt;预格式&lt;code&gt;&lt;/code&gt;代码块（一般和pre标签一起使用）]]></content>
      <categories>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>-HTML -CSS -H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习笔记]]></title>
    <url>%2FJava%2FJavaWeb%2F</url>
    <content type="text"><![CDATA[ServletServletResoponse 设置响应格式123ServletResponse response = new ServletResponse();response.setContentType("application/msword");//设置响应类型为word文档。//具体可以在tomcat/config/web.xml中查找需要格式对应的值 JSPJSP运行原理 JSP是简Servlet编写的一种技术，他将Java代码和HTML语句混合在同一个文件中编写。只对网页中的要动态产生的内容才用Java代码来编写，而对固定不变的静态内容才用普通静态HTML页面的方式编写。 JSP继承了HttpJspBase类，而HttpJspBase又继承了HttpServlet，即jsp间接继承了HttpServlet，即JSP本质上就是一个Servlet。 JSP八大内置对象（实际上9个） 类名 对象实例名（可直接调用） HttpServletRequest request HttpServletResoponse response PageContext pageContext HttpSession session ServletContext application ServletConfig config JspWriter out Object page Exception exception ① request：HttpServletRequest的一个对象。 ② response：HttpServletResponse的一个对象（在JSP页面中几乎不会调用response的任何方法）。 ③ pageContext：页面的上下文，是PageContext的一个对象。可以从该对象中获取到其他8个隐含对象。亦可以从中获取到当前页面的其他信息。（学习自定义标签时使用他。在JSP页面上很少直接使用他。） ④ session：代表浏览器和服务器的一次会话，是HttpSession的一个对象。 ⑤ application：代表当前Web应用。是ServletContext的一个对象。（可以获取初始化参数等。） ⑥ config：当前JSP对应的Servlet的ServletConfig对象。（开发时几乎不使用。若需要访问当前JSP配置的初始化参数，需要通过映射的地址才可以。） ⑦ out：JspWriter对象。调用out.println()可以直接把字符串打印到浏览器上。（在两次out.println()时，中间不会换行，需要添加HTML的换行标签&lt;br>。） ⑧ page：指向当前JSP对应的Servlet对象的引用，但为Object类型，只能调用Object类的方法（几乎不使用。） ⑨ exception：一定的条件下才可以用。（只有主动声明了isErrorPage=”true”的时候，才可以使用。） 标红均为开发时常用对象。 pageContext，request，session，application对属性的作用域范围从小到大。 JSP表达式​ JSP表达式（expression）提供了将一个java变量或表达式的计算结果输出到客户端的简化方式，他将要输出的变量或表达式直接封装在&lt;%= 和 %&gt;中。 JSP注释的格式：&lt;%– JSP注释 –%&gt; HTML注释的格式：&lt;!– HTML注释 –> 区别 : ​ JSP注释可以阻止Java代码的执行，而HTML注释surround with &lt;% Java代码 %&gt;时，不能阻止Java代码的执行。 域对象的属性操作 ① 和属性相关的方法： Object getAttribute(String name)：获取指定的属性 Enumeration getAttributeNames()：获取所有的属性的名字组成的Enumeration对象 void removeAttribute(String name)：移除指定的属性 void setAttribute(String name, Object obj)：设置属性 ② pageContext，request，session，application对象都有这些方法。这四个对象也成为域对象。 ③ 作用范围 pageContext：属性的作用范围仅限于当前JSP页面。（在Servlet中无法得到pageContext对象。） request：属性的作用范围仅限于同一个请求。 session：属性的作用范围限于一次会话。（会话：浏览器打开直到关闭称之为一次会话。（会话在此期间不失效。）） application：属性的作用范围限于当前Web应用。是范围最大的属性作用范围，只要在一处设置属性，在其他各处的JSP或Servlet中都可以获取到。 请求的转发和重定向 ① 调用HttpServletRequest的getRequestDispatcher(String path)方法获取RequestDispatcher对象。调用方法时，需要传入要转发的地址。 ② 调用 HttpServletRequest的 forward（request，response）进行请求的转发。 ③ 调用sendRedirect(String path) 进行请求的重定向。 ④ 转发与重定向的区别： 本质区别：请求的转发只发出了 一次 请求，而重定向则发出了 两次 请求。 具体： 请求的转发：地址栏是初次发出请求的地址。 请求的重定向：地址栏不再是初次发出的请求地址，地址栏为最后响应的那个地址。 请求的转发：在最终的Servlet中，request对象和中转的那个request是同一个对象。 请求的重定向：在最终的Servlet中，request对象和中转的那个request不是同一个对象。 请求的转发：只能转发到当前Web应用的资源（内部资源）。 请求的重定向：可以重定向到任何资源。 请求的转发：“ / ” 代表的是当前Web应用（localhost:port/WebApps）的根目录。 请求的重定向：“ / ” 代表的是当前Web站点（localhost:port）的根目录。 JSP指令 ①include 用于通知JSP引擎在翻译当前JSP页面时将其他文件中的内容合并进当前JSP页面转换成的Servlet源文件中，这种在源文件级别进行引入的方式称之为静态引入，当前JSP页面与静态引入的页面紧密结合为一个Servlet。 file属性的设置值必须使用相对路径。 如果以“ / ”开头，表示相对于当前Web应用程序的根目录（注意不是站点根目录），否则，表示相对于当前文件。 ②page page指令用于定义JSP页面的各种属性，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面，为了保持程序的可读性和遵循良好的变成习惯，page指令最好是放在整个JSP页面的起始位置。 page指令常用的属性： import属性：指定当前JSP页面对应的Servlet需要导入的类。&lt;%@page import=”全类名”%&gt; session属性：取值为true或false，指定当前页面的session隐藏变量是否可用，也可以说访问当前页面时，是否一定要生成HttpSession对象。 errorPage和isErrorPage：前者表示指定若当前页面出现错误的实际响应页面是什么，其中“ / ” 表示的是当前Web应用的根目录。后者表示指定当前页面是否为错误处理页面，可以说明当前页面是否可以使用exception隐藏内置对象。 需要注意的是：若指定isErrorPage=”true”，并使用exception的方法了，一般不建议能够直接访问该页面。 contentType：指定当前JSP页面的响应类型。实际调用的是response.setContentType(“text/html;charset=UTF-8”);通常情况下，对于JSP页面而言其取值均为 text/html; charset=UTF-8 pageEncoding：指定当前JSP页面的字符编码。通常情况下该值和contentType中的charset一致。 isELIgnored：指定当前JSP页面是否可以使用EL表达式。通常取值为true。 如何使客户不能直接访问一个页面呢？ 1) 对于Tomcat服务器而言，WEB-INF下的文件是不能通过在浏览器中直接输入来访问的。但通过请求的转发是可以访问的！2) 还可以在web.xml文件中配置错误页面。 1234567891011 &lt;!-- 方式1.指定出错的代码，404没有指定资源，500内部错误。 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;!-- 指定响应页面的位置 --&gt;&lt;/error-page&gt; &lt;!-- 方式2.指定异常的类型 --&gt; &lt;error-page&gt;&lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;!-- 指定响应页面的位置 --&gt;&lt;/error-page&gt; ③taglib JSP标签 jsp:include标签： &lt;jsp:include page = &quot;path&quot;&gt; &lt;/jsp:include&gt; 动态引入：并不是像include指令生成一个Servlet源文件，而是生成两个Servlet源文件，然后通过一个方法的方式把目标页面包含进来。 org.apache.jasper.runtime.JspRuntimeLibrary.include(request,response,&quot;path&quot;,out,false); include指令和jsp:include标签： 是在当前JSP页面的执行期间插入被引入资源的输出内容。 被动态引入的资源必须是一个能独立被Web容器调用和执行的资源。 include指令只能引入遵循JSP格式的文件，被引入文件与当前JSP文件共同合被翻译成一个Servlet源文件。 jsp:foward标签： &lt;jsp:forward page = &quot;path&quot;&gt;&lt;/jsp:forward&gt; 相当于request.getRequestDispatcher(&quot;path&quot;).forward(request,response); 但使用jsp:forward可以使用jsp:param子标签向path传入一些参数，同样jsp:include也可以使用jsp:param子标签。 中文乱码编码格式 = 解码格式即可解决乱码问题。 MVC设计模式MVC即Model-View-Controller。模型-视图-控制器。 模型（Model） 模型是应用程序的主体部分。模型表示业务数据和业务逻辑。 一个模型能为多个视图提供数据。 由于应用于模型的代码只需要写一次就可以被多个视图重用，所以提高了代码的可重用性。 视图（View） 视图是用户看到并与之交互的界面，作用如下： 视图向用户显示相关的数据。 接受用户的输入。 不进行任何实际的业务处理。 控制器（Controller） 控制器接受用户的输入并调用模型和视图去完成用户的需求。 控制器接受请求并决定调用哪个模型组建去处理请求，然后决定调用哪个视图来显示模型处理返回的数据。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-JavaWeb -JSP -Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hello Everyone！这是我的第一篇文章。 在老铁的帮助下，我慢慢开始摸索代码世界…… 自己加油吧。 Keep Going！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
