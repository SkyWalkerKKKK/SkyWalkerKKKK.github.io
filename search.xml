<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2FJava%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC概述 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库。 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 JDBC底层使用了网络编程技术，将Java代码中的SQL代码发送给服务器的数据库，执行完再返回结果给Java代码。 使用JDBC的准备 因为底层是网络编程技术，所以网络三要素（IP，协议，端口）都要指明。 还要指明使用哪个数据库、用户名、密码。 快速入门： 1234567891011121314151617181920212223242526272829步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键--&gt;Add As Library 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql，接受返回结果 7. 处理结果 8. 释放资源代码实现： //1.导入驱动jar包 //2.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "root"); //4.定义sql语句 String sql = "update account set balance = 500 where id = 1"; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); DriverManager：驱动管理对象 功能 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(“com.mysql.jdbc.Driver”); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块。 源码如下： 1234567891011121314151617package com.mysql.jdbc;import java.sql.DriverManager;import java.sql.SQLException;public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125;&#125; 获取数据库连接： 方法：static Connection getConnection(String url, String user, String password) 参数： url：指定连接的路径 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 例子：jdbc:mysql://localhost:3306/student 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 可以在URL后面拼接?characterEncoding=utf8来指定使用UTF-8编码处理数据 user：用户名 password：密码 两种注册驱动的方式（面试题）： 1、Class.forName(“com.mysql.jdbc.Driver”); 2、DriverManager.registerDriver(new Driver()); 两者的区别： 方式一只会注册一次驱动，触发Driver类中的静态代码块执行。 而方式二会注册两次驱动。在内存中生成两个不同的Driver对象。 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 Connection：数据库连接对象 功能： 获取执行sql 的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 功能 执行sql boolean execute(String sql) ：可以执行任意的sql 返回值：如果第一个结果为 ResultSet 对象，则返回 true；如果其为更新计数或者不存在任何结果，则返回 false int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值： (1) 对于 SQL 数据操作语言 (DML) 语句，返回行计数 (2) 对于什么都不返回的 SQL 语句，返回 0 ResultSet executeQuery(String sql) ：执行DQL（select)语句 返回值：包含给定查询所生成数据的 ResultSet 对象；永远不能为 null ResultSet：结果集对象,封装查询结果 boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 Xxx：代表数据类型 如： int getInt() , String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 使用步骤（注意）： 游标向下移动一行 判断是否有数据 获取数据 12345678910//循环判断游标是否是最后一行末尾。while(rs.next())&#123; //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString("name"); double balance = rs.getDouble(3); System.out.println(id + "---" + name + "---" + balance);&#125; PreparedStatement：执行sql的对象 SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 输入用户随便，输入密码：a’ or ‘a’ = ‘a sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ 解决sql注入问题：使用PreparedStatement对象来解决 预编译的SQL：参数使用?作为占位符 步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 注册驱动 获取数据库连接对象 Connection 定义sql 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给？赋值： 方法：setXxx(参数1,参数2) 参数1：？的位置编号 从1 开始 参数2：？的值 执行sql，接受返回结果，不需要传递sql语句 处理结果 释放资源 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 可以防止SQL注入 效率更高 抽取JDBC工具类 ： JDBCUtils 目的：简化书写 分析： 注册驱动也抽取 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性。 解决：配置文件 1234567#文件名：jdbc.properties#以连接MySQL数据库中的skywalker库为例，内容如下：driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/skywalker#如果连接的是本机MySQL服务器，url可以简写为url=jdbc:mysql:///skywalkeruser=rootpassword=123 抽取一个方法释放资源 JDBCUtils代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.sql.*;import java.util.Properties;/** * @author SkyWalker * @create 2019 - 07 - 28 - 9:52 */public class JDBCUtils &#123; private static String driver; // driver private static String url; // url private static String user; // user private static String password; // password static &#123; try &#123; //从配置文件中读取数据库配置信息 Properties prop = new Properties(); prop.load(JDBCUtils.class.getClassLoader().getResourceAsStream("jdbc.properties")); driver = prop.getProperty("driver"); url = prop.getProperty("url"); user = prop.getProperty("user"); password = prop.getProperty("password"); //注册驱动 Class.forName(driver); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; Connection conn = null; try &#123; conn = DriverManager.getConnection(url, user, password); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; public static void release(Connection conn, PreparedStatement ps, ResultSet rs) &#123; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDBC控制事务 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 操作： 开启事务。 完成后，提交事务。 如果发生异常，则回滚事务。 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 案例：jack给skywalker转账500元的事务，对比数据库中的数据进行测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;/** * @author SkyWalker * @create 2019 - 07 - 28 - 17:28 */public class Demo &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps1 = null; PreparedStatement ps2 = null; try &#123; conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); String sql1 = "update account set balance = balance - ? where `name` = ?"; String sql2 = "update account set balance = balance + ? where `name` = ?"; ps1 = conn.prepareStatement(sql1); ps2 = conn.prepareStatement(sql2); // jack 给 skywalker 转账500 ps1.setDouble(1, 500); ps1.setString(2, "jack"); ps2.setDouble(1, 500); ps2.setString(2, "skywalker"); //开始执行事务的操作 ps1.executeUpdate(); //手动制造了一个异常，若不进行回滚操作，则数据库中的数据会发生问题。事务的一致性无法保持。 int i = 3 / 0; ps2.executeUpdate(); //事务完成后，提交事务 conn.commit(); &#125; catch (Exception e) &#123; //事务未完成，回滚事务 if (conn != null) &#123; try &#123; conn.rollback(); &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(conn, ps1, null); if (ps2 != null) &#123; try &#123; ps2.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 数据库连接池 概念：其实就是一个容器（集合），存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处： 节约资源 用户访问高效 方便对连接进行统一管理 连接池的实现： 标准接口：DataSource javax.sql包下的 获取连接：getConnection() 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 分类： C3P0 导包 定义配置文件 可以是properties形式的，也可以是xml形式的 需要将配置文件放在src下 创建核心对象，数据库连接池对象 ComboPooledDataSource 调用getConnction()方法获取连接 Druid 导包 定义配置文件 是properties形式的 可以叫任意名称 可以放在任意目录下 手动加载配置文件 获取数据库连接池对象：通过工厂类来获取 DruidDataSourceFactory 调用getConnction()方法获取连接 Spring JDBC Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发。 步骤： 导入jar包 创建JdbcTemplate对象。依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 update():执行DML语句。增、删、改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList():查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query():查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject：查询结果，将结果封装为对象 一般用于聚合函数的查询 对于Spring JDBC的练习： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import cn.skywalker.Druid.JDBCUtils;import org.junit.Test;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import cn.skywalker.domain.Employee;import java.util.List;import java.util.Map;/** * @author SkyWalker * @create 2019 - 07 - 30 - 15:24 */public class Demo &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 将编号为1011的工资更新为7500 */ @Test public void test01() &#123; template.update("update emp set salary = ? where id = ?", 7500, 1011); &#125; /** * 添加一条记录 */ @Test public void test02() &#123; template.update("insert into emp(id,ename,dept_id) values (?,?,?)", 1015, "张飞", 20); &#125; /** * 删除刚才的记录 */ @Test public void test03() &#123; template.update("delete from emp where id = ?", 1015); &#125; /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test04() &#123; Map&lt;String, Object&gt; map = template.queryForMap("select * from emp where id = ?", 1001); System.out.println(map); &#125; /** * 5. 查询所有记录，将其封装为List */ @Test public void test05() &#123; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList("select * from emp"); for (Map&lt;String, Object&gt; map : list) &#123; System.out.println(map); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test06() &#123; List&lt;Employee&gt; emplist = template.query("select * from emp", new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class)); for (Employee emp : emplist) &#123; System.out.println(emp); &#125; &#125; /** * 7. 查询总记录数 */ @Test public void test07() &#123; Integer count = template.queryForObject("select count(*) from emp", Integer.class); System.out.println(count); &#125; /** * 8. 查询id为1008的员工，封装为Emp对象 */ @Test public void test08()&#123; Employee employee = template.queryForObject("select * from emp where id = ?", new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class), 1008); System.out.println(employee); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SQL</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2Funcategorized%2Fredis%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery3.0]]></title>
    <url>%2Funcategorized%2FjQuery3-0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[BootStrap]]></title>
    <url>%2Funcategorized%2FBootStrap%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2Funcategorized%2FJavaScript%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2FDatabase%2FMySQL%2F</url>
    <content type="text"><![CDATA[数据库的基本概念 数据库的英文单词： DataBase 简称 ： DB 什么数据库？ 用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 – SQL 常见的关系型数据库软件 Oracle MySQL SQL Server DB2 MySQL数据库软件 安装 如果勾选Enable root access from remote machines选项，则可以使用root用户进行远程访问本MySQL服务器。（或者以后在mysql数据库下的user表中，自己手动添加一个主机名为’%’的root用户，也可以访问本机MySQL服务器。） 卸载 （1）去mysql的安装目录找到my.ini文件，复制 datadir=”C:/ProgramData/MySQL/MySQL Server 5.5/Data/“ （2）在控制面板卸载MySQL （3）删除C:/ProgramData目录下的MySQL文件夹。 配置 MySQL服务启动 cmd–&gt; services.msc 打开服务的窗口 使用管理员打开cmd net start mysql : 启动mysql的服务net stop mysql:关闭mysql服务 MySQL登录 mysql -uroot -p密码 mysql -h连接目标ip -uroot -p连接目标的密码 mysql –host=连接目标ip –user=root –password=连接目标的密码 MySQL退出 exit quit MySQL目录结构 MySQL安装目录：basedir=”D:/develop/MySQL/“ 配置文件 my.ini MySQL数据目录：datadir=”C:/ProgramData/MySQL/MySQL Server 5.5/Data/“ 在数据库中，可以将数据库想象成一个文件夹，表就是一个文件，数据则是该文件中的数据。 数据库 → 文件夹 表 → 文件 数据 → 数据 SQL 什么是SQL？Structured Query Language：结构化查询语言其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL：操作数据库、表DDL：Data Definition Language 数据定义语言 使用数据库 查询当前正在使用的数据库名称 select database(); 使用数据库 use 数据库名称; 操作数据库：CRUD C(Create):创建 创建数据库： create database 数据库名称; 创建数据库，判断不存在，再创建： create database if not exists 数据库名称; 创建数据库，并指定字符集 create database 数据库名称 character set 字符集名; 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk create database if not exists db4 character set gbk; R(Retrieve)：查询 查询所有数据库的名称: show databases; 查询某个数据库的字符集:查询某个数据库的创建语句 show create database 数据库名称; U(Update):修改 修改数据库的字符集 alter database 数据库名称 character set 字符集名称; D(Delete):删除 删除数据库 drop database 数据库名称; 判断数据库存在，存在再删除 drop database if exists 数据库名称; 操作表：CRUD C(Create):创建 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); 注意：最后一列，不需要加逗号（,） 数据库类型： int：整数类型 age int, double:小数类型 score double(5,2) date:日期，只包含年月日，yyyy-MM-dd datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp:时间戳类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar：字符串 name varchar(20):姓名最大20个字符 zhangsan 8个字符 张三 2个字符 创建表 ​ create table student(​ id int,​ name varchar(32),​ age int ,​ score double(4,1),​ birthday date,​ insert_time timestamp​ ); 复制表： create table 表名 like 被复制的表名; R(Retrieve)：查询 查询某个数据库中所有的表名称 show tables; 查询表结构 desc 表名; U(Update):修改 修改表名 alter table 表名 rename to 新的表名; rename table 表名 to 新的表名; 修改表的字符集 alter table 表名 character set 字符集名称; 添加一列 alter table 表名 add 列名 数据类型; 修改列名称 类型 alter table 表名 change 列名 新列名 新数据类型; alter table 表名 modify 列名 新数据类型; 删除列 alter table 表名 drop 列名; D(Delete):删除 drop table 表名; drop table if exists 表名 ; 客户端图形化工具：SQLYog DML：增删改表中数据DML：Data Manipulation Language 数据操作语言 添加数据 语法： insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n); 注意： 列名和值要一一对应。 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,…值n); 除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据 语法： delete from 表名 [where 条件] 注意： 如果不加条 件，则删除表中所有记录。 如果要删除所有记录 delete from 表名; – 不推荐使用。有多少条记录就会执行多少次删除操作 TRUNCATE TABLE 表名; – 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 修改数据 语法： update 表名 set 列名1 = 值1, 列名2 = 值2,… [where 条件]; 注意： 如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录（单表查询）DQL：Data QueryLanguage 数据查询语言 语法select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序列名 [ASC | DESC] limit 起始索引,长度; 基础查询 多个字段的查询 select 字段名1，字段名2… from 表名； 注意： 如果查询所有字段，则可以使用*来替代字段列表。 去除重复： distinct 计算列 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1：哪个字段需要判断是否为null 如果该字段为null后的替换值。 起别名： as：as也可以省略 条件查询 where子句后跟条件 运算符 >、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; BETWEEN…AND IN( 集合) LIKE：模糊查询 占位符： _:单个任意字符 %：多个任意字符 IS NULL and 或 &amp;&amp; * or 或 || * not 或 ! 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE '马%'; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE "_化%"; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE '___'; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE '%德%'; 排序查询 语法： order by 子句 排序方式： ASC：升序 DESC：降序 注意： 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 聚合函数将一列数据作为一个整体，进行纵向的计算。 count：计算个数 一般选择非空的列：主键 count(*) max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 注意：聚合函数的计算，排除null值。 解决方案： 选择不包含非空的列进行计算 IFNULL函数 分组查询 语法：group by 分组字段; 注意： 分组之后查询的字段：分组字段、聚合函数 where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 案例： 12345678910111213-- 按照性别分组。分别查询男、女同学的平均分SELECT sex , AVG(math) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 分页查询 语法：limit 起始索引,长度; 公式：起始索引 = （当前的页码 - 1） * 每页显示的条数 limit是一个MySQL“方言” 注意点： limit a,b 在sql语句最后，表示从索引为a的记录开始查询，最多查询b条记录，a可以省略，如果不写，则默认从索引为0的记录开始查询 约束 概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。 分类： 主键约束：primary key 非空约束：not null 唯一约束：unique 外键约束：foreign key 非空约束非空约束：not null，某一列的值不能为null 创建表时添加约束 1234CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空); 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); 默认约束default 创建表时添加约束 123456create table stu ( id INT; name VARCHAR(32) DEFAULT '张三');INSERT INTO stu VALUES(1); -- 不会报错，name有默认值'张三' 删除默认约束 ALTER TABLE stu MODIFY name VARCHAR(32); 创建表之后添加默认约束 ALTER TABLE stu MODIFY name VARCHAR(32) DEFAULT &#39;李四&#39;; 唯一约束唯一约束：unique，某一列的值不能重复 注意： 唯一约束可以有NULL值，而且可以有多个，因为NULL没有数据，不存在重复的问题 在创建表时，添加唯一约束 1234CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 手机号); 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 在表创建完后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; 主键约束主键约束：primary key。 注意： 含义：非空且唯一 一张表只能有一个字段为主键 主键就是表中记录的唯一标识 在创建表时，添加主键约束 1234create table stu( id int primary key,-- 给id添加主键约束 name varchar(20)); 删除主键 12-- 错误 alter table stu modify id int ;ALTER TABLE stu DROP PRIMARY KEY; 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 自动增长： 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 在创建表时，添加主键约束，并且完成主键自增长 1234create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20)); 删除自动增长 ALTER TABLE stu MODIFY id INT; 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 外键约束外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 在创建表时，可以添加外键 12345create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)); 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 级联操作 添加级联操作 语法： 123456ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE; 分类： 级联更新：ON UPDATE CASCADE 级联删除：ON DELETE CASCADE 数据库的设计多表之间的关系 分类 一对一： 如：人和身份证 分析：一个人只有一个身份证，一个身份证只能对应一个人 一对多（多对一）： 如：部门和员工 分析：一个部门有多个员工，一个员工只能对应一个部门 多对多： 如：学生和课程 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 实现关系 一对多(多对一)： 如：部门和员工 实现方式：在多的一方建立外键，指向一的一方的主键。 多对多： 如：学生和课程 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 一对一： 如：人和身份证 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 数据库设计的范式（重点） 概念：设计数据库时，需要遵循的一些规范。 要遵循后边的范式要求，必须先遵循前边的所有范式要求。 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 分类 第一范式（1NF）：每一列都是不可分割的原子数据项 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） 几个概念： 1、函数依赖：A–&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号–&gt;姓名。 （学号，课程名称） –&gt; 分数 2、完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） –&gt; 分数 3、部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） – &gt; 姓名 4、传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号–&gt;系名，系名–&gt;系主任 5、码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） 主属性：码属性组中的所有属性 非主属性：除过码属性组的属性 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原 命令行方式 语法： 备份：mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 还原： 登录数据库 创建数据库 使用数据库 执行文件。source文件路径 图形化工具 DQL：查询表中的记录（多表查询）【重点】笛卡尔积有两个集合A,B .取这两个集合的所有组成情况。 要完成多表查询，需要消除无用的数据 内连接查询使用内连接查询时，要明确以下几点： 从哪些表中查询数据 条件是什么 查询哪些字段 隐式内连接使用where条件消除无用数据 例子： 12345678910111213141516-- 查询所有员工信息和对应的部门信息SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;-- 查询员工表的名称，性别。部门表的名称SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称FROM emp t1, dept t2WHERE t1.`dept_id` = t2.`id`; 显式内连接语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 例如： 12SELECT * FROM emp INNER JOIN dept ON emp.dept_id = dept.id; SELECT * FROM emp JOIN dept ON emp.dept_id = dept.id; 外连接查询左外连接 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； 查询的是左表所有数据以及其交集部分。 例子： 12-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 右外连接 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； 查询的是右表所有数据以及其交集部分。 例子： 1SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 全外连接MySQL不支持full join，Oracle和SQLServer才支持。 语法： 12345SELECT o.Id_o,o.orderNo, p.Id_P,p.name,p.Address,p.CityFROM person pfull join oders o ON o.Id_P = p.Id_P; MySQL要达到全连接的效果，必须使用left join + union + right join 的方式实现，如下： 123SELECT * FROM persons p left join orders o on p.Id_P = o.Id_PunionSELECT * FROM persons p right join orders o ON p.Id_P = o.Id_P; 全连接，满足条件的数据就连接，不满足条件的数据会保留（对两张表中的所有数据都不过滤，只起到了对两张表的笛卡尔积去除重复的作用） 子查询 概念：查询中嵌套查询，称嵌套查询为子查询。 123456789-- 查询工资最高的员工信息-- 1 查询最高的工资是多少 9000SELECT MAX(salary) FROM emp;-- 2 查询员工信息，并且工资等于9000的SELECT * FROM emp WHERE emp.`salary` = 9000;-- 一条sql就完成这个操作。子查询SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); 子查询不同情况 子查询的结果是单行单列的： 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = 12-- 查询员工工资小于平均工资的人SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 子查询的结果是多行单列的： 子查询可以作为条件，使用运算符in来判断 12345-- 查询'财务部'和'市场部'所有的员工信息SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部';SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;-- 子查询SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部'); 子查询的结果是多行多列的： 子查询可以作为一张虚拟表参与查询 1234567-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息-- 子查询SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; '2011-11-11') t2WHERE t1.id = t2.dept_id; -- 普通内连接SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; '2011-11-11' 事务 概念：Transaction，相当于是一个容器（盒子），可以将一个操作的多个步骤（SQL代码）装起来之后，形成了一个不可分割的最小整体（原子性），这个操作整体要么都成功，要么都失败。 使用场景：例如转账操作。 事务的三个操作： 开启事务 start transaction; 回滚：如果事务中至少有一个操作失败，就可以回滚 rollback; 提交事务：如果事务中的多个操作全部成功，就可以提交事务 commit; 事务的提交方式 自动提交 MySQL默认就是自动提交，执行一条DML语句就自动提交一次。 查询默认的提交方式： select @@autocommit; -- 1：自动提交 0：手动提交 修改默认的提交方式： set @@autocommit = 0; -- 修改默认提交方式为手动提交 手动提交 如果自己开启了事务，被事务管理的sql执行完之后，需要手动提交 123start transaction;...commit; 事务的四大特征 原子性：是不可分个的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或者回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间，相互独立。 一致性：事务操作前后，数据总量不变。 事务的隔离级别 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 存在问题： 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别： read uncommitted：读未提交 产生的问题：脏读、不可重复读、幻读 read committed：读已提交 （Oracle默认级别） 产生的问题：不可重复读、幻读 repeatable read：可重复读 （MySQL默认级别） 产生的问题：幻读 serializable：串行化 可以解决所有的问题 - 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 - 数据库查询隔离级别：`select @@tx_isolation;` - 数据库设置隔离级别：`set global transaction isolation level 级别字符串;` 演示： 12345set global transaction isolation level read uncommitted;start transaction;-- 转账操作update account set balance = balance - 500 where id = 1;update account set balance = balance + 500 where id = 2; DCL：访问控制 对数据库用户的增删改查 添加用户 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;; 删除用户 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;; 修改用户密码 方式1：切到mysql数据库，然后使用普通的update语句修改。 update user set password = password(&#39;新密码&#39;) where user = &#39;用户名&#39;; 方式2：set password for &#39;用户名&#39;@&#39;主机名&#39; = password(&#39;新密码&#39;); mysql中忘记了root用户的密码？ 1234567891011找回密码步骤：1、cmd -- &gt; net stop mysql 停止mysql服务 tips：需要管理员运行该cmd2、使用无验证方式启动mysql服务： mysqld --skip-grant-tables3、打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功4、use mysql;5、update user set password = password('你的新密码') where user = 'root';6、关闭两个窗口7、打开任务管理器，手动结束mysqld.exe 的进程8、启动mysql服务9、使用新密码登录。 查询用户 123456-- 1. 切换到mysql数据库USE mysql;-- 2. 查询user表SELECT * FROM USER;tips：通配符 % 表示可以在任意主机使用用户登录数据库 对数据库用户的权限管理 查询用户现有的权限 1234-- 查询权限SHOW GRANTS FOR '用户名'@'主机名';-- 例子SHOW GRANTS FOR 'lisi'@'%'; 为用户授予权限 1234-- 授予权限grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';-- 给张三用户授予所有权限，在任意数据库任意表上GRANT ALL ON *.* TO 'zhangsan'@'localhost'; 撤销用户权限 123-- 撤销权限：revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%';]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>-MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE Error Log]]></title>
    <url>%2FJava%2FJavaSE-Error-Log%2F</url>
    <content type="text"><![CDATA[Java中protected方法访问权限的问题在cn.skywalker.test05包下的Student类： 123456789101112package cn.skywalker.test05;/** * @author SkyWalker * @create 2019 - 06 - 29 - 19:40 */public class Student &#123; protected void display()&#123; System.out.println("display....."); &#125;&#125; 在cn.skywalker.test06包下的Test类： 12345678910111213141516171819package cn.skywalker.test06;import cn.skywalker.test05.Student;/** * @author SkyWalker * @create 2019 - 06 - 29 - 20:13 */public class Test extends Student&#123; public static void main(String[] args) &#123; Student student = new Student();// student.display(); //在不同包实例化Student类对象，该对象对Student类中声明的protected方法的调用不属于本类调用 Test t = new Test(); t.display(); &#125;&#125; 这里我用cn.skywalker.test06包下的Test类继承了cn.skywalker.test05包下的Student类，但是在Test类中的main()函数中实例化了一个Student对象，该对象却无法调用Student类中使用protected修饰的方法。 这里再给出《java in a nutshell》中的一段话： protected access requires a little more elaboration. Suppose class A declares a protected field x and is extended by a class B, which is defined in a different package (this last point is important). Class B inherits the protected field x, and its code can access that field in the current instance of B or in any other instances of B that the code can refer to. This does not mean, however, that the code of class B can start reading the protected fields of arbitrary instances of A! If an object is an instance of A but is not an instance of B, its fields are obviously not inherited by B, and the code of class B cannot read them. 翻译：protected访问是需要一些准备的。假如类A定义了一个protected的属性x，并且被定义在不同包中的类B扩展了类A。A和B不再同一个包内这一点非常重要。从而，B继承了A的protected属性x，而且在当前B 的实例中这个属性是能够被访问的又或者其他代码中涉及到访问这个属性的B的实例中也是可以访问这个属性的。然而，这并不表示B 的代码可以任意访问A的实例中protected修饰的属性！如果一个对象是A而不是B的实例，显然B是没有继承该对象的属性的，从而B的代码无法访问它们。 方法的访问控制： public protected default private 同类 ✔ ✔ ✔ ✔ 同包 ✔ ✔ ✔ 子类（不同包） ✔ ✔ 不同包中无继承关系的类 ✔ 使用同名局部变量的问题话不多说，直接上代码： 12345678910111213141516171819public class Test &#123; public int age = 5; //成员变量age，默认初始化值为5 public void setAge(int age)&#123; //成员方法，有一个局部变量形参age age = age; &#125; public int getAge()&#123; //成员方法，返回成员变量age的值 return this.age; &#125; public static void main(String[] args)&#123; //主函数 //创建对象，进行测试 Test t = new Test(); t.setAge(10); System.out.println(t.getAge()); //运行结果为5 &#125;&#125; 很明显，我们能看到在Test类中的setAge(int age)方法中，没有使用this关键字对成员变量age进行赋值。而且从运行结果来看，不难发现，在setAge(int age)方法中age = age;这句代码，两个age均指的是形参age这个局部变量。如没有用this显式指明age，则会遵循就近原则，就会发生局部变量age对自己赋值的情况。 局部变量使用范围问题123456789101112131415161718class Demo&#123; String s = "Outer"; public static void main(String[] args)&#123; S2 s2 = new S2(); s2.display(); &#125;&#125;class S1&#123; String s = "S1"; public void display()&#123; System.out.println(s); &#125;&#125;class S2 extends S1&#123; String s = "S2";&#125; 代码如上所示，最终运行结果为S1。 可以总结出：就近原则在使用时，应注意方法对变量的调用也是遵循就近原则的。 多态中关于变量的使用1234567891011121314151617181920212223public class Demo&#123; public static void main(String[] args)&#123; Fu f = new Zi(); System.out.println(f.a); f.method;//这是子类的method方法 &#125;&#125;class Fu&#123; int a = 1; public void method()&#123; System.out,println("这是父类的method方法"); &#125;&#125;class Zi extends Fu&#123; int a = 2; public void method()&#123; System.out.println("这是子类的method方法"); &#125;&#125; 代码如上所示。 我的错误选项： 如果将父类中的成员变量a删除，修改代码如下： 12345class Fu&#123; public void method()&#123; System.out,println("这是父类的method方法"); &#125;&#125; 则运行结果为： 122这是子类的method方法 上面的选项是错误的。正确的运行结果为：编译器报错。 因为如果将Fu类中的成员变量a删除后，在Demo的主函数中f.a的用法将会无法通过编译。 关于println()与toString()的联系12345678910111213141516public class ToStringTest &#123; static int i = 1; public static void main(String args[]) &#123; // 调用ToStringTest的 toString方法 System.out.println("love " + new ToStringTest()); ToStringTest a = new ToStringTest(); a.i++; System.out.println("me " + a.i); &#125; public String toString() &#123; System.out.print("I "); return "java "; &#125;&#125; 运行结果： 12I love java me 2 从结果中，猛一下似乎看不太明白，但静下心来仔细分析，我们会发现在主函数的第一句代码 System.out.println(&quot;love &quot; + new ToStringTest()); 执行过程中，JVM优先解析了 “ + “后面的new ToStringTest()，而我们知道，在JVM调用println()时，底层是调用了该Object对象的toString()方法，所以会最先执行ToStringTest类中重写的toString()方法。结果也就在逻辑之中了。 String类型的深度解析String的本质打开String的源码，类注释中有这么一段话 “Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings.Because String objects are immutable they can be shared.”。 这句话总结归纳了String的一个最重要的特点： String是值不可变(immutable)的常量，是线程安全的(can be shared)。 接下来，String类使用了final修饰符，表明了String类的第二个特点：String类是不可继承的。 下面是String类的成员变量定义，从类的实现上阐明了String值是不可变的(immutable)。 private final char value[]; private final int count; 因此，我们看String类的concat方法。实现该方法第一步要做的肯定是扩大成员变量value的容量，扩容的方法重新定义一个大容量的字符数组buf。第二步就是把原来value中的字符copy到buf中来，再把需要concat的字符串值也copy到buf中来，这样子，buf中就包含了concat之后的字符串值。下面就是问题的关键了，如果value不是final的，直接让value指向buf，然后返回this，则大功告成，没有必要返回一个新的String对象。但是。。。可惜。。。由于value是final型的，所以无法指向新定义的大容量数组buf，那怎么办呢？“return new String(0, count + otherLen, buf);”，这是String类concat实现方法的最后一条语句，重新new一个String对象返回。这下真相大白了吧！ ​ 总结：String实质是字符数组，两个特点： 该类不可被继承 不可变性(immutable)。 12345String s1 = "ab";String s2 = "abc";String s3 = s1 + "c";System.out.println(s3 == s2); //falseSystem.out.println(s3.equals(s2)); //true 1234String s1 = "a" + "b" + "c";String s2 = "abc";System.out.println(s1 == s2);//trueSystem.out.println(s1.equals(s2));//true java网络编程Socket文件上传过程中的中文乱码问题文件上传功能的实现 要求 1、开启文件上传服务器后，侦听TCP连接，若有新连接，则创建一条新的线程去处理连接。 2、文件上传的流程： 123456789101112131415161718192021222324（1） 客户端要求用户录入一个文件路径。客户端对路径进行合理性判断。 （2） 第一次通信： 如果路径正确，则客户端将文件名（getName()方法）发送给服务器。服务器进行接收。 （3） 第二次通信： 服务器接收到文件名后，判断给定的目录中是否存在该文件（exists()方法）， 如果不存在，则反馈false;如果存在则反馈true。 客户端等待反馈结果。 （4） 第三次通信（文件复制的核心部分）： if (反馈为false) &#123; 客户端：将文件读入，通过socket输出流传递 服务器端：通过socket输入流接收，将文件写出 &#125; else &#123; 提示文件已存在，上传失败 &#125; （5） 第四次通信： 复制成功后，服务器反馈复制成功信息。 问题解决很简单（突然感觉自己好蠢）： 不要使用windows自带的鼠标右键新建-&gt;新建文本文档。因为会默认使用GBK格式。 需要使用一些UTF-8编码格式的或者其他格式的都可以识别，只要编码解码格式相同，就不会出现乱码问题。 关于java中true和false是否为Object类型的问题在调用方法时，形参要求的是Object类型，我传了一个false进去，没报错也运行出来了，然后就有点小疑惑，仔细想了想，想到了boolean的包装类Boolean。在参数传进去的时候，应该是把false当作一个Boolean类型了。 Scanner类中next()和nextLine()的区别对于键盘录入对象Scanner对象的两个录入字符串方法的区别Scanner sc = new Scanner(System.in);sc.next()和 sc.nextLine();的区别next() 对于录入的字符串碰到空格就会停止录入nextLine()会把整行字符串全部录入并且sc.next() 在录入字符串后会在尾部加一个 \r\n 因而sc.nextLine()会录入 \r\n 而导致原来nextLine要录入的字符串没有录入 1234567891011121314//例1：import java.util.Scanner;public class nextAndNextLine &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(“请输入第一个字符串”); String a = sc.next(); System.out.println(“请输入第二个字符串”); String b = sc.nextLine(); System.out.println(“字符串1:” + a); System.out.println(“字符串2:” + b); sc.close(); &#125;&#125; 运行结果： 请输入第一个字符串 abc 请输入第二个字符串 字符串1：abc 字符串2： 这里我们可以看出来我们本来要录入两个字符串，但是只录入和打印了一个字符串，这个原因是next()方法会在尾部加一个换行符，windows系统的换行符是\r\n,因而后面的nextLine()方法将\r\n录入进去，从而造成第二次没有录入字符串的情况。 1234567891011121314//例2：import java.util.Scanner;public class nextAndNextLine &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(“请输入第一个字符串”); String a = sc.nextLine(); System.out.println(“请输入第二个字符串”); String b = sc.next(); System.out.println(“字符串1:” + a); System.out.println(“字符串2:” + b); sc.close(); &#125;&#125; 运行结果： 请输入第一个字符串 abc 请输入第二个字符串 字符串1：abc 字符串2：abc 这时候我们可以看到,键盘允许你录入两个数据,并且正确的输出了两个数据。这里我们可以看出nextLine()方法后面并不会加默认的符号，因此我建议录入字符串尽量用nextLine方法。 1234567891011121314//例3：import java.util.Scanner;public class nextAndNextLine &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(“请输入第一个字符串”); String a = sc.nextLine(); System.out.println(“请输入第二个字符串”); String b = sc.next(); System.out.println(“字符串1:” + a); System.out.println(“字符串2:” + b); sc.close(); &#125;&#125; 运行结果： 请输入第一个字符串 abc 请输入第二个字符串 ab c 字符串1：abc 字符串2：ab 这里我们可以看出来，next()方法碰到空格就会停止录入,因此只录入abc，而nextLine()方法会将这行字符串全部录入。因此建议用nextLine()方法录入字符串。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-ErrorLog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE]]></title>
    <url>%2FJava%2FJavaSE%2F</url>
    <content type="text"><![CDATA[环境变量的配置 右键 “我的电脑” – “属性” – “高级系统设置” – “高级” – “环境变量” 打开环境变量设置。 新建系统变量“JAVA_HOME”，值的内容为JDK的根目录。 在“Path”环境变量的值中，增加“%JAVA_HOME%\bin;” 此时再使用cmd即可直接使用javac和java命令。 JDK9的JShell的简单使用直接在cmd中输入jshell，回车，即可启动JShell。 JShell一般用于极其简单、轻量的情况。 编译器的两点优化（对于变量的赋值）第一个优化对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。 如果没有超过左侧的范围，编译器补上强转。 如果右侧超过了左侧范围，那么直接编译器报错。 123456789101112131415public class Demo01 &#123; public static void main(String[] args) &#123; // 右侧确实是一个int数字，但是没有超过左侧的范围，就是正确的。 // int --&gt; byte, 不是自动类型转换 byte num1 = /*(byte)*/ 30; // 右侧没有超过左侧范围 System.out.println(num1); // 30 // byte num2 = 128; // 右侧超过了左侧的范围，编译器报错 // int --&gt; char, 没有超过范围 // 编译器将会自动补上一个隐含的(char) char c1 = /*(char)*/ 65; System.out.println(c1); // A &#125; &#125; 第二个优化在给变量进行赋值的时候，如果右侧的表达式当中全部都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。 short result = 5 + 8; // 等号右边全部都是常量，没有任何变量参与运算 编译之后，得到的.class字节码文件当中相当于【直接就是】： short result = 13; 右侧的常量结果数值，没有超过左侧范围，所以正确。 这称为“编译器的常量优化” 但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。 12345678910111213141516public class Demo02 &#123; public static void main(String[] args) &#123; short num1 = 10; // 正确写法，右侧没有超过左侧范围 short a = 5; short b = 8; // short + short --&gt; int + int --&gt; int // short result = a + b; // 错误写法！左侧需要是int类型 // 右侧不用变量，而是采用常量，而且只有两个常量，没有别人 short result = 5 + 8; System.out.println(result); short result2 = 5 + a + 8; // 结果应该是18，但是编译器报错 &#125;&#125; switch语句使用的注意事项 多个case后面的数值不可以重复 switch后面小括号当中只能是下列数据类型： 基本数据类型：byte / short / char / int 引用数据类型：String字符串 / enum枚举 switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。 匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者switch的整体结束为止。 关于switch的穿透代码示例： 123456789101112131415public class Debug01 &#123; public static void main(String[] args) &#123; int a = 1; switch (a) &#123; case 1: System.out.println("1."); case 2: case 3: default: // switch的穿透，所以会执行下面的输出语句。 System.out.println("default."); &#125; &#125;&#125; 代码的运行结果为： 121.default. 数组的定义 方式1： 动态初始化：数据类型[] 数组名称 = new 数据类型[数组长度]; 方式2： 标准的静态初始化：数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … }; 方式3： 省略的静态初始化：数据类型[] 数组名称 = { 元素1, 元素2, … }; 注意事项： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。 静态初始化标准格式可以拆分成为两个步骤。 动态初始化也可以拆分成为两个步骤。 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。 使用建议：如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。 1234567891011121314151617181920public class Demo03 &#123; public static void main(String[] args) &#123; // 省略格式的静态初始化 int[] arrayA = &#123; 10, 20, 30 &#125;; // 静态初始化的标准格式，可以拆分成为两个步骤 int[] arrayB; arrayB = new int[] &#123; 11, 21, 31 &#125;; // 动态初始化也可以拆分成为两个步骤 int[] arrayC; arrayC = new int[5]; // 静态初始化的省略格式，不能拆分成为两个步骤。// int[] arrayD;// arrayD = &#123; 10, 20, 30 &#125;; &#125;&#125; 数组中的内存图 Random类 作用：用于产生一个随机数 所属包：java.util.Random 格式： 12Random random = new Random();int number = random.nextInt(int index); // 获取数据的范围：[0,index) 左闭右开的一个区间。 拓展： Math类下的static double random()方法的返回值为double。值为正号，大于等于 0.0 ，小于 1.0 。 即获取数据的范围：[0.0, 1.0) 左闭右开的一个区间。 常用案例： 生成一个1~100的随机数字 1234int num = (int)(Math.random() * 100) + 1; // 使用Math类下的random()静态方法Random r = new Random();int num1 = r.nextInt(100) + 1; // 使用Random类生成 方法重载的注意点 与返回值类型无关 123456789public class MethodDemo&#123; public static void fn(int a)&#123; //method body &#125; public static int fn(int a)&#123; //method body &#125;&#125; 上面的代码不构成方法的重载：因为形参列表相同。虽然返回值类型不同，但方法重载与返回值类型无关。 集成开发环境IntelliJ IDEA IDE（Integrated Development Environment）集成开发环境。 至于本章主题描述 一句话 IDEA牛逼。。。OK就这样233 IDEA中Debug的使用如何加断点选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可。 如何运行加了断点的程序在代码区域右键Debug执行。 看哪里看Debugger窗口 点哪里点Step Into（F7）这个箭头，也可以直接按F7，运行完之后，点击Stop结束。 如何删除断点选择要删除的断点，单击鼠标左键即可。 如果是多个断点，可以每一个再点击一次，也可以一次性全部删除。 注意事项如果数据来自于键盘输入（Scanner），一定要记住输入数据，不然就不能继续往下查看了。 Java中的内存分配JVM简介 Java虚拟机（Java Virtual Machine 简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 一个运行时的Java虚拟机实例的天职是：负责运行一个java程序。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。 JVM的体系结构包含几个主要的子系统和内存区： 垃圾回收器（Garbage Collection）：负责回收堆内存（Heap）中没有被使用的对象，即这些对象已经没有被引用了。 类装载子系统（ClassLoader Sub-System）：除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。 执行引擎（Execution Engine）：负责执行那些包含在被装载类的方法中的指令。 运行时数据区（Java Memory Allocation Area）：又叫虚拟机内存或者Java内存，虚拟机运行时需要从整个计算机内存划分一块内存区域存储许多东西。例如：字节码、从已装载的class文件中得到的其他信息、程序创建的对象、传递给方法的参数，返回值、局部变量等等。 Java内存分区从上节知道，运行时数据区即是java内存，而且数据区要存储的东西比较多，如果不对这块内存区域进行划分管理，会显得比较杂乱无章。 根据存储数据的不同，java内存通常被划分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Method Area）、栈（Stack）、堆（Heap）。 程序计数器（Program Count Register）：又叫程序寄存器。JVM支持多个线程同时运行，当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）。如果线程正在执行的是一个Java方法（非native），那么PC寄存器的值将总是指向下一条将被执行的指令，如果方法是 native的，程序计数器寄存器的值不会被定义。 JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。 栈（Stack）：又叫堆栈。JVM为每个新创建的线程都分配一个栈。也就是说,对于一个Java程序来说，它的运行就是通过对栈的操作来完成的。栈以帧为单位保存线程的状态。JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。我们知道,某个线程正在执行的方法称为此线程的当前方法。我们可能不知道，当前方法使用的帧称为当前帧。当线程激活一个Java方法，JVM就会在线程的 Java堆栈里新压入一个帧，这个帧自然成为了当前帧。在此方法执行期间，这个帧将用来保存参数、局部变量、中间计算过程和其他数据。从Java的这种分配机制来看,堆栈又可以这样理解：栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。 方法区（Method Area）：当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，如下图所示。本地方法区存在一块特殊的内存区域，叫常量池（Constant Pool），这块内存将与String类型的分析密切相关。 堆（Heap）：Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。在此区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存，但是这个对象的引用却是在栈（Stack）中分配。因此，执行String s = new String(“s”)时，需要从两个地方分配内存：在堆中为String对象分配内存，在栈中为引用（这个堆对象的内存地址，即指针）分配内存。 继承 格式：public class 子类名 extends 父类名 { } 范例：public class Zi extends Fu { } 代码范例： 1234567891011121314151617181920212223public class Demo04 &#123; public static void main(String[] args) &#123; //创建对象，调用方法 Fu f = new Fu(); f.show(); Zi z = new Zi(); z.method(); z.show();//调用继承于父类的show方法 &#125;&#125;class Fu &#123; public void show()&#123; System.out.println("父类的show方法"); &#125;&#125;class Zi extends Fu &#123; public void method()&#123; System.out.println("子类的method方法"); &#125;&#125; 注意：父类的构造器无法继承下来，如需调用，使用super关键字即可。 继承的好处与弊端 好处： 提高了代码的 复用性（多个类相同的成员可以放到同一个类中） 提高了代码的 维护性（如果方法的代码需要修改，修改一处即可） 弊端： 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性 继承体现的关系： is a 继承中成员变量的访问特点通过子类对象访问一个变量 ，遵循就近原则： 先找局部范围 再找子类成员范围 再找父类成员范围 如果都没有就报错(不考虑父亲的父亲…) 继承中成员方法的访问特点与成员变量的“就近原则”类似。 再找子类成员范围 再找父类成员范围 如果都没有就报错(不考虑父亲的父亲…) 继承中构造函数的访问特点 子类会继承父类的数据，可能还会使用父类的数据。所以子类初始化之前，一定要先完成父类的初始化。 每一个子类构造方法的第一条语句默认都是：super(); 如果想要控制子类的构造方法调用父类的哪一个构造方法，使用super进行调用即可。 示例代码： 1234567891011121314151617181920212223242526272829public class Demo05 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); &#125;&#125;class Fu &#123; public Fu() &#123; System.out.println("Fu的无参"); &#125; public Fu(int age) &#123; System.out.println("Fu的有参"); &#125;&#125;class Zi extends Fu &#123; public Zi() &#123;// super();//调用父类的无参构造函数 super(10);//调用父类的有参构造函数 System.out.println("Zi的无参"); &#125; public Zi(int age) &#123; //默认调用super();即无参构造函数，可以使用super(int值)显式调用父类的有参构造函数 super(10); System.out.println("Zi的有参"); &#125;&#125; Super内存图 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 方法重写 在重写方法时，可以在声明前加入@Override注解，可以帮助我们检查我们要重写的方法声明是否错误 父类中私有的方法不能被重写 子类的方法的声明和父类的方法的声明一般一致，但是有些地方可以不一致，遵循以下原则： 一大：子类重写的方法的权限修饰符必须大于或者等于父类方法的权限修饰符 private &lt; default &lt; protected &lt; public 两同： 方法名必须相同 参数列表必须相同 两小： 子类重写的方法的返回值类型必须小于等于父类方法的返回值类型（针对的是引用类型，一般小于说的是子类与父类的关系，对基本类型无效） 子类重写的方法抛出的异常必须小于等于或者少于等于父类的方法抛出的异常，如果父类方法没有抛出异常，则子类重写之后的方法绝对不能抛出异常 继承的注意事项 Java中的类只支持单继承，不支持多继承（一个类只能有一个父类） Java中的类支持多层继承 final、static修饰符 final修饰符： 修饰方法：该方法无法被重写 修饰变量：该变量无法被赋值 修饰类：该类无法被继承 static修饰符： 被类的所有对象共享 可以通过类名调用 非静态的成员方法 能访问静态的成员变量 能访问非静态的成员变量 能访问静态的成员方法 能访问非静态的成员方法 静态的成员方法 能访问静态的成员变量 能访问静态的成员方法 总结成一句话就是：静态成员方法只能访问静态成员 示例代码： 123456789101112131415161718192021222324class Student &#123; public String name; //姓名 public int age; //年龄 public static String university; //学校 共享数据！所以设计为静态！ public void show() &#123; System.out.println(name + "," + age + "," + university); &#125;&#125;public class Demo06 &#123; public static void main(String[] args) &#123; // 为对象的共享数据赋值 Student.university = "Tsinghua"; Student s1 = new Student(); s1.name = "lcw"; s1.age = 30; s1.show(); Student s2 = new Student(); s2.name = "ld"; s2.age = 33; s2.show(); &#125;&#125; 多态 概念 一个事物在不同情况下表现出的多种形态 前提 有继承/实现关系 有方法的重写（不一定是必须有） 父类的引用指向子类的对象 多态中成员访问的特点 成员变量：编译看左边（父类），运行看左边（父类） 成员方法：编译看左边（父类），运行看右边（子类） 总结：编译都看左边，运行也都看左边（非静态的成员方法除外）。 多态的好处与弊端 好处：提高了程序的扩展性 弊端：不能使用子类的特有属性、功能 多态的转型（引用类型的转换） 向上转型：小类型（子类）转为大类型（父类），自动转 格式：父类类型 变量名 = 子类对象; 比如：Animal a = new Cat(); 其实多态的体现就是向上转型 向下转型：大类型（父类）转为小类型（子类），强制转 格式：子类类型 对象名 = （子类类型）父类类型的对象名; 比如：Cat c = (Cat)a; 抽象类 概念：使用abstract关键字修饰的类 格式：public abstract class 类名 { } 抽象类的特点 抽象类和抽象方法必须使用 abstract 关键字修饰 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类 抽象类不能实例化 抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态 抽象类的子类 要么重写抽象类中的所有抽象方法 要么是抽象类 抽象类的成员特点 成员变量 既可以是变量 也可以是常量 构造方法 空参构造 有参构造 成员方法 抽象方法 普通方法 接口 概念：公共的规范和标准，只要按照这些规范来就可以正确使用 接口的特点 接口用关键字interface修饰 1public interface 接口名 &#123;&#125; 类实现接口用implements表示 1public class 类名 implements 接口名 &#123;&#125; 接口不能实例化 接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。 多态的形式：具体类多态，抽象类多态，接口多态。 接口的子类 要么重写接口中的所有抽象方法 要么子类也是抽象类 内部类 概念：就是在一个类中定义一个类 格式 ： 1234public class 类名&#123; 修饰符 class 类名&#123; &#125;&#125; ​ 内部类的访问特点 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 分类 成员内部类 局部内部类 匿名内部类 常用API工具类设计思想 构造方法用 private 修饰 成员用 public static 修饰 java.util.Arrays public static String toString(int[] a) ：将指定给定数组以指定格式的字符串返回 [元素1, 元素2, 元素3] 如果直接使用System.out.println()打印一个数组，其实得到的是地址值（字符数组除外，字符数组打印出来的是元素内容） public static void sort(int[] a) ：将指定的数组元素进行排序，默认升序排列 java.util.Math 1、Math类概述 Math 包含执行基本数字运算的方法 2、Math中方法的调用方式 Math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用 3、Math类的常用方法 | 方法名 方法名 | 说明 || ———————————————- | ———————————————- || public static int abs(int a) | 返回参数的绝对值 || public static double ceil(double a) | 返回大于或等于参数的最小double值，等于一个整数 || public static double floor(double a) | 返回小于或等于参数的最大double值，等于一个整数 || public static int round(float a) | 按照四舍五入返回最接近参数的int || public static int max(int a,int b) | 返回两个int值中的较大值 || public static int min(int a,int b) | 返回两个int值中的较小值 || public static double pow (double a,double b) | 返回a的b次幂的值 || public static double random() | 返回值为double的正值，[0.0,1.0) | java.lang.Object toString() equals() java.lang.System System类的常用方法 方法名 说明 public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前时间(以毫秒为单位) java.util.Date void setTime(long millis) long getTime() Date()：代表的当前系统时间 Date(long millis)：代表基准时间+毫秒值落到的时间 java.text.SimpleDateFormat SimpleDateFormat(String str) String format(Date d) Date parse(String str) java.util.Calendar get(int field) void set(int year, int month, int date) setTime(Date date) add(int field,int amount) 注意： 月份是从0~11 ，0表示1月，1表示2月，以此类推… 星期是从1-7，1表示星期日，2表示星期一，以此类推… 包装类 基本类型包装类的作用 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 基本类型对应的包装类 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean Integer经典使用案例（String与int类型转换） int —&gt; String 方式一： 123int num = 100;String s1 = num + "";System.out.println(s1); 方式二： 123int num = 100;String s2 = String.valueOf(num);System.out.println(s2); 方式三： 123int num = 100;String s3 = Integer.toString(num);System.out.println(s3); String —&gt; int 方式一： 1234String s = "100";Integer i = Integer.valueOf(s);int x = i.intValue();System.out.println(x); 方式二： 123String s = "100";int y = Integer.parseInt(s);System.out.println(s); 案例： 需求：有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：“27 38 46 50 91” 思路： 定义一个字符串 把字符串中的数字数据存储到一个int类型的数组中 得到字符串中每一个数字数据？ public String[] split(String regex) 定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中 public static int parseInt(String s) 对 int 数组进行排序 把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现 输出结果 代码： 1234567891011121314151617181920212223242526public class IntegerTest &#123; public static void main(String[] args) &#123; //定义一个字符串 String s = "91 27 46 38 50"; //把字符串中的数字数据存储到一个int类型的数组中 String[] strArray = s.split(" "); int arr[] = new int[strArray.length]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = Integer.parseInt(strArray[i]); &#125; //对 int 数组进行排序 Arrays.sort(arr); //把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现 StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; if (i == arr.length - 1) &#123; sb.append(arr[i]); &#125; else &#123; sb.append(arr[i]).append(" "); &#125; &#125; //输出结果 System.out.println(sb); &#125;&#125; Integer的注意点：在自动装箱与自动拆箱的过程中，同样的赋值语句，可能对应不同的地址。例如： 1234567Integer i1 = Integer.valueOf(100);Integer i2 = Integer.valueOf(100);System.out.println(i1 == i2); // trueInteger i3 = Integer.valueOf(200);Integer i4 = Integer.valueOf(200);System.out.println(i3 == i4); // false 然后我们扒Integer的源码，发现： 123456789101112131415public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; int h = 127; high = h; //然后是其他部分的源码，不再赘述，只取部分说明 ...&#125; 异常异常的概念 程序在编译或者运行的过程中出现的错误 Java中的异常指的都是异常类 异常类的体系 Throwable Error：不研究 Exception 编译时异常（检查异常）：Exception下除了RuntimeException及其子类之外的都是编译时异常 运行时异常（非检查异常）：RuntimeException及其子类都是运行时异常 集合 集合的体系结构： 单列集合： Collection接口 List接口：可以存储重复元素、存取有序、有索引可以根据索引操作元素 ArrayList类 LinkedList类 Set接口：不可以存储重复元素、存取无序、无索引不可以根据索引操作元素 HashSet类 TreeSet类 双列集合： Map接口 HashMap类 单列集合Collection常用方法： 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定的元素 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合中是否存在指定的元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中元素的个数 List接口存储的数据是可重复的、与添加顺序一致的（存取有序） ArrayList集合 ​ 底层是数组结构实现，查询快、增删慢 LinkedList集合 ​ 底层是链表结构实现，查询慢、增删快 ArrayList特有的常用方法： 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 List中，使用迭代器Iterator可能会导致并发修改异常的情况： 出现的原因 ​ 迭代器遍历的过程中，通过集合对象修改了集合中的元素 （添加和删除），造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：ConcurrentModificationException 解决的方案 ​ 用for循环遍历，然后用集合对象做对应的操作即可 示例代码 123456789101112131415161718192021222324252627282930public class ListDemo &#123; public static void main(String[] args) &#123; //创建集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add("hello"); list.add("world"); list.add("java"); //遍历集合，得到每一个元素，看有没有"world"这个元素，如果有，我就添加一个"javaee"元素，请写代码实现// Iterator&lt;String&gt; it = list.iterator();// while (it.hasNext()) &#123;// String s = it.next();// if(s.equals("world")) &#123;// list.add("javaee");// &#125;// &#125; for(int i=0; i&lt;list.size(); i++) &#123; String s = list.get(i); if(s.equals("world")) &#123; list.add("javaee"); &#125; &#125; //输出集合对象 System.out.println(list); &#125;&#125; 列表迭代器 ListIterator介绍 通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器 用于允许程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置 示例代码 1234567891011121314151617181920212223public class ListIteratorDemo &#123; public static void main(String[] args) &#123; //创建集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add("hello"); list.add("world"); list.add("java"); //获取列表迭代器 ListIterator&lt;String&gt; lit = list.listIterator(); while (lit.hasNext()) &#123; String s = lit.next(); if(s.equals("world")) &#123; lit.add("javaee"); &#125; &#125; System.out.println(list); &#125;&#125; LinkedList集合的特有功能 特有方法 | 方法名 | 说明 || ————————- | ——————————– || public void addFirst(E e) | 在该列表开头插入指定的元素 || public void addLast(E e) | 将指定的元素追加到此列表的末尾 || public E getFirst() | 返回此列表中的第一个元素 || public E getLast() | 返回此列表中的最后一个元素 || public E removeFirst() | 从此列表中删除并返回第一个元素 || public E removeLast() | 从此列表中删除并返回最后一个元素 | Set接口方法与List接口几乎一模一样。 主要实现类有HashSet、TreeSet、LinkedHashSet。 存储的数据是不可重复的、不保证与添加顺序一致的（存取无序）。 双列集合MapMap集合的特点 键值对映射关系 一个键对应一个值 键不能重复，值可以重复 元素存取无序 方法介绍 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 根据键删除键值对元素 void clear() 移除所有的键值对元素 boolean containsKey(Object key) 判断集合是否包含指定的键 boolean containsValue(Object value) 判断集合是否包含指定的值 boolean isEmpty() 判断集合是否为空 int size() 两种遍历方式： keySet() entrySet() Collections工具类常用方法： shuffle() reverse() sort() IOFile类构造方法 File(String pathname) File(String parent , String child) File(File parent , String child) 常用方法 创建文件 boolean createNewFile() 创建文件 创建文件夹 boolean mkdir() 创建目录 boolean mkdirs() 创建多级目录 判断 boolean isDirectory() boolean isFile() boolean exists() 获取 String getAbsolutePath() String getPath() String getName() String[] list 获取当前文件夹下，所有的文件或者单级子文件夹名称数组 File[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 删除 boolean delete() API中没有直接提供级联删除方法，只提供了这一个删除方法，如果调用此方法的File是非空目录，则会拒绝删除请求，返回false。 IO流的体系【IO重点】 字节流 InputStream FileInputStream BufferedInputStream OutputStream FileOutputStream BufferedOutputStream 字符流 Reader InputStreamReader FileReader BufferedReader Writer OutputStreamWriter FileWriter BufferedWriter Properties（集合与IO相结合）Properties作为Map集合的使用 Properties介绍 是一个Map体系的集合类 Properties可以保存到流中或从流中加载 属性列表中的每个键及其对应的值都是一个字符串 Properties基本使用 12345678910111213141516171819public class PropertiesDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象// Properties&lt;String,String&gt; prop = new Properties&lt;String,String&gt;(); //错误 Properties prop = new Properties(); //存储元素 prop.put("it001", "lcw"); prop.put("it002", "ld"); prop.put("it003", "lgl"); //遍历集合 Set&lt;Object&gt; keySet = prop.keySet(); for (Object key : keySet) &#123; Object value = prop.get(key); System.out.println(key + "," + value); &#125; &#125;&#125; Properties作为Map集合的特有方法 特有方法 | 方法名 | 说明 || ———————————————- | ———————————————————— || Object setProperty(String key, String value) | 设置集合的键和值，都是String类型，底层调用 Hashtable方法 put || String getProperty(String key) | 使用此属性列表中指定的键搜索属性 || Set stringPropertyNames() | 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 | 示例代码 12345678910111213141516171819202122232425262728293031323334public class PropertiesDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Properties prop = new Properties(); //Object setProperty(String key, String value)：设置集合的键和值，都是String类型，底层调用Hashtable方法put prop.setProperty("it001", "lcw"); /* Object setProperty(String key, String value) &#123; return put(key, value); &#125; Object put(Object key, Object value) &#123; return map.put(key, value); &#125; */ prop.setProperty("it002", "ld"); prop.setProperty("it003", "lgl"); //String getProperty(String key)：使用此属性列表中指定的键搜索属性// System.out.println(prop.getProperty("it001"));// System.out.println(prop.getProperty("it0011"));// System.out.println(prop); //Set&lt;String&gt; stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 Set&lt;String&gt; names = prop.stringPropertyNames(); for (String key : names) &#123;// System.out.println(key); String value = prop.getProperty(key); System.out.println(key + "," + value); &#125; &#125;&#125; Properties和IO流相结合的方法 和IO流结合的方法 | 方法名 | 说明 || ———————————————– | ———————————————————— || void load(InputStream inStream) | 从输入字节流读取属性列表（键和元素对） || void load(Reader reader) | 从输入字符流读取属性列表（键和元素对） || void store(OutputStream out, String comments) | 将此属性列表（键和元素对）写入此 Properties表中，以适合于使用 load(InputStream)方法的格式写入输出字节流 || void store(Writer writer, String comments) | 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 | 示例代码 12345678910111213141516171819202122232425262728293031323334public class PropertiesDemo03 &#123; public static void main(String[] args) throws IOException &#123; //把集合中的数据保存到文件// myStore(); //把文件中的数据加载到集合 myLoad(); &#125; private static void myLoad() throws IOException &#123; Properties prop = new Properties(); //void load(Reader reader)： FileReader fr = new FileReader("myOtherStream\\fw.txt"); prop.load(fr); fr.close(); System.out.println(prop); &#125; private static void myStore() throws IOException &#123; Properties prop = new Properties(); prop.setProperty("it001","lcw"); prop.setProperty("it002","ld"); prop.setProperty("it003","lgl"); //void store(Writer writer, String comments)： FileWriter fw = new FileWriter("myOtherStream\\fw.txt"); prop.store(fw,null); fw.close(); &#125;&#125; 游戏次数案例 案例需求 实现猜数字小游戏只能试玩3次，如果还想玩，提示：游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn) 分析步骤 写一个游戏类，里面有一个猜数字的小游戏 写一个测试类，测试类中有main()方法，main()方法中写如下代码： ​ 从文件中读取数据到Properties集合，用load()方法实现 文件已经存在：game.txt 里面有一个数据值：count=0 ​ 通过Properties集合获取到玩游戏的次数 ​ 判断次数是否到到3次了 如果到了，给出提示：游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn) 如果不到3次： 次数+1，重新写回文件，用Properties的store()方法实现玩游戏 代码实现 123456789101112131415161718192021222324252627282930public class PropertiesTest &#123; public static void main(String[] args) throws IOException &#123; //从文件中读取数据到Properties集合，用load()方法实现 Properties prop = new Properties(); FileReader fr = new FileReader("myOtherStream\\game.txt"); prop.load(fr); fr.close(); //通过Properties集合获取到玩游戏的次数 String count = prop.getProperty("count"); int number = Integer.parseInt(count); //判断次数是否到到3次了 if(number &gt;= 3) &#123; //如果到了，给出提示：游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn) System.out.println("游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn)"); &#125; else &#123; //玩游戏 GuessNumber.start(); //次数+1，重新写回文件，用Properties的store()方法实现 number++; prop.setProperty("count",String.valueOf(number)); FileWriter fw = new FileWriter("myOtherStream\\game.txt"); prop.store(fw,null); fw.close(); &#125; &#125;&#125; 对象序列化流 对象序列化介绍 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化 对象序列化流： ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 构造方法 | 方法名 | 说明 || ———————————— | ————————————————– || ObjectOutputStream(OutputStream out) | 创建一个写入指定的OutputStream的ObjectOutputStream | 序列化对象的方法 | 方法名 | 说明 || —————————- | ———————————- || void writeObject(Object obj) | 将指定的对象写入ObjectOutputStream | 示例代码 学生类 123456789101112131415161718192021222324252627282930313233343536public class Student implements Serializable &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 测试类 123456789101112131415public class ObjectOutputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\oos.txt")); //创建对象 Student s = new Student("lcw",34); //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream oos.writeObject(s); //释放资源 oos.close(); &#125;&#125; 注意事项 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 Serializable是一个标记接口，实现该接口，不需要重写任何方法 对象反序列化流 对象反序列化流： ObjectInputStream ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象 构造方法 | 方法名 | 说明 || ——————————— | ———————————————- || ObjectInputStream(InputStream in) | 创建从指定的InputStream读取的ObjectInputStream | 反序列化对象的方法 | 方法名 | 说明 || ——————- | ——————————- || Object readObject() | 从ObjectInputStream读取一个对象 | 示例代码 1234567891011121314public class ObjectInputStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\oos.txt")); //Object readObject()：从ObjectInputStream读取一个对象 Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + "," + s.getAge()); ois.close(); &#125;&#125; serialVersionUID&amp;transient serialVersionUID 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ 会出问题，会抛出InvalidClassException异常 如果出问题了，如何解决呢？ 重新序列化 给对象所属的类加一个serialVersionUID private static final long serialVersionUID = 42L; transient 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？ 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程 示例代码 学生类 1234567891011121314151617181920212223242526272829303132333435363738public class Student implements Serializable &#123; private static final long serialVersionUID = 42L; private String name;// private int age; private transient int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;// @Override// public String toString() &#123;// return "Student&#123;" +// "name='" + name + '\'' +// ", age=" + age +// '&#125;';// &#125;&#125; 测试类 1234567891011121314151617181920212223public class ObjectStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123;// write(); read(); &#125; //反序列化 private static void read() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\oos.txt")); Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + "," + s.getAge()); ois.close(); &#125; //序列化 private static void write() throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\oos.txt")); Student s = new Student("lcw", 30); oos.writeObject(s); oos.close(); &#125;&#125; 多线程 概念： 进程：正在运行的应用程序 线程：是进程中的单个顺序控制流，是一条执行路径 实现多线程实现多线程方式一：继承Thread类 方法介绍 | 方法名 | 说明 || ———— | ——————————————- || void run() | 在线程开启后，此方法将被调用执行 || void start() | 使此线程开始执行，Java虚拟机会调用run方法() | 实现步骤 定义一个类MyThread继承Thread类 在MyThread类中重写run()方法 创建MyThread类的对象 启动线程 实现多线程方式二：实现Runnable接口 Thread构造方法 | 方法名 | 说明 || ———————————— | ———————- || Thread(Runnable target) | 分配一个新的Thread对象 || Thread(Runnable target, String name) | 分配一个新的Thread对象 | 实现步骤 定义一个类MyRunnable实现Runnable接口 在MyRunnable类中重写run()方法 创建MyRunnable类的对象 创建Thread类的对象，把MyRunnable对象作为构造方法的参数 启动线程 设置和获取线程名称 方法介绍 | 方法名 | 说明 || ————————– | ———————————- || void setName(String name) | 将此线程的名称更改为等于参数name || String getName() | 返回此线程的名称 || Thread currentThread() | 返回对当前正在执行的线程对象的引用 | 线程优先级 线程调度 两种调度方式 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些 Java使用的是抢占式调度模型 随机性 假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的 优先级相关方法 | 方法名 | 说明 || ————————————— | ———————————————————— || final int getPriority() | 返回此线程的优先级 || final void setPriority(int newPriority) | 更改此线程的优先级。线程默认优先级是5；线程优先级的范围是：1-10 | 线程控制 相关方法 | 方法名 | 说明 || —————————— | ———————————————————— || static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 || void join() | 等待这个线程死亡（如果某个线程调用了此方法，则其他并发的线程必须等待这个线程死亡后才有机会调用） || void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 | 线程的生命周期 线程同步卖票 案例需求 某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票 实现步骤 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100; 在SellTicket类中重写run()方法实现卖票，代码步骤如下 判断票数大于0，就卖票，并告知是哪个窗口卖的 卖了票之后，总票数要减1 票没有了，也可能有人来问，所以这里用死循环让卖票的动作一直执行 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下 创建SellTicket类的对象 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 启动线程 卖票案例的问题 卖票出现了问题 相同的票出现了多次 出现了负数的票 问题产生原因 线程执行的随机性导致的 网络编程入门网络编程概述 计算机网络 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统 网络编程 在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换 网络编程三要素 IP地址 要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识 端口 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识 协议 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议 IP地址IP地址：是网络中设备的唯一标识 IP地址分为两大类 IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题 DOS常用命令： ipconfig：查看本机IP地址 ping IP地址：检查网络是否连通 特殊IP地址： 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用 InetAddressInetAddress：此类表示Internet协议（IP）地址 相关方法 | 方法名 | 说明 || —————————————– | ———————————————————— || static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 || String getHostName() | 获取此IP地址的主机名 || String getHostAddress() | 返回文本显示中的IP地址字符串 | 代码演示 1234567891011121314public class InetAddressDemo &#123; public static void main(String[] args) throws UnknownHostException &#123; //InetAddress address = InetAddress.getByName("skywalker"); InetAddress address = InetAddress.getByName("192.168.1.66"); //public String getHostName()：获取此IP地址的主机名 String name = address.getHostName(); //public String getHostAddress()：返回文本显示中的IP地址字符串 String ip = address.getHostAddress(); System.out.println("主机名：" + name); System.out.println("IP地址：" + ip); &#125;&#125; 端口和协议 端口 设备上应用程序的唯一标识 端口号 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败 协议 计算机网络中，连接和通信的规则被称为网络通信协议 UDP协议 用户数据报协议(User Datagram Protocol) UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议 TCP协议 传输控制协议 (Transmission Control Protocol) TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手” 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 第一次握手，客户端向服务器端发出连接请求，等待服务器确认 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 第三次握手，客户端再次向服务器端发送确认信息，确认连接 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等 UDP通信程序UDP发送数据 Java中的UDP通信 UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念 Java提供了DatagramSocket类作为基于UDP协议的Socket 构造方法 | 方法名 | 说明 || ———————————————————– | —————————————————- || DatagramSocket() | 创建数据报套接字并将其绑定到本机地址上的任何可用端口 || DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 | 相关方法 | 方法名 | 说明 || —————————— | ———————- || void send(DatagramPacket p) | 发送数据报包 || void close() | 关闭数据报套接字 || void receive(DatagramPacket p) | 从此套接字接受数据报包 | 发送数据的步骤 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包 调用DatagramSocket对象的方法发送数据 关闭发送端 代码演示 12345678910111213141516171819202122public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口 DatagramSocket ds = new DatagramSocket(); //创建数据，并把数据打包 //DatagramPacket(byte[] buf, int length, InetAddress address, int port) //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。 byte[] bys = "hello,udp,我来了".getBytes(); DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName("192.168.1.66"),10086); //调用DatagramSocket对象的方法发送数据 //void send(DatagramPacket p) 从此套接字发送数据报包 ds.send(dp); //关闭发送端 //void close() 关闭此数据报套接字 ds.close(); &#125;&#125; UDP接收数据 接收数据的步骤 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 构造方法 | 方法名 | 说明 || ———————————– | ———————————————– || DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 | 相关方法 | 方法名 | 说明 || —————– | —————————————- || byte[] getData() | 返回数据缓冲区 || int getLength() | 返回要发送的数据的长度或接收的数据的长度 | 示例代码 123456789101112131415161718public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength())); &#125; &#125;&#125; UDP通信程序练习 案例需求 UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束 UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* UDP发送数据： 数据来自于键盘录入，直到输入的数据是886，发送数据结束 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); //自己封装键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) &#123; //输入的数据是886，发送数据结束 if ("886".equals(line)) &#123; break; &#125; //创建数据，并把数据打包 byte[] bys = line.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345); //调用DatagramSocket对象的方法发送数据 ds.send(dp); &#125; //关闭发送端 ds.close(); &#125;&#125;/* UDP接收数据： 因为接收端不知道发送端什么时候停止发送，故采用死循环接收 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength())); &#125; //关闭接收端// ds.close(); &#125;&#125; TCP通信程序TCP发送数据 Java中的TCP通信 Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。 Java为客户端提供了Socket类，为服务器端提供了ServerSocket类 构造方法 | 方法名 | 说明 || ———————————— | ———————————————- || Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号 || Socket(String host, int port) | 创建流套接字并将其连接到指定主机上的指定端口号 | 相关方法 | 方法名 | 说明 || —————————— | ——————– || InputStream getInputStream() | 返回此套接字的输入流 || OutputStream getOutputStream() | 返回此套接字的输出流 | 示例代码 123456789101112131415public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; //创建客户端的Socket对象(Socket) //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 Socket s = new Socket("192.168.1.66",10000); //获取输出流，写数据 //OutputStream getOutputStream() 返回此套接字的输出流 OutputStream os = s.getOutputStream(); os.write("hello,tcp,我来了".getBytes()); //释放资源 s.close(); &#125;&#125; TCP接收数据 构造方法 | 方法名 | 说明 || ———————– | ——————————– || ServletSocket(int port) | 创建绑定到指定端口的服务器套接字 | 相关方法 | 方法名 | 说明 || ————— | —————————— || Socket accept() | 监听要连接到此的套接字并接受它 | 示例代码 123456789101112131415161718192021public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //创建服务器端的Socket对象(ServerSocket) //ServerSocket(int port) 创建绑定到指定端口的服务器套接字 ServerSocket ss = new ServerSocket(10000); //Socket accept() 侦听要连接到此套接字并接受它 Socket s = ss.accept(); //获取输入流，读数据，并把数据显示在控制台 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); String data = new String(bys,0,len); System.out.println("数据是：" + data); //释放资源 s.close(); ss.close(); &#125;&#125; TCP通信程序练习 案例需求 客户端：数据来自于文本文件，接收服务器反馈 服务器：接收到的数据写入文本文件，给出反馈，代码用线程进行封装，为每一个客户端开启一个线程 案例分析 创建客户端对象，创建输入流对象指向文件，每读入一行数据就给服务器输出一行数据，输出结束后使用shutdownOutput()方法告知服务端传输结束 创建多线程类，在run()方法中读取客户端发送的数据，为了防止文件重名，使用计数器给文件名编号，接受结束后使用输出流给客户端发送反馈信息。 创建服务端对象，每监听到一个客户端则开启一个新的线程接受数据。 客户端接受服务端的回馈信息 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; //创建客户端Socket对象 Socket s = new Socket("192.168.1.66",10000); //封装文本文件的数据 BufferedReader br = new BufferedReader(new FileReader("myNet\\InetAddressDemo.java")); //封装输出流写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); String line; while ((line=br.readLine())!=null) &#123; bw.write(line); bw.newLine(); bw.flush(); &#125; s.shutdownOutput(); //接收反馈 BufferedReader brClient = new BufferedReader(new InputStreamReader(s.getInputStream())); String data = brClient.readLine(); //等待读取数据 System.out.println("服务器的反馈：" + data); //释放资源 br.close(); s.close(); &#125;&#125;public class ServerThread implements Runnable &#123; private Socket s; public ServerThread(Socket s) &#123; this.s = s; &#125; @Override public void run() &#123; try &#123; //接收数据写到文本文件 BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream())); //解决名称冲突问题 int count = 0; File file = new File("myNet\\Copy["+count+"].java"); while (file.exists()) &#123; count++; file = new File("myNet\\Copy["+count+"].java"); &#125; BufferedWriter bw = new BufferedWriter(new FileWriter(file)); String line; while ((line=br.readLine())!=null) &#123; bw.write(line); bw.newLine(); bw.flush(); &#125; //给出反馈 BufferedWriter bwServer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); bwServer.write("文件上传成功"); bwServer.newLine(); bwServer.flush(); //释放资源 s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //创建服务器Socket对象 ServerSocket ss = new ServerSocket(10000); while (true) &#123; //监听客户端连接，返回一个对应的Socket对象 Socket s = ss.accept(); //为每一个客户端开启一个线程 new Thread(new ServerThread(s)).start(); &#125; &#125;&#125; Lambda&amp;方法引用 Lambda表达式为JDK1.8的新特性。 Lambda表达式：简化匿名内部类的一种方式，只能用于有且只有一个抽象方法的接口。 由这三部分组成：(形式参数) -&gt; {代码块} (形式参数): 括号中是参数列表，如果是空参方法，不需要传参。比如Runnable接口中的run()方法。 参数类型可以省略，但是有多个参数的情况下，不能只省略一个。 而且，如果参数有且只有一个那么小括号可以省略。 -&gt;: 固定用法，表示传递 {代码块}: 重写的方法的方法体 如果代码块的语句只有一条，可以省略大括号和分号（如果有return，return也得省略掉） 接口新特性 静态方法（JDK1.8） 格式 public static 返回值类型 方法名(参数列表) { } 范例 12public static void show() &#123;&#125; 注意事项 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 默认方法（JDK1.8） 格式 public default 返回值类型 方法名(参数列表) { } 范例 12public default void show3() &#123; &#125; 注意事项 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字 public可以省略，default不能省略 私有方法（JDK1.9） 主要作用：抽取接口中共性的代码 私有方法产生原因 Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java 9增加私有方法的必然性 定义格式 格式1 private 返回值类型 方法名(参数列表) { } 范例1 12private void show() &#123; &#125; 格式2 private static 返回值类型 方法名(参数列表) { } 范例2 12private static void method() &#123; &#125; 注意事项 默认方法可以调用私有的静态方法和非静态方法 静态方法只能调用私有的静态方法 函数式接口@FunctionalInterface注解：用于检测一个接口是否是函数式接口。 常用的函数式接口： Supplier 属于生产型接口。 接口中只有一个方法 T get(); 获得结果。 Consumer 属于消费型接口 接口中有两个方法： void accept(T t); 对给定的参数执行此操作。 default Consumer andThen(Consumer &lt;? super T&gt; after); 返回一个组合的 Consumer ，按顺序执行该操作，然后执行 after操作。 Predicate 表示一个参数的谓词（布尔值函数）。 五个常用方法，其中boolean test( T t )是该FunctionalInterface的功能方法 Modifier and Type Method and Description default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) 返回一个组合的谓词，表示该谓词与另一个谓词的短路逻辑AND。 static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) 返回根据 Objects.equals(Object, Object)测试两个参数是否相等的 谓词 。 default Predicate&lt;T&gt; negate() 返回表示此谓词的逻辑否定的谓词。 default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) 返回一个组合的谓词，表示该谓词与另一个谓词的短路逻辑或。 boolean test(T t) 在给定的参数上评估这个谓词。 Function 表示接受一个参数并产生结果的函数。 Modifier and Type Method and Description default &lt;V&gt; Function&lt;T,V&gt; andThen(Function&lt;? super R,? extends V&gt; after) 返回一个组合函数，首先将该函数应用于其输入，然后将 after函数应用于结果。 R apply(T t) 将此函数应用于给定的参数。 default &lt;V&gt; Function&lt;V,R&gt; compose(Function&lt;? super V,? extends T&gt; before) 返回一个组合函数，首先将 before函数应用于其输入，然后将此函数应用于结果。 static &lt;T&gt; Function&lt;T,T&gt; identity() 返回一个总是返回其输入参数的函数。 Stream流 类似于车间的生产线，可以更加方便的对集合或者数组中的元素进行操作 操作步骤 1、根据数据源（集合或者数组）生成Stream流对象 2、流操作（使用Stream接口中的方法） 如何将集合或者数组转为Stream流对象（集合/数组-&gt;Stream流） 单列集合通过Collection接口的默认方法stream()，比如： 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Stream&lt;String&gt; listStream = list.stream(); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); Stream&lt;String&gt; setStream = set.stream(); 双列集合不能直接转为Stream流对象，需要先转为单列集合，然后再调用stream()方法转为流对象，比如： 1234567Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;Integer&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream(); 数组通过Stream接口的静态方法of(T… values)，比如： 1234 String[] strArray = &#123;"hello","world","java"&#125;; Stream&lt;String&gt; strArrayStream = Stream.of(strArray); 或者Stream&lt;String&gt; strArrayStream2 = Stream.of("hello", "world", "java"); Stream接口中的方法 12345678910111213141516延迟方法（中间操作）：如果一个方法的返回还是Stream流对象，则称之为延迟方法Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)：用于过滤流中不满足条件的数据Stream&lt;T&gt; limit(long n) :截取流中的前n个数据Stream&lt;T&gt; skip(long n)：跳过流中的前n个数据，截取剩余的数据public static &lt;T&gt; Stream&lt;T&gt; concat(Stream a, Stream b)：用于合并两个流Stream&lt;T&gt; distinct() ：将流中重复的元素去除Stream&lt;T&gt; sorted()：按照自然顺序对流中的数据进行排序Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator):按照指定的比较器规则对流中的数据进行排序&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) ：将流中的元素从一种类型转换为另一种类型的数据IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper) :将流中的数据转为int类型返回一个新的流（IntStream）&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector) ：将流中的数据收集到集合中终结方法（终结操作）：如果一个方法的返回不是Stream流对象，则称之为终结方法void forEach(Consumer&lt;? super T&gt; action) ：用于遍历流中的数据long count()：用于统计流中数据的个数 Stream流的收集（Stream流-&gt;集合/数组）收集到集合收集到List集合 stream.collect(Collectors.toList()); 比如： List&lt;String&gt; names = listStream.collect(Collectors.toList()); 收集到Set集合 stream.collect(Collectors.toSet()); 比如： Set&lt;Integer&gt; ages = setStream.collect(Collectors.toSet()); 收集到Map集合 stream.collect(Collectors.toMap(Function fun1,Function fun2)); 比如： Map&lt;String, Integer&gt; map = arrayStream.collect(Collectors.toMap( s -&gt; s.split(&quot;,&quot;)[0], s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1]) ) ); 收集到数组 123456789Stream&lt;String&gt; stream = Stream.of("hello", "world", "java", "php", "mysql");// 只要后三个元素Stream&lt;String&gt; skipStream = stream.skip(2);//String[] strings = skipStream.toArray(length-&gt;new String[length]);String[] strings = skipStream.toArray(String[]::new);for (String s : strings) &#123; System.out.println(s);&#125; 类加载器类加载 类加载的描述 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化 类的加载 就是指将class文件读入内存，并为之创建一个 java.lang.Class 对象 任何类被使用时，系统都会为之建立一个 java.lang.Class 对象 类的连接 验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致 准备阶段：负责为类的类变量分配内存，并设置默认初始化值 解析阶段：将类的二进制数据中的符号引用替换为直接引用 类的初始化 在该阶段，主要就是对类变量进行初始化 类的初始化步骤 假如类还未被加载和连接，则程序先加载并连接该类 假如该类的直接父类还未被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 注意：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3 类的初始化时机 创建类的实例 调用类的类方法 访问类或者接口的类变量，或者为该类变量赋值 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 类加载器类加载器的作用 负责将.class文件加载到内存中，并为之生成对应的 java.lang.Class 对象。虽然我们不用过分关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行！ JVM的类加载机制 全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区 Java中的内置类加载器 Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为null ，并且没有父null Platform class loader：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类 System class loader：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap ClassLoader 中的两个方法 方法分类 | 方法名 | 说明 || —————————————– | ————————– || static ClassLoader getSystemClassLoader() | 返回用于委派的系统类加载器 || ClassLoader getParent() | 返回父类加载器进行委派 | 示例代码 1234567891011121314public class ClassLoaderDemo &#123; public static void main(String[] args) &#123; //static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器 ClassLoader c = ClassLoader.getSystemClassLoader(); System.out.println(c); //AppClassLoader //ClassLoader getParent()：返回父类加载器进行委派 ClassLoader c2 = c.getParent(); System.out.println(c2); //PlatformClassLoader ClassLoader c3 = c2.getParent(); System.out.println(c3); //null &#125;&#125; 反射 概念 将类封装成一个Class对象，然后将类的各个组成部分也封装成对象，然后在运行阶段可以获取各个组成部分并且操作它们。 成员变量 -&gt; Filed类 构造方法 -&gt; Constructor类 成员方法 -&gt; Method类 反射称之为Java中的解剖学，反射相当于是对Java中的类进行解剖 获取Class对象 类名.class 比如：Class clazz = Student.class; 对象名.getClass() 比如：Class clazz = stu.getClass(); Class.forName(“全类名”) 比如：Class.forName(&quot;cn.skywalker.Student&quot;); 以上三种方式获取的字节码对象是同一个。 Class类 123456789101112131415 Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：获取指定参数的public修饰的构造方法 Constructor&lt;?&gt;[] getConstructors()：获取所有public修饰的构造方法 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) ：获取指定参数的构造方法，权限修饰符不限 Constructor&lt;?&gt;[] getDeclaredConstructors() ：获取所有的构造方法，权限修饰符不限T newInstance() ：使用空参构造创建对象 Field getField(String name) Field[] getFields() Field getDeclaredField(String name) Field[] getDeclaredFields() Method getMethod(String name, Class&lt;?&gt;... parameterTypes) Method[] getMethods() Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) Method[] getDeclaredMethods() Constructor类 如何获取 如何操作 public修饰的构造方法使用空参构造创建对象方式一：（1）获取字节码对象（Class对象）（2）调用Class类中的getConstructor()方法获取Constructor对象（3）调用Constructor类中的newInstance()方法创建对象 Class&lt;?&gt; c = Class.forName(“com.itheima_02.Student”);Constructor&lt;?&gt; con = c.getConstructor();Object obj = con.newInstance(); 方式二：（1）获取字节码对象（Class对象）（2）调用Class类中的newInstance()方法创建对象 Class&lt;?&gt; clazz = Class.forName(“com.myReflect.itheima_02.Student”); Object obj = clazz.newInstance(); 使用有参构造创建对象 （1）获取字节码对象（Class对象） （2）调用Class类中的getConstructor(参数类型)方法获取Constructor对象 （3）调用Constructor类中的newInstance(实参)方法创建对象 Class&lt;?&gt; c = Class.forName(“com.itheima_02.Student”);Constructor&lt;?&gt; con = c.getConstructor(String.class, int.class, String.class);Object obj = con.newInstance(“林青霞”, 30, “西安”); 非public修饰的构造方法（1）获取字节码对象（Class对象）（2）调用Class类中的getDeclaredConstructor(参数类型)方法获取Constructor对象（3）调用Constructor类中的setAccessible(true)方法（4）调用Constructor类中的newInstance(实参)方法创建对象 ​ Filed类 如何获取 如何操作 1、获取Class对象 2、使用Class类中的getField(String name)获取指定的成员变量的Field对象 3、反射创建对象 4、调用Field类中的set给指定对象的该成员变量赋指定的值 模块化 在不同模块之间建立模块依赖关系，可以使用不同模块的资源。 使用不同模块的类： exports 包名; requires 模块名; 使用不同模块提供的接口（包含实现类，主要思想是面向接口编程）服务： 提供服务端： exports 接口所在的包; provides 接口名 with 实现类名; 使用服务端： uses 接口名;（使用编译器会自动帮你导包）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2Fmarkdown%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 再一次感谢您花费时间阅读，祝您在这里记录、阅读、分享愉快！]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>-markdown -笔记 -工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML/CSS]]></title>
    <url>%2FHTML-CSS%2FHTML-CSS%2F</url>
    <content type="text"><![CDATA[软件架构 C/S（Client/Server）：客户端/服务器端 在用户本地有一个客户端程序，在远程有一个服务器端程序 如：QQ，迅雷… 优点 用户体验好 缺点 开发、安装、部署、维护麻烦 B/S（Browser/Server）：浏览器/服务器端 只需要一个浏览器，用户通过不同的网址（URL），客户访问不同的服务器端程序 优点 开发、安装、部署、维护简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高 B/S架构详解 资源分类： 静态资源 使用静态网页开发技术发布的资源。 特点： 所有用户访问，得到的结果是一样的。 如：文本，图片，音频，视频，HTML，CSS，JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源 动态资源 使用动态网页及时发布的资源。 特点： 所有用户访问，得到的结果可能不一样 如：jsp/servlet，php，asp… 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 我们要学习动态资源，必须先学习静态资源！ 静态资源： HTML：用于搭建基础网页，展示页面的内容 CSS：用于美化页面，布局页面 JavaScript：控制页面的元素，让页面有一些动态的效果 HTML 概念：是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本：超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. 标记语言： 由标签构成的语言。&lt;标签名称&gt; 如 html，xml 标记语言不是编程语言 快速入门： 语法： html文档后缀名 .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写。 代码： 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 文本标签1234567891011121314&lt;em&gt;&lt;/em&gt;表示语义上的强调（自动斜体）&lt;strong&gt;&lt;/strong&gt;表示内容上的强调（自动加粗）&lt;i&gt;&lt;/i&gt;i标签的内容会以斜体显示&lt;b&gt;&lt;/b&gt;b标签的内容会以加粗显示&lt;small&gt;&lt;/small&gt;内容以细小的字体显示&lt;cite&gt;&lt;/cite&gt;引用（加书名号的）&lt;q&gt;&lt;/q&gt;行引用&lt;blockquote&gt;&lt;/blockquote&gt;块儿引用&lt;sup&gt;&lt;/sup&gt;上标&lt;sub&gt;&lt;/sub&gt;下标&lt;del&gt;&lt;/del&gt;删除线&lt;ins&gt;&lt;/ins&gt;插入内容&lt;pre&gt;&lt;/pre&gt;预格式&lt;code&gt;&lt;/code&gt;代码块（一般和pre标签一起使用） 图片标签 img标签：展示图片 属性： src：指定图片的位置 代码： 1234567891011121314&lt;!--展示一张图片 img--&gt;&lt;img src="image/pic1.jpg" align="right" alt="图片1" width="500" height="500"/&gt;&lt;!-- 相对路径 * 以.开头的路径 * ./：代表当前目录 ./image/1.jpg * ../:代表上一级目录--&gt;&lt;img src="./image/pic1.jpg"&gt;&lt;img src="../image/pic2.jpg"&gt; 列表标签 有序列表： ol li 无序列表： ul li 代码： 1234567891011121314151617&lt;!--有序列表 ol--&gt;早上起床干的事情&lt;ol type="A" start="5"&gt; &lt;li&gt;睁眼&lt;/li&gt; &lt;li&gt;看手机&lt;/li&gt; &lt;li&gt;穿衣服&lt;/li&gt; &lt;li&gt;洗漱&lt;/li&gt;&lt;/ol&gt;&lt;!-- 无序列表 ul--&gt;早上起床干的事情&lt;ul type="disc"&gt; &lt;li&gt;睁眼&lt;/li&gt; &lt;li&gt;看手机&lt;/li&gt; &lt;li&gt;穿衣服&lt;/li&gt; &lt;li&gt;洗漱&lt;/li&gt;&lt;/ul&gt; 链接标签 a标签：定义一个超链接 属性： href：指定访问资源的URL(统一资源定位符) href是Hypertext Reference的缩写。意思是指定超链接目标的URL。是css代码的一种。href 属性的值可以是任何有效文档的相对或绝对URL，包括片段标识符和JavaScript代码段。 target：指定打开资源的方式 _self:默认值，在当前页面打开 _blank：在空白页面打开 代码： 1234567891011121314151617&lt;!--超链接 a--&gt;&lt;a href="http://www.skywalkerkkkk.cn"&gt;点我&lt;/a&gt;&lt;br&gt;&lt;a href="http://www.skywalkerkkkk.cn" target="_self"&gt;点我&lt;/a&gt;&lt;br&gt;&lt;a href="http://www.skywalkerkkkk.cn" target="_blank"&gt;点我&lt;/a&gt;&lt;br&gt;&lt;!-- 也可以跳转至项目内的页面 --&gt;&lt;a href="./anotherPage.html"&gt;点我跳转&lt;/a&gt;&lt;br&gt;&lt;a href="mailto:skywalkerkkkk@skywalkerkkkk.cn"&gt;联系我们&lt;/a&gt;&lt;br&gt;&lt;a href="http://www.skywalkerkkkk.cn"&gt;&lt;img src="image/pic1.jpg"&gt;&lt;/a&gt; 语义化标签 html5中为了提高程序的可读性，提供了一些标签。 &lt;header&gt;：页眉 &lt;footer&gt;：页脚 表格标签 table：定义表格 width：宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条 bgcolor：背景色 align：对齐方式 tr：定义行 bgcolor：背景色 align：对齐方式 td：定义单元格 colspan：合并列 rowspan：合并行 th：定义表头单元格 &lt;caption&gt;：表格标题 &lt;thead&gt;：表示表格的头部分 &lt;tbody&gt;：表示表格的体部分 &lt;tfoot&gt;：表示表格的脚部分 表单标签 概念：用于采集用户输入的数据的。用于和服务器进行交互。 form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 属性： action：指定提交数据的URL method:指定提交方式 分类：一共7种，2种比较常用 get： 请求参数会在地址栏中显示。会封装到请求行中。 请求参数大小是有限制的。 不太安全。 post： 请求参数不会再地址栏中显示。会封装在请求体中。 请求参数的大小没有限制。 较为安全。 表单项中的数据要想被提交：必须指定其name属性 表单项标签 input：可以通过type属性值，改变元素展示的样式 type属性： text：文本输入框，默认值 placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 password：密码输入框 radio:单选框 注意： 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 checkbox：复选框 注意： 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息。 按钮： submit：提交按钮。可以提交表单 button：普通按钮 image：图片提交按钮 src属性指定图片的路径 label：指定输入项的文字描述信息 注意： label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 select: 下拉列表 子元素：option，指定列表项 textarea：文本域 cols：指定列数，每一行有多少个字符 rows：默认多少行。 外部样式表格式1&lt;link rel = "stylesheet" type = "text/css" href = "css文件路径" /&gt; CSS 概念：CSS（Cascading Style Sheet，层叠样式表）。将多个样式叠加作用在HTML元素上面，可以同时起效果，让页面更加好看。 好处： 降低CSS样式和HTML元素的耦合度，将这两部分进行了分离 功能更加强大 CSS和HTML的3种结合方式： 内联样式 内部样式 外部样式 内联样式 在HTML标签内使用style属性，在属性值内编写CSS代码。 缺点： CSS代码和HTML代码耦合在一起，并没有做到分离 作用范围太小，只能作用在该标签上 内部样式 在HTML页面的head标签内定义一个style标签在style标签体中定义CSS代码。 代码： 1234567&lt;style&gt; 选择器｛ 属性名1:属性值1; 属性名2:属性值2; 属性名3:属性值3; ｝&lt;/style&gt; 缺点： 只能在本HTML页面内起效果，出了该页面无法起效果 外部样式 在外部定义一个CSS文件，在文件中编写CSS代码 在HTML页面中如何使用外部样式： 使用link标签 1&lt;link rel = "stylesheet" type = "text/css" href = "css文件路径" /&gt; 在style标签中引入 123&lt;style&gt; @import 关联css文件的路径;&lt;/style&gt; CSS语法 格式： 12345选择器 &#123; 属性名1:属性值1; 属性名2:属性值2; ...&#125; 选择器:筛选具有相似特征的元素 注意：每一对属性需要使用；隔开，最后一对属性可以不加分号 选择器 概念：筛选具有相似特征的元素 分类： 基础选择器 id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 语法：#id属性值{} 元素选择器：选择具有相同标签名称的元素 语法： 标签名称{} 类选择器：选择具有相同的class属性值的元素。 语法：.class属性值{} 优先级关系：id选择器 &gt; 类选择器 &gt; 元素选择器 扩展选择器 选择所有元素 语法： *{} 并集选择器 选择器1,选择器2{} 后代选择器：筛选选择器1元素下的选择器2元素 语法： 选择器1 选择器2{} 子选择器：筛选选择器2的父元素选择器1 语法： 选择器1 &gt; 选择器2{} 属性选择器：选择元素名称，属性名=属性值的元素 语法： 元素名称[属性名=”属性值”]{} 元素状态选择器（伪类选择器） 语法： 元素:状态{} 如：&lt;a&gt; 状态： link：初始化的状态 visited：被访问过的状态 active：正在访问状态 hover：鼠标悬浮状态 属性 字体、文本 font-size：字体大小 color：文本颜色 text-align：对齐方式 line-height：行高 背景 background 边框 border：设置边框，符合属性 尺寸 width：宽度 height：高度 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况下内边距会影响整个盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 float：浮动 left right 案例：注册页面 html页面代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;link rel="stylesheet" href="../../css/register.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="rg_layout"&gt; &lt;div class="rg_left"&gt; &lt;p&gt;新用户注册&lt;/p&gt; &lt;p&gt;USER REGISTER&lt;/p&gt; &lt;/div&gt; &lt;div class="rg_middle"&gt; &lt;form action="#" method="post"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="username"&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="text" id="username" name="username" placeholder="请输入用户名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="password"&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="password" id="password" name="password" placeholder="请输入密码"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="email"&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="email" id="email" name="email" placeholder="请输入邮箱"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="name"&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="text" id="name" name="name" placeholder="请输入真实姓名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="tel"&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="tel" id="tel" name="tel" placeholder="请输入您的手机号"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt; &lt;input type="radio" name="gender" value="male" checked&gt;男 &lt;input type="radio" name="gender" value="female"&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="birthday"&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="date" id="birthday" name="birthday"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="verify_code"&gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt; &lt;input type="img" id="verify_code" name="verify_code"&gt; &lt;img src="../../img/verify_code.jpg" id="img_check"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" align="center"&gt;&lt;input type="submit" id="sub" name="sub" value="注册"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class="rg_right"&gt; &lt;p&gt;已有账号？&lt;a href="#"&gt;立即登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css样式表代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697* &#123; padding: 0px; margin: 0px; box-sizing: content-box;&#125;body &#123; background: url("../img/register_bg.png") no-repeat; background-size: cover; padding-top: 5%;&#125;.rg_layout &#123; /*让div水平居中*/ margin: auto; width: 1000px; height: 650px; border: 8px solid rgb(238, 238, 238); background-color: white;&#125;.rg_left p:first-child &#123; color: rgb(255, 225, 128); font-size: 25px;&#125;.rg_left p:last-child &#123; color: rgb(168, 172, 191); font-size: 25px;&#125;.rg_left &#123; float: left; margin: 30px;&#125;.left_side &#123; text-align: right; width: 100px; height: 60px; color: rgb(185, 185, 185); font-size: 20px;&#125;.right_side &#123; padding-left: 50px;&#125;#username, #password, #email, #name, #tel, #birthday, #verify_code &#123; border-radius: 5px; border: 1px rgb(221, 221, 221) solid; height: 5px; width: 270px; font-size: 17px; padding: 15px;&#125;#verify_code &#123; width: 130px;&#125;#img_check &#123; vertical-align: middle; height: 30px; padding-left: 20px;&#125;#sub&#123; background-color: rgb(255, 222, 101); width: 150px; height: 40px; border: 0px; font-size: 15px;&#125;.rg_middle &#123; /*border: 1px solid red;*/ float: left; margin: 30px; width: 48%;&#125;.rg_right p a &#123; color: rgb(253, 185, 178);&#125;.rg_right &#123; float: right; margin: 30px;&#125; 效果图：]]></content>
      <categories>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>-HTML -CSS -H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb]]></title>
    <url>%2FJava%2FJavaWeb%2F</url>
    <content type="text"><![CDATA[ServletServletResoponse 设置响应格式123ServletResponse response = new ServletResponse();response.setContentType("application/msword");//设置响应类型为word文档。//具体可以在tomcat/config/web.xml中查找需要格式对应的值 JSPJSP运行原理 JSP是简Servlet编写的一种技术，他将Java代码和HTML语句混合在同一个文件中编写。只对网页中的要动态产生的内容才用Java代码来编写，而对固定不变的静态内容才用普通静态HTML页面的方式编写。 JSP继承了HttpJspBase类，而HttpJspBase又继承了HttpServlet，即jsp间接继承了HttpServlet，即JSP本质上就是一个Servlet。 JSP八大内置对象（实际上9个） 类名 对象实例名（可直接调用） HttpServletRequest request HttpServletResoponse response PageContext pageContext HttpSession session ServletContext application ServletConfig config JspWriter out Object page Exception exception ① request：HttpServletRequest的一个对象。 ② response：HttpServletResponse的一个对象（在JSP页面中几乎不会调用response的任何方法）。 ③ pageContext：页面的上下文，是PageContext的一个对象。可以从该对象中获取到其他8个隐含对象。亦可以从中获取到当前页面的其他信息。（学习自定义标签时使用他。在JSP页面上很少直接使用他。） ④ session：代表浏览器和服务器的一次会话，是HttpSession的一个对象。 ⑤ application：代表当前Web应用。是ServletContext的一个对象。（可以获取初始化参数等。） ⑥ config：当前JSP对应的Servlet的ServletConfig对象。（开发时几乎不使用。若需要访问当前JSP配置的初始化参数，需要通过映射的地址才可以。） ⑦ out：JspWriter对象。调用out.println()可以直接把字符串打印到浏览器上。（在两次out.println()时，中间不会换行，需要添加HTML的换行标签&lt;br>。） ⑧ page：指向当前JSP对应的Servlet对象的引用，但为Object类型，只能调用Object类的方法（几乎不使用。） ⑨ exception：一定的条件下才可以用。（只有主动声明了isErrorPage=”true”的时候，才可以使用。） 标红均为开发时常用对象。 pageContext，request，session，application对属性的作用域范围从小到大。 JSP表达式​ JSP表达式（expression）提供了将一个java变量或表达式的计算结果输出到客户端的简化方式，他将要输出的变量或表达式直接封装在&lt;%= 和 %&gt;中。 JSP注释的格式：&lt;%– JSP注释 –%&gt; HTML注释的格式：&lt;!– HTML注释 –> 区别 : ​ JSP注释可以阻止Java代码的执行，而HTML注释surround with &lt;% Java代码 %&gt;时，不能阻止Java代码的执行。 域对象的属性操作 ① 和属性相关的方法： Object getAttribute(String name)：获取指定的属性 Enumeration getAttributeNames()：获取所有的属性的名字组成的Enumeration对象 void removeAttribute(String name)：移除指定的属性 void setAttribute(String name, Object obj)：设置属性 ② pageContext，request，session，application对象都有这些方法。这四个对象也成为域对象。 ③ 作用范围 pageContext：属性的作用范围仅限于当前JSP页面。（在Servlet中无法得到pageContext对象。） request：属性的作用范围仅限于同一个请求。 session：属性的作用范围限于一次会话。（会话：浏览器打开直到关闭称之为一次会话。（会话在此期间不失效。）） application：属性的作用范围限于当前Web应用。是范围最大的属性作用范围，只要在一处设置属性，在其他各处的JSP或Servlet中都可以获取到。 请求的转发和重定向 ① 调用HttpServletRequest的getRequestDispatcher(String path)方法获取RequestDispatcher对象。调用方法时，需要传入要转发的地址。 ② 调用 HttpServletRequest的 forward（request，response）进行请求的转发。 ③ 调用sendRedirect(String path) 进行请求的重定向。 ④ 转发与重定向的区别： 本质区别：请求的转发只发出了 一次 请求，而重定向则发出了 两次 请求。 具体： 请求的转发：地址栏是初次发出请求的地址。 请求的重定向：地址栏不再是初次发出的请求地址，地址栏为最后响应的那个地址。 请求的转发：在最终的Servlet中，request对象和中转的那个request是同一个对象。 请求的重定向：在最终的Servlet中，request对象和中转的那个request不是同一个对象。 请求的转发：只能转发到当前Web应用的资源（内部资源）。 请求的重定向：可以重定向到任何资源。 请求的转发：“ / ” 代表的是当前Web应用（localhost:port/WebApps）的根目录。 请求的重定向：“ / ” 代表的是当前Web站点（localhost:port）的根目录。 JSP指令 ①include 用于通知JSP引擎在翻译当前JSP页面时将其他文件中的内容合并进当前JSP页面转换成的Servlet源文件中，这种在源文件级别进行引入的方式称之为静态引入，当前JSP页面与静态引入的页面紧密结合为一个Servlet。 file属性的设置值必须使用相对路径。 如果以“ / ”开头，表示相对于当前Web应用程序的根目录（注意不是站点根目录），否则，表示相对于当前文件。 ②page page指令用于定义JSP页面的各种属性，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面，为了保持程序的可读性和遵循良好的变成习惯，page指令最好是放在整个JSP页面的起始位置。 page指令常用的属性： import属性：指定当前JSP页面对应的Servlet需要导入的类。&lt;%@page import=”全类名”%&gt; session属性：取值为true或false，指定当前页面的session隐藏变量是否可用，也可以说访问当前页面时，是否一定要生成HttpSession对象。 errorPage和isErrorPage：前者表示指定若当前页面出现错误的实际响应页面是什么，其中“ / ” 表示的是当前Web应用的根目录。后者表示指定当前页面是否为错误处理页面，可以说明当前页面是否可以使用exception隐藏内置对象。 需要注意的是：若指定isErrorPage=”true”，并使用exception的方法了，一般不建议能够直接访问该页面。 contentType：指定当前JSP页面的响应类型。实际调用的是response.setContentType(“text/html;charset=UTF-8”);通常情况下，对于JSP页面而言其取值均为 text/html; charset=UTF-8 pageEncoding：指定当前JSP页面的字符编码。通常情况下该值和contentType中的charset一致。 isELIgnored：指定当前JSP页面是否可以使用EL表达式。通常取值为true。 如何使客户不能直接访问一个页面呢？ 1) 对于Tomcat服务器而言，WEB-INF下的文件是不能通过在浏览器中直接输入来访问的。但通过请求的转发是可以访问的！2) 还可以在web.xml文件中配置错误页面。 1234567891011 &lt;!-- 方式1.指定出错的代码，404没有指定资源，500内部错误。 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;!-- 指定响应页面的位置 --&gt;&lt;/error-page&gt; &lt;!-- 方式2.指定异常的类型 --&gt; &lt;error-page&gt;&lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;!-- 指定响应页面的位置 --&gt;&lt;/error-page&gt; ③taglib JSP标签 jsp:include标签： &lt;jsp:include page = &quot;path&quot;&gt; &lt;/jsp:include&gt; 动态引入：并不是像include指令生成一个Servlet源文件，而是生成两个Servlet源文件，然后通过一个方法的方式把目标页面包含进来。 org.apache.jasper.runtime.JspRuntimeLibrary.include(request,response,&quot;path&quot;,out,false); include指令和jsp:include标签： 是在当前JSP页面的执行期间插入被引入资源的输出内容。 被动态引入的资源必须是一个能独立被Web容器调用和执行的资源。 include指令只能引入遵循JSP格式的文件，被引入文件与当前JSP文件共同合被翻译成一个Servlet源文件。 jsp:foward标签： &lt;jsp:forward page = &quot;path&quot;&gt;&lt;/jsp:forward&gt; 相当于request.getRequestDispatcher(&quot;path&quot;).forward(request,response); 但使用jsp:forward可以使用jsp:param子标签向path传入一些参数，同样jsp:include也可以使用jsp:param子标签。 中文乱码编码格式 = 解码格式即可解决乱码问题。 MVC设计模式MVC即Model-View-Controller。模型-视图-控制器。 模型（Model） 模型是应用程序的主体部分。模型表示业务数据和业务逻辑。 一个模型能为多个视图提供数据。 由于应用于模型的代码只需要写一次就可以被多个视图重用，所以提高了代码的可重用性。 视图（View） 视图是用户看到并与之交互的界面，作用如下： 视图向用户显示相关的数据。 接受用户的输入。 不进行任何实际的业务处理。 控制器（Controller） 控制器接受用户的输入并调用模型和视图去完成用户的需求。 控制器接受请求并决定调用哪个模型组建去处理请求，然后决定调用哪个视图来显示模型处理返回的数据。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-JavaWeb -JSP -Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hello Everyone！这是我的第一篇文章。 在老铁的帮助下，我慢慢开始摸索代码世界…… 自己加油吧。 Keep Going！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
