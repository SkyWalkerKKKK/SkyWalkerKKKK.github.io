<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSM框架]]></title>
    <url>%2FFramework%2F16_SSM%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[概述 SSM（Spring+SpringMVC+MyBatis）框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。 什么是框架框架( Framework )是构成一类特定软件可复用设计的一组相互协作的类。框架规定了你的应用的体系结构。它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节 为什么要用框架有些框架初学者会感叹，框架好难！而且在学习过程中，涉及到的代码量可能会很少，使用了框架后，本来可能几行就完成的代码，变得需要多写很多行来完成。就会产生一个疑问：为什么要用框架？这不是多此一举吗？ 我们在学习框架之前，做项目的时候，有很多工具类或者基础类都是我们自己写的，比如BaseServlet，JDBCUtils等等，学习过框架之后，我们就会有两个选择： A、复制别人的代码直接使用，早点下班享受 欢乐人生 B、埋头苦干，自立更生，放弃6点下班的权力 很显然，一个不是太固执的人都会选择 A ，因为简单方便,我们应该考虑的问题别人已经考虑好了 同样，框架也是将项目中共有的问题抽取出来，封装成工具类供大家使用,我们遇到的问题，前辈们已经帮助我们封装好了工具类,使用就好了。 其实不然，“杀鸡焉用青龙偃月刀”？在做项目时功能越来越多，项目越来越大的情况下，就会发现，使用框架可以大大的减少代码的编写量，而框架最大的好处就是重用性强，方便维护。这意味着框架可以帮助我们在某些代码上的一劳永逸。 因为软件系统发展到今天已经很复杂了，特别是服务器端软件，涉及到的知识，内容，问题太多。在某些方面使用别人成熟的框架，就相当于让别人帮你完成一些基础工作，你只需要集中精力完成系统的业务逻辑设计。而且框架一般是成熟，稳健的，他可以处理系统很多细节问题，比如，事务处理，安全性，数据流控制等问题。还有框架一般都经过很多人使用，所以结构很好，所以扩展性也很好，而且它是不断升级的，你可以直接享受别人升级代码带来的好处。 框架一般处在低层应用平台（如J2EE）和高层业务逻辑之间的中间层。 软件为什么要分层？ 为了实现“高内聚、低耦合”。把问题划分开来各个解决，易于控制，易于延展，易于分配资源…总之好处很多啦。 框架和设计模式框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。构件通常是代码重用，而设计模式是设计重用，框架则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。在软件生产中有三种级别的重用：内部重用，即在同一应用中能公共使用的抽象块;代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。 框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。 SSM是哪三大框架SSM = Spring + SpringMVC + MyBatis 为什么是三大框架为了便于管理代码，现在流行的是分层开发，分为三层： 表现层（controller层）：负责接收参数，响应数据 业务逻辑层（service层）：负责处理业务逻辑 持久层（dao层）：负责数据库交互 但是分层完毕后,全世界所有的Java项目开发人员发现 controller层所有的逻辑都使用servlet太麻烦，需要封装工具类，而互联网有很多封装好的工具类可以使用，开发人员就会选择比较适用的下载使用。 但世间本没有路，走的人多了就成了路。 三大框架就是因为使用的人多我们称为“三大框架”，但是市面上依旧有很多框架，只不过用人相对较少。 三大框架的作用 SpringMVC框架解决了表现层（web层，也叫controller层）获取参数、写回数据的问题。 MyBatis框架解决了持久层（dao层）从数据库中获取数据代码量大、耦合性强的问题。 Spring框架的作用是整合其他各个框架，相当于一个领导，不干活，只负责管理人与人之前的关系。 ### Spring Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地new一个对象，而是让Spring框架帮你来完成这一切。 Spring概述Spring的发展历程Rod Johnson （ Spring 之父） 2017年9月份发布了 Spring 的最新版本 Spring5.0通用版（GA） Spring的优势 方便解耦，简化开发 AOP 编程的支持 声明式事务的支持 方便程序的测试 什么是耦合？程序间的依赖关系。 如何解耦？降低程序间的依赖关系。 实际开发中应该做到： 编译期不依赖，运行时才依赖。 思路？ 使用反射来创建对象，而避免使用new关键字。 通过读取配置文件来获取要创建的对象全限定类名。 IOC 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 起源 早在2004年，Martin Fowler就提出了“哪些方面的控制被反转了？”这个问题。他总结出是依赖对象的获得被反转了，因为大多数应用程序都是由两个或是更多的类通过彼此的合作来实现企业逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么这将导致代码高度耦合并且难以维护和调试。 XML方式配置IOC XML配置文件的方式可以配置Spring的IOC，需要在XML文件中引入Spring的约束文档，主要通过Bean标签来配置对象。 Bean标签基本配置用于配置对象交由Spring 来创建。 默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。 基本属性： id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名称 Bean标签范围配置scope:指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的 prototype 多例的 request WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中 session WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中 global session WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session （1）当scope的取值为singleton时 ​ Bean的实例化个数：1个 ​ Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 ​ Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 （2）当scope的取值为prototype时 ​ Bean的实例化个数：多个 ​ Bean的实例化时机：当调用getBean()方法时实例化Bean 对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了 Bean生命周期配置 init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 Bean实例化的三种方式【划重点了】无参构造实例化 它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败 XML文件： 1&lt;bean id="userDao" class="cn.skywalker.dao.impl.UserDaoImpl"/&gt; 工厂的静态方法实例化 工厂的静态方法返回Bean实例 XML文件： 123&lt;bean id="userDao" class="cn.skywalker.factory.StaticFactoryBean" factory-method="createUserDao" /&gt; java文件： 12345public class StaticFactoryBean &#123; public static UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 工厂的动态方法实例化 工厂的非静态方法返回Bean实例 XML文件： 12&lt;bean id="factoryBean" class="cn.skywalker.factory.DynamicFactoryBean"/&gt;&lt;bean id="userDao" factory-bean="factoryBean" factory-method="createUserDao"/&gt; java文件： 12345public class DynamicFactoryBean &#123; public UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 注解方式配置IOC 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。 12345678//@Component("userDao")@Repository("userDao")public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println("save running... ..."); &#125;&#125; 使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化 123456789//@Component("userService")@Service("userService")public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); @Override public void save() &#123; userDao.save(); &#125;&#125; 值得注意的是：使用注解进行开发时，需要在spring的xml配置文件中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 1234&lt;!--spring的xml配置文件--&gt;&lt;!--注解的组件扫描--&gt;&lt;context:component-scan base-package="cn.skywalker"/&gt; 引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载 1&lt;import resource="applicationContext-xxx.xml"/&gt; DI DI： Dependency Injection，依赖注入。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。容器全权负责的组件的装配，它会把符合依赖关系的对象通过JavaBean属性或者构造函数传递给需要的对象。通过JavaBean属性注射依赖关系的做法称为设值方法注入(Setter Injection)；将依赖关系作为构造函数参数传入的做法称为构造器注入（Constructor Injection）。 在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。 IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 XML方式实现依赖注入构造方法注入123456&lt;!-- spring的xml配置文件 --&gt;&lt;bean id="userDao" class="cn.skywalker.dao.impl.UserDaoImpl"/&gt;&lt;bean id="userService" class="cn.skywalker.service.impl.UserServiceImpl"&gt; &lt;constructor-arg name="userDao" ref="userDao"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 123456789101112131415/* 1.创建有参构造函数 2.经过xml的配置后，Spring会为userDao赋值*/ public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; set方法属性注入 传统的set方法注入 123456&lt;!-- spring的xml配置文件 --&gt;&lt;bean id="userDao" class="cn.skywalker.dao.impl.UserDaoImpl"/&gt;&lt;bean id="userService" class="cn.skywalker.service.impl.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao"/&gt;&lt;/bean&gt; p命名空间注入 p命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： 1、首先，需要引入p命名空间： 1xmlns:p="http://www.springframework.org/schema/p" 2、其次，需要修改注入方式： 1&lt;bean id="userService" class="cn.skywalker.service.impl.UserServiceImpl" p:userDao-ref="userDao"/&gt; 注解方法实现依赖注入使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入 123456789101112//@Component("userService")@Service("userService")public class UserServiceImpl implements UserService &#123; /*@Autowired @Qualifier("userDao")*/ @Resource(name="userDao") private UserDao userDao; @Override public void save() &#123; userDao.save(); &#125;&#125; 使用@Value进行字符串的注入 123456789101112131415@Repository("userDao")public class UserDaoImpl implements UserDao &#123; @Value("注入普通数据") private String str; @Value("$&#123;jdbc.driver&#125;") private String driver; @Override public void save() &#123; System.out.println(str); System.out.println(driver); System.out.println("save running... ..."); &#125;&#125; 使用@Scope标注Bean的范围 12345//@Scope("prototype")@Scope("singleton")public class UserDaoImpl implements UserDao &#123; //此处省略代码&#125; 使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法 12345678@PostConstructpublic void init()&#123; System.out.println("初始化方法....");&#125;@PreDestroypublic void destroy()&#123; System.out.println("销毁方法.....");&#125; 依赖注入的数据类型普通类型的注入 XML配置文件方式 12345678910111213141516171819public class UserDaoImpl implements UserDao &#123; private String company; private int age; public void setCompany(String company) &#123; this.company = company; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(company+"==="+age); System.out.println("UserDao save method running...."); &#125;&#125; 1234&lt;bean id="userDao" class="cn.skywalker.dao.impl.UserDaoImpl"&gt; &lt;property name="company" value="skywalker"&gt;&lt;/property&gt; &lt;property name="age" value="666"&gt;&lt;/property&gt;&lt;/bean&gt; 注解方式 123456789101112131415161718192021@Repositorypublic class UserDaoImpl implements UserDao &#123; @value("skywalker") private String company; @value("666") private int age; public void setCompany(String company) &#123; this.company = company; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(company+"==="+age); System.out.println("UserDao save method running...."); &#125;&#125; 引用类型的注入 XML配置文件方式注入 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao; @Override public void save() &#123; userDao.save(); &#125;&#125; 12345&lt;bean id="userDao" class="cn.skywalker.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;bean id="userService" class="cn.skywalker.service.impl.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;&lt;/bean&gt; 注解方式注入 123456789101112@Service("userService")public class UserServiceImpl implements UserService &#123; /*@Autowired @Qualifier("userDao")*/ @Resource(name="userDao") private UserDao userDao; @Override public void save() &#123; userDao.save(); &#125;&#125; 单列集合的注入泛型为普通数据类型的单列集合123456789101112public class UserDaoImpl implements UserDao &#123; private List&lt;String&gt; strList; public void setStrList(List&lt;String&gt; strList) &#123; this.strList = strList; &#125; public void save() &#123; System.out.println(strList); System.out.println("UserDao save method running...."); &#125;&#125; 123456789&lt;bean id="userDao" class="cn.skywalker.dao.impl.UserDaoImpl"&gt; &lt;property name="strList"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 泛型为引用数据类型的单列集合123456789101112public class UserDaoImpl implements UserDao &#123; private List&lt;User&gt; userList; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; public void save() &#123; System.out.println(userList); System.out.println("UserDao save method running...."); &#125;&#125; 12345678910111213&lt;bean id="u1" class="cn.skywalker.domain.User"/&gt;&lt;bean id="u2" class="cn.skywalker.domain.User"/&gt;&lt;bean id="userDao" class="cn.skywalker.dao.impl.UserDaoImpl"&gt; &lt;property name="userList"&gt; &lt;list&gt; &lt;bean class="cn.skywalker.domain.User"/&gt; &lt;bean class="cn.skywalker.domain.User"/&gt; &lt;ref bean="u1"/&gt; &lt;ref bean="u2"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 双列集合的注入123456789101112public class UserDaoImpl implements UserDao &#123; private Map&lt;String,User&gt; userMap; public void setUserMap(Map&lt;String, User&gt; userMap) &#123; this.userMap = userMap; &#125; public void save() &#123; System.out.println(userMap); System.out.println("UserDao save method running...."); &#125;&#125; 12345678910&lt;bean id="u1" class="cn.skywalker.domain.User"/&gt;&lt;bean id="u2" class="cn.skywalker.domain.User"/&gt;&lt;bean id="userDao" class="cn.skywalker.dao.impl.UserDaoImpl"&gt; &lt;property name="userMap"&gt; &lt;map&gt; &lt;entry key="user1" value-ref="u1"/&gt; &lt;entry key="user2" value-ref="u2"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; Properties类型的注入123456789101112public class UserDaoImpl implements UserDao &#123; private Properties properties; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public void save() &#123; System.out.println(properties); System.out.println("UserDao save method running...."); &#125;&#125; 123456789&lt;bean id="userDao" class="cn.skywalker.dao.impl.UserDaoImpl"&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="p1"&gt;aaa&lt;/prop&gt; &lt;prop key="p2"&gt;bbb&lt;/prop&gt; &lt;prop key="p3"&gt;ccc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; Spring配置数据源数据源（连接池）的作用数据源(连接池)是提高程序性能如出现的 事先实例化数据源，初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等 123456789开发步骤①导入数据源的坐标和数据库驱动坐标p②创建数据源对象③设置数据源的基本连接数据④使用数据源获取连接资源和归还连接资源 数据源的手动创建①导入c3p0和druid的坐标 123456789101112&lt;!-- C3P0连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; ①导入mysql数据库驱动坐标 123456&lt;!-- mysql驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; ②创建C3P0连接池 1234567891011121314@Testpublic void testC3P0() throws Exception &#123; //创建数据源 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //设置数据库连接参数 dataSource.setDriverClass("com.mysql.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/test"); dataSource.setUser("root"); dataSource.setPassword("root"); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close();&#125; ②创建Druid连接池 12345678910111213@Testpublic void testDruid() throws Exception &#123; //创建数据源 DruidDataSource dataSource = new DruidDataSource(); //设置数据库连接参数 dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/test"); dataSource.setUsername("root"); dataSource.setPassword("root"); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; ③提取jdbc.properties配置文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root ④读取jdbc.properties配置文件创建连接池 123456789101112@Testpublic void testC3P0ByProperties() throws Exception &#123; //加载类路径下的jdbc.properties ResourceBundle rb = ResourceBundle.getBundle("jdbc"); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(rb.getString("jdbc.driver")); dataSource.setJdbcUrl(rb.getString("jdbc.url")); dataSource.setUser(rb.getString("jdbc.username")); dataSource.setPassword(rb.getString("jdbc.password")); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; Spring配置数据源可以将DataSource的创建权交由Spring容器去完成 DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入 123456&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt;&lt;/bean&gt; 测试从容器当中获取数据源 1234ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");DataSource dataSource = (DataSource)applicationContext.getBean("dataSource");Connection connection = dataSource.getConnection();System.out.println(connection); 抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径： 命名空间：xmlns:context=”http://www.springframework.org/schema/context&quot; 约束路径：http://www.springframework.org/schema/context​ ​ http://www.springframework.org/schema/context/spring-context.xsd 1234567&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt; 技术要点Spring容器加载properties文件 12&lt;context:property-placeholder location="xx.properties"/&gt;&lt;property name="" value="$&#123;key&#125;"/&gt; 纯注解开发之Spring的新注解 注解 说明 @Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=”cn.skywalker”/&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载.properties 文件中的配置 @Import 用于导入其他配置类 配置核心注解文件 123456@Configuration@ComponentScan("cn.skywalker")@Import(&#123;DataSourceConfiguration.class&#125;)public class SpringConfiguration &#123; &#125; 上面文件通过@Import注解引入的注解配置文件： 1234567891011121314151617181920212223242526@PropertySource("classpath:jdbc.properties")public class DataSourceConfiguration &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; @Bean(name="dataSource") public DataSource getDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource; &#125; &#125; Spring整合Junit原始Junit测试Spring的问题在测试类中，每个测试方法都有以下两行代码： 12ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");AccountService as = ac.getBean("accountService",IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 上述问题解决思路让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它 将需要进行测试Bean直接在测试类中进行注入 Spring集成Junit步骤 导入spring集成Junit的坐标 使用@Runwith注解替换原来的运行器 使用@ContextConfiguration指定配置文件或配置类 使用@Autowired注入需要测试的对象 创建测试方法进行测试 Spring集成Junit代码实现①导入spring集成Junit的坐标 123456789101112&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ②使用@Runwith注解替换原来的运行期 123@RunWith(SpringJUnit4ClassRunner.class)public class SpringJunitTest &#123;&#125; ③使用@ContextConfiguration指定配置文件或配置类 1234567@RunWith(SpringJUnit4ClassRunner.class)//加载spring核心配置文件//@ContextConfiguration(value = &#123;"classpath:applicationContext.xml"&#125;)//加载spring核心配置类@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123;&#125; ④使用@Autowired注入需要测试的对象 123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService;&#125; ⑤创建测试方法进行测试 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService; @Test public void testUserService()&#123; userService.save(); &#125;&#125; Spring集成Junit步骤： 导入spring集成Junit的坐标 使用@Runwith注解替换原来的运行期 使用@ContextConfiguration指定配置文件或配置类 使用@Autowired注入需要测试的对象 创建测试方法进行测试 AOP AOP：Aspect Oriented Programming（面向切面编程），是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP的作用及其优势作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 AOP的底层实现实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 说到代理技术，也就是不修改原来代码的情况下增强功能。在这里提一下装饰者模式： 1234567891011121314151617181920212223242526272829303132/** * 诉求 : 是只写一次 / 我不想修改原来的代码 * 装饰者模式: * 对dao 进行了一个装饰 * 优点: 不修改代码的基础上对原有的功能进行增强 * 缺点: * 1) 如果方法增加了 ,代码需要变更 * 2) 每个接口都需要一个工具类 3) 没有实现代码只写一次 */public class LogUtil_UserDao &#123; private UserDao userDao; public LogUtil_UserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void save() &#123; long start =System.currentTimeMillis(); userDao.save(); long end =System.currentTimeMillis(); System.out.println("UserDao+save"+(end-start)); &#125; public void update() &#123; long start =System.currentTimeMillis(); userDao.update(); long end =System.currentTimeMillis(); System.out.println("UserDao+update"+(end-start)); &#125;&#125; AOP的动态代理技术常用的动态代理技术： JDK动态代理：基于接口的动态代理技术 cglib动态代理：基于父类的动态代理技术 JDK动态代理 目标类的接口 123public interface TargetInterface &#123; public void method();&#125; 目标类 123456public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println("Target running...."); &#125;&#125; 动态代理代码 123456789101112131415161718Target target = new Target(); //创建目标对象//创建代理对象TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("前置增强代码..."); Object invoke = method.invoke(target, args); System.out.println("后置增强代码..."); return invoke; &#125; &#125;);// 测试,当调用接口的任何方法时，代理对象的代码都无需修改proxy.method(); cglib动态代理 目标类 12345public class Target &#123; public void method() &#123; System.out.println("Target running...."); &#125;&#125; 动态代理代码 12345678910111213141516Target target = new Target(); //创建目标对象Enhancer enhancer = new Enhancer(); //创建增强器enhancer.setSuperclass(Target.class); //设置父类enhancer.setCallback(new MethodInterceptor() &#123; //设置回调 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("前置代码增强...."); Object invoke = method.invoke(target, objects); System.out.println("后置代码增强...."); return invoke; &#125;&#125;);Target proxy = (Target) enhancer.create(); //创建代理对象//测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method(); AOP的相关术语概念 Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 Aspect（切面）：是切入点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 123456789101112需要注意的几个概念： 【1】pointcut：切入点。 即被增强的方法（若未增强方法，基本等同于连接点joinpoint） 【2】advice：通知、增强内容。 即在切入点要增强的内容。 【3】aspect：切面。 即切入点+通知，也就是被增强后的方法。 【4】weaving：织入。 即将切入点与通知结合的过程，也就是增强方法的过程。一般指配置的过程 基于XML的AOP开发步骤导入AOP相关坐标12345678910111213&lt;!--导入spring的context坐标，context依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- aspectj的织入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt; 创建目标接口和目标类（内部有切点）12345678910public interface TargetInterface &#123; public void method();&#125;public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println("Target running...."); &#125;&#125; 创建通知类（内部有增强方法）123456public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println("前置代码增强....."); &#125;&#125; 将目标类和切面类的对象创建权交给Spring1234&lt;!--配置目标类--&gt;&lt;bean id="target" class="cn.skywalker.aop.Target"&gt;&lt;/bean&gt;&lt;!--配置通知类--&gt;&lt;bean id="myAspect" class="cn.skywalker.aop.MyAspect"&gt;&lt;/bean&gt; 在applicationContext.xml中配置织入关系 导入AOP命名空间 1234567891011&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 配置切点表达式、前置增强的织入关系 12345678&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref="myAspect"&gt; &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt; &lt;aop:before method="before" pointcut="execution(public void cn.skywalker.aop.Target.method())"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试代码1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class AopTest &#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; 配置详解切点表达式的写法表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： 123456789101112131415161718192021222324全部不省略 public void cn.skywalker.dao.UserDaoImpl.save() 修饰符可以省 void cn.skywalker.dao.UserDaoImpl.save() 方法名称可以使用通配符 void cn.skywalker.dao.UserDaoImpl.*() void cn.skywalker.dao.UserDaoImpl.find*() 类 名称可以使用通配符 void cn.skywalker.dao.*.*() void cn.skywalker.dao.UserDaoI*.*() 包 名称可以使用通配符,.. 表示当前包及其子包 void *..*.*() 返回值可以使用通配符 * *..*.*() 参数 基本类型 直接写名称 对象类型,写全类名 .. 表示有无参数均可 通知的类型通知的配置语法：&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt; 名称 标签 说明 前置通知 &lt;aop:before&gt; 用于配置前置通知，指定增强的方法在切入点方法之前执行。 后置通知 &lt;aop:after-returning&gt; 用于配置后置通知，指定增强的方法在切入点方法之后执行。 环绕通知 &lt;aop:around&gt; 用于配置环绕通知，指定增强的方法在切入点方法之前和之后都执行。 异常抛出通知 &lt;aop:after-throwing&gt; 用于配置异常抛出通知，指定增强的方法在出现异常时执行。 最终通知 &lt;aop:after&gt; 用于配置最终通知，无论增强方式执行是否有异常都会执行。 tips：使用环绕通知可以完成其他所有的通知功能。 12345678910111213141516171819202122public Object around(ProceedingJoinPoint pjp) &#123; Object obj = null; try &#123; System.out.println("类名:"+pjp.getTarget().getClass().getName()); System.out.println("方法名:"+ pjp.getSignature().getName()); //前置通知 System.out.println("before...."); //执行被代理方法 obj= pjp.proceed(pjp.getArgs());// userDao.save() //后置通知 System.out.println("afterRetruning...."); &#125; catch (Throwable throwable) &#123; //异常通知 System.out.println("afterThrowing...."); throwable.printStackTrace(); &#125;finally &#123; //最终通知 System.out.println("after...."); &#125; return obj; &#125; 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。 1234567&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref="myAspect"&gt; &lt;aop:pointcut id="myPointcut" expression="execution(* cn.skywalker.aop.*.*(..))"/&gt; &lt;aop:before method="before" pointcut-ref="myPointcut"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 基于注解的AOP开发步骤创建目标接口和目标类（内部有切点）12345678910public interface TargetInterface &#123; public void method();&#125;public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println("Target running...."); &#125;&#125; 创建切面类（内部有增强方法）123456public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println("前置代码增强....."); &#125;&#125; 将目标类和切面类的对象创建权交给 spring12345678910111213@Component("target")public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println("Target running...."); &#125;&#125;@Component("myAspect")public class MyAspect &#123; public void before()&#123; System.out.println("前置代码增强....."); &#125;&#125; 在切面类中使用注解配置织入关系12345678@Component("myAspect")@Aspectpublic class MyAspect &#123; @Before("execution(* cn.skywalker.aop.*.*(..))") public void before()&#123; System.out.println("前置代码增强....."); &#125;&#125; 在配置文件中开启组件扫描和 AOP 的自动代理12345&lt;!--组件扫描--&gt;&lt;context:component-scan base-package="cn.skywalker.aop"/&gt;&lt;!--aop的自动代理--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 测试代码12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class AopTest &#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; 配置详解注解通知的类型通知的配置语法：@通知注解(“切点表达式”) 名称 标签 说明 前置通知 @Before 用于配置前置通知，指定增强的方法在切入点方法之前执行。 后置通知 @AfterReturning 用于配置后置通知，指定增强的方法在切入点方法之后执行。 环绕通知 @Around 用于配置环绕通知，指定增强的方法在切入点方法之前和之后都执行。 异常抛出通知 @AfterThrowing 用于配置异常抛出通知，指定增强的方法在出现异常时执行。 最终通知 @After 用于配置最终通知，无论增强方式执行是否有异常都会执行。 切点表达式的抽取 同 xml配置aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： 12345678910@Component("myAspect")@Aspectpublic class MyAspect &#123; @Before("MyAspect.myPoint()") public void before()&#123; System.out.println("前置代码增强....."); &#125; @Pointcut("execution(* cn.skywalker.aop.*.*(..))") public void myPoint()&#123;&#125;&#125; Spring相关APIApplicationContext的继承体系applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象。 ApplicationContext的实现类 ClassPathXmlApplicationContext 它是从类的根路径下加载配置文件 推荐使用这种 FileSystemXmlApplicationContext 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 getBean()方法使用 getBean()方法的源码： 12345678public Object getBean(String name) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(name);&#125;public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(requiredType);&#125; 其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。 当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错 getBean()方法的使用： 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");UserService userService1 = (UserService) applicationContext.getBean("userService");UserService userService2 = applicationContext.getBean(UserService.class); 声明式事务编程式事务控制相关对象PlatformTransactionManagerPlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。 注意：PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类。 例如： Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager TransactionDefinitionTransactionDefinition 是事务的定义信息对象 事务隔离级别设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED(oracle) ISOLATION_REPEATABLE_READ(mysql) ISOLATION_SERIALIZABLE 事务传播行为 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 TransactionStatusTransactionStatus 接口提供的是事务具体的运行状态。 基于 XML 的声明式事务控制什么是声明式事务控制Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便 注意：Spring 声明式事务控制底层就是AOP。 声明式事务控制的实现声明式事务控制明确事项： 谁是切点？ 谁是通知？ 配置切面？ ①引入tx命名空间 1234567891011121314&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; ②配置事务增强 1234567891011&lt;!--平台事务管理器--&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--事务增强配置--&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; ③配置事务 AOP 织入 12345&lt;!--事务的aop增强--&gt;&lt;aop:config&gt; &lt;aop:pointcut id="myPointcut" expression="execution(* cn.skywalker.service.impl.*.*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPointcut"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; ④测试事务控制转账业务代码 123456@Overridepublic void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money);&#125; 切点方法的事务参数的配置123456&lt;!--事务增强配置--&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中，tx:method 代表切点方法的事务参数的配置，例如： 1&lt;tx:method name="transfer" isolation="REPEATABLE_READ" propagation="REQUIRED" timeout="-1" read-only="false"/&gt; name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 基于注解的声明式事务控制使用注解配置声明式事务控制 编写 AccoutDao 12345678910111213@Repository("accountDao")public class AccountDaoImpl implements AccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) &#123; jdbcTemplate.update("update account set money=money-? where name=?",money,outMan); &#125; public void in(String inMan, double money) &#123; jdbcTemplate.update("update account set money=money+? where name=?",money,inMan); &#125;&#125; 编写 AccoutService 12345678910111213@Service("accountService")@Transactionalpublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) public void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); &#125;&#125; 编写 applicationContext.xml 配置文件 123456&lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;&lt;!--组件扫描--&gt;&lt;context:component-scan base-package="cn.skywalker"/&gt;&lt;!--事务的注解驱动--&gt;&lt;tx:annotation-driven/&gt; 注解配置声明式事务控制解析 使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。 注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。 使用在方法上，不同的方法可以采用不同的事务参数配置。 Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt; SpringMVC SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。 MyBatis mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
        <tag>MyBatis</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2FNginx%2F15_Nginx%2F</url>
    <content type="text"></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Tomcat</tag>
        <tag>reverse proxy</tag>
        <tag>load balancing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2FMaven%2F13_maven%2F</url>
    <content type="text"></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax&Json]]></title>
    <url>%2FJavaScript%2F11_Ajax%2F</url>
    <content type="text"><![CDATA[.imp{ color:red; } .lg{ font-size:25px; } Ajax Ajax概念：ASynchronous JavaScript And XML 异步的JavaScript 和 XML Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 同步和异步 客户端和服务器端相互通信的基础上。 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 实现方式原生JavaScript实现方式1234567891011121314151617181920212223242526272829303132333435363738394041//1.创建核心对象var xmlhttp;if (window.XMLHttpRequest)&#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest();&#125;else&#123;// code for IE6, IE5 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");&#125;//2. 建立连接/* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步）*/xmlhttp.open("GET","ajaxServlet?username=tom",true);//3.发送请求xmlhttp.send();//4.接受并处理来自服务器的响应结果//获取方式 ：xmlhttp.responseText//什么时候获取？当服务器响应成功后再获取//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。xmlhttp.onreadystatechange=function()&#123; //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125;&#125; JQeury实现方式$.ajax()123456789101112131415//使用$.ajax()发送异步请求$.ajax(&#123; url:"ajaxServlet1111" , // 请求路径 type:"POST" , //请求方式 //data: "username=jack&amp;age=23",//请求参数 data:&#123;"username":"jack","age":23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert("出错啦...") &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:"text"//设置接受到的响应数据的格式&#125;); $.get()1234567$.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 $.post()1234567$.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 Ajax技术案例案例要求使用Ajax技术，实现用户名是否存在的验证功能。 前台页面使用JS实现用户名的校验123456789101112131415161718192021222324252627282930313233343536373839//定义一个函数checkUsernamefunction checkUsername() &#123; //获取span、p标签 var $s_user = $("#s_user"); var $p_user = $("#p_user"); //清空span、p标签 $s_user.html(""); $p_user.html(""); //1.获取用户名信息 var username = $("#username").val(); //2.定义正则表达式 var reg = /^\w&#123;6,12&#125;$/; //3.校验 var flag = reg.test(username); //4.逻辑判断然后向span、p标签替换内容 if (flag) &#123; $.post( // 1.传递url "AjaxCheckUsernameServlet", // 2.传递data（参数） &#123;username: user&#125;, // 3.回调函数 function (data) &#123; if (data == "true") &#123; //数据库中不存在该用户名 $s_user.html("&lt;img src='img/gou.png' width='30' height='20'&gt;"); &#125; else &#123; //数据库中已存在该用户名 $p_user.html("用户名已存在！请重新输入."); &#125; &#125;, // 4.返回值类型 "text" ); &#125; else &#123; //不符合正则校验规则 $p_user.html("用户名格式错误!以任意字符开头结尾，6~12个字符!"); &#125;&#125; AjaxCheckUsernameServlet的编写12345678910111213141516171819202122232425262728293031package servlet;import domain.User;import service.UserService;import service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author SkyWalker * @create 2019 - 08 - 23 - 18:56 */@WebServlet("/AjaxCheckUsernameServlet")public class AjaxCheckUsernameServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; User user = new User(); user.setUname(request.getParameter("username")); UserService service = new UserServiceImpl(); String s = service.userExists(user); response.getWriter().write(s); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125;&#125; UserServiceImpl的编写123456789101112131415161718package service.impl;import dao.UserDao;import domain.User;import service.UserService;/** * @author SkyWalker * @create 2019 - 08 - 23 - 18:59 */public class UserServiceImpl implements UserService &#123; private static UserDao dao = new UserDao(); @Override public String userExists(User user) &#123; return dao.userExists(user); &#125;&#125; UserDaoImpl的编写12345678910111213141516171819202122232425262728293031package dao;import dao.UserDao;import domain.User;import org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import util.JDBCUtils;/** * @author SkyWalker * @create 2019 - 08 - 12 - 10:20 */public class UserDaoImpl implements UserDao &#123; private static JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); public String userExists(User user) &#123; Integer count = null; try &#123; count = template.queryForObject("select count(*) from user where uname = ?", Integer.class, user.getUname()); &#125; catch (DataAccessException e) &#123; e.printStackTrace(); &#125; if (count != 0) &#123; return "false"; &#125; else &#123; return "true"; &#125; &#125;&#125; Json 概念：JavaScript Object Notation JavaScript对象表示法 特点 json现在多用于存储和交换文本信息的语法 进行数据的传输 JSON 比 XML 更小、更快，更易解析 语法基本规则 数据在名称/值对中：json数据是由键值对构成的 键用引号(单双都行)引起来，也可以不使用引号 值得取值类型： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {&quot;persons&quot;:[{},{}]} 对象（在花括号中）{&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}} null 数据由逗号分隔：多个键值对由逗号分隔 花括号保存对象：使用{}定义json 格式 方括号保存数组：[] 获取数据 json对象.键名 json对象[“键名”] 数组对象[索引] 遍历 123456789101112131415161718192021222324//1.定义基本格式var person = &#123;"name": "张三", age: 23, 'gender': true&#125;;var ps = [ &#123;"name": "张三", "age": 23, "gender": true&#125;, &#123;"name": "李四", "age": 24, "gender": true&#125;, &#123;"name": "王五", "age": 25, "gender": false&#125; ];//获取person对象中所有的键和值//for in 循环/* for(var key in person)&#123; //这样的方式获取不行。因为相当于 person."name" //alert(key + ":" + person.key); alert(key+":"+person[key]);&#125;*///获取ps中的所有值for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+":"+p[key]); &#125;&#125; Json数据和Java对象的相互转换 Json解析器：常见的解析器：Jsonlib，Gson，fastjson，jackson Json转为Java对象 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换：readValue(json字符串数据,Class) Java对象转换Json（使用Jackson） 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 转换方法： writeValue(参数1，obj); 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 writeValueAsString(obj):将对象转为json字符串 注解： @JsonIgnore：排除属性。 @JsonFormat：属性值得格式化，如：@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 复杂java对象转换 List：数组 Map：对象格式一致]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AJAX</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML]]></title>
    <url>%2FXML%2F08_XML%2F</url>
    <content type="text"><![CDATA[概念 Extensible Markup Language，可扩展标记语言。 可扩展：标签都是自定义的。&lt;user&gt;、&lt;student&gt; w3c：万维网联盟 xml的梦想 取代html(破灭) 存储数据代替一部分sql的功能(破灭) 作为数据的传输的载体(程序和程序交流的平台),(破灭) —-&gt;被json的东西替代! 配置文件(取代properties), (一部分的功能被”注解”所取代) XML的基础语法 文档声明必须在第一行 有且只有一个跟标签 区分大小写 属性必须用”引号”引起来 标签要正确闭合 快速入门： 123456789101112131415&lt;?xml version='1.0' ?&gt;&lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; XML的组成 文档声明： 格式：&lt;?xml 属性列表 ?&gt; 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值：yes：不依赖其他文件。no：依赖其他文件 指令：结合css的，&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 标签：标签名称自定义。 规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性：id属性值唯一 文本域： CDATA区：在该区域中的数据会被原样展示，格式： &lt;![CDATA[ 数据 ]]&gt; XML的约束 作用：规定xml的书写规则 作为框架的使用者(程序员)： 能够在xml中引入约束文档 能够简单的读懂约束文档 分类： dtd:一种简单的约束技术 schema:一种复杂的约束技术 dtd 缺点： 不可以进行更细节的约束 他不能引入多个约束 引入： 引入本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd本地路径&quot;&gt; 引入网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL（网络路径）&quot;&gt; schema 解决了dtd出现的问题 约束文档的头： 1234&lt;xsd:schema xmlns=&quot;http://www.itcast.cn/xml&quot; ---&gt; 给约束文档起名称空间, 专门用来区分多个schema中对相同元素的约束 xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; ----&gt;引入&quot;元约束&quot;, 告诉w3c这个是一个约束文档被约束的xml的头&gt; 引入： 12345&lt;跟标签 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; ----&gt;告诉w3c这个是一个被约束文档 xsi:schemaLocation=&quot;http://www.itcast.cn/xml stu.xml&quot; ----&gt; 引入约束文档的位置 xmlns=&quot;http://www.itcast.cn/xml&quot; ---&gt;为约束文档起别名&gt; 解析思想解析 概念：操作xml文档，将文档中的数据读取到内存中 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 DOM 核心思想：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：可以进行crud的操作 缺点：容易内存溢出 SAX 核心思想：逐行读取, 基于事件驱动 优点：不会内容溢出 缺点：不能增删改 XML常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup JSOUP，DOM4J，JAXP都是DOM思想，pull是SAX思想 快速入门 123456789101112131415161718192021222324252627&gt; /**&gt; 步骤：&gt; 1. 导入jar包&gt; 2. 获取Document对象&gt; 3. 获取对应的标签Element对象&gt; 4. 获取数据&gt; */&gt; &gt; /**&gt; 代码：&gt; */&gt; &gt; //2.1获取student.xml的path&gt; String path = JsoupDemo1.class.getClassLoader().getResource("student.xml").getPath();&gt; //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document&gt; Document document = Jsoup.parse(new File(path), "utf-8");&gt; //3.获取元素对象 Element&gt; Elements elements = document.getElementsByTag("name");&gt; &gt; System.out.println(elements.size());&gt; //3.1获取第一个name的Element对象&gt; Element element = elements.get(0);&gt; //3.2获取数据&gt; String name = element.text();&gt; System.out.println(name);&gt; &gt; Jsoup类 工具类，可以解析html或xml文档，返回Document 方法： | Modifier and Type | Method | Description || :—————- | :———————————– | :—————————————- || static Document | parse(File in, String charsetName) | 解析xml或html文件 || static Document | parse(String html) | 解析xml或html字符串 || static Document | parse(URL url, int timeoutMillis) | 通过网络路径获取指定的html或xml的文档对象 | Document类 文档对象。代表内存中的DOM树 常用方法（获取Element对象方法）： Modifier and Type Method Description Element getElementById(String id) 根据id属性值获取唯一的element对象 Elements getElementsByTag(String tagName) 根据标签名称获取元素对象集合 Elements getElementsByAttribute(String key) 根据属性名称获取元素对象集合 Elements getElementsByAttributeValue(String key, String value) 根据对应的属性名和属性值获取元素对象集合 Elements类 元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 Element类 文档对象。代表内存中的DOM树 常用方法： 获取Element对象方法 获取属性值 获取文本内容 Modifier and Type Method Description Element getElementById(String id) 根据id属性值获取唯一的element对象 Elements getElementsByTag(String tagName) 根据标签名称获取元素对象集合 Elements getElementsByAttribute(String key) 根据属性名称获取元素对象集合 Elements getElementsByAttributeValue(String key, String value) 根据对应的属性名和属性值获取元素对象集合 String attr(String attributeKey) 根据属性名称获取属性值 String text() 获取此元素及其所有子元素的组合文本。 String html() 获取标签体的所有内容(包括字标签的字符串内容) Node类 节点对象。是Document和Element的父类 快捷查询方式Jsoup.selector Jsoup中的方法，起到了选择器的作用 使用的方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 1234元素选择器: &quot;元素名&quot;属性选择器: &quot;元素[属性名=&apos;属性值&apos;]&quot; 或者 &quot;元素[属性名=属性值]&quot; 子元素选择器: &quot;选择器1 &gt; 选择器2&quot; ----&gt;找&quot;选择器1&quot;下的直接子类&quot;选择器2&quot;后代选择器: &quot;选择器1 选择器2&quot;----&gt;找&quot;选择器1&quot;下的所有子类&quot;选择器2&quot; XPath XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 语法： 123// 不论层级查询. 例如: &quot;//property&quot; ---&gt;不论层级查找&quot;property&quot;标签/ 子父集关系 例如: &quot;//aaa/bbb&quot; ----&gt;查&quot;aaa&quot;标签下的一级&quot;bbb&quot;标签@属性=&apos;值&apos; 例如: &quot;//aaa[@name=&apos;张三&apos;]&quot; ----&gt;查aaa标签但是要求aaa标签必须有name属性,而且值为&apos;张三&apos; 代码： 12345678910111213141516171819202122232425262728293031323334353637//1.获取student.xml的pathString path = XPathDemo.class.getClassLoader().getResource("student.xml").getPath();//2.获取Document对象Document document = Jsoup.parse(new File(path), "utf-8");//3.根据document对象，创建JXDocument对象JXDocument jxDocument = new JXDocument(document);//4.结合xpath语法查询//4.1查询所有student标签List&lt;JXNode&gt; jxNodes = jxDocument.selN("//student");for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode);&#125;System.out.println("--------------------");//4.2查询所有student标签下的name标签List&lt;JXNode&gt; jxNodes2 = jxDocument.selN("//student/name");for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode);&#125;System.out.println("--------------------");//4.3查询student标签下带有id属性的name标签List&lt;JXNode&gt; jxNodes3 = jxDocument.selN("//student/name[@id]");for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode);&#125;System.out.println("--------------------");//4.4查询student标签下带有id属性的name标签 并且id属性值为skywalkerList&lt;JXNode&gt; jxNodes4 = jxDocument.selN("//student/name[@id='skywalker']");for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode);&#125;]]></content>
      <categories>
        <category>XML</category>
      </categories>
      <tags>
        <tag>-XML -HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2FJava%2F04_JDBC%2F</url>
    <content type="text"><![CDATA[JDBC概述 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库。 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 JDBC底层使用了网络编程技术，将Java代码中的SQL代码发送给服务器的数据库，执行完再返回结果给Java代码。 使用JDBC的准备 因为底层是网络编程技术，所以网络三要素（IP，协议，端口）都要指明。 还要指明使用哪个数据库、用户名、密码。 快速入门： 1234567891011121314151617181920212223242526272829步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键--&gt;Add As Library 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql，接受返回结果 7. 处理结果 8. 释放资源代码实现： //1.导入驱动jar包 //2.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "root"); //4.定义sql语句 String sql = "update account set balance = 500 where id = 1"; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); DriverManager：驱动管理对象 功能 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(“com.mysql.jdbc.Driver”); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块。 源码如下： 1234567891011121314151617package com.mysql.jdbc;import java.sql.DriverManager;import java.sql.SQLException;public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125;&#125; 获取数据库连接： 方法：static Connection getConnection(String url, String user, String password) 参数： url：指定连接的路径 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 例子：jdbc:mysql://localhost:3306/student 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 可以在URL后面拼接?characterEncoding=utf8来指定使用UTF-8编码处理数据 user：用户名 password：密码 两种注册驱动的方式（面试题）： 1、Class.forName(“com.mysql.jdbc.Driver”); 2、DriverManager.registerDriver(new Driver()); 两者的区别： 方式一只会注册一次驱动，触发Driver类中的静态代码块执行。 而方式二会注册两次驱动。在内存中生成两个不同的Driver对象。 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 Connection：数据库连接对象 功能： 获取执行sql 的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 功能 执行sql boolean execute(String sql) ：可以执行任意的sql 返回值：如果第一个结果为 ResultSet 对象，则返回 true；如果其为更新计数或者不存在任何结果，则返回 false int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值： (1) 对于 SQL 数据操作语言 (DML) 语句，返回行计数 (2) 对于什么都不返回的 SQL 语句，返回 0 ResultSet executeQuery(String sql) ：执行DQL（select)语句 返回值：包含给定查询所生成数据的 ResultSet 对象；永远不能为 null ResultSet：结果集对象,封装查询结果 boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 Xxx：代表数据类型 如： int getInt() , String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 使用步骤（注意）： 游标向下移动一行 判断是否有数据 获取数据 12345678910//循环判断游标是否是最后一行末尾。while(rs.next())&#123; //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString("name"); double balance = rs.getDouble(3); System.out.println(id + "---" + name + "---" + balance);&#125; PreparedStatement：执行sql的对象 SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 输入用户随便，输入密码：a’ or ‘a’ = ‘a sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ 解决sql注入问题：使用PreparedStatement对象来解决 预编译的SQL：参数使用?作为占位符 步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 注册驱动 获取数据库连接对象 Connection 定义sql 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给？赋值： 方法：setXxx(参数1,参数2) 参数1：？的位置编号 从1 开始 参数2：？的值 执行sql，接受返回结果，不需要传递sql语句 处理结果 释放资源 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 可以防止SQL注入 效率更高 抽取JDBC工具类 ： JDBCUtils 目的：简化书写 分析： 注册驱动也抽取 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性。 解决：配置文件 1234567#文件名：jdbc.properties#以连接MySQL数据库中的skywalker库为例，内容如下：driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/skywalker#如果连接的是本机MySQL服务器，url可以简写为url=jdbc:mysql:///skywalkeruser=rootpassword=123 抽取一个方法释放资源 JDBCUtils代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.sql.*;import java.util.Properties;/** * @author SkyWalker * @create 2019 - 07 - 28 - 9:52 */public class JDBCUtils &#123; private static String driver; // driver private static String url; // url private static String user; // user private static String password; // password static &#123; try &#123; //从配置文件中读取数据库配置信息 Properties prop = new Properties(); prop.load(JDBCUtils.class.getClassLoader().getResourceAsStream("jdbc.properties")); driver = prop.getProperty("driver"); url = prop.getProperty("url"); user = prop.getProperty("user"); password = prop.getProperty("password"); //注册驱动 Class.forName(driver); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; Connection conn = null; try &#123; conn = DriverManager.getConnection(url, user, password); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; public static void release(Connection conn, PreparedStatement ps, ResultSet rs) &#123; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDBC控制事务 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 操作： 开启事务。 完成后，提交事务。 如果发生异常，则回滚事务。 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 案例：jack给skywalker转账500元的事务，对比数据库中的数据进行测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;/** * @author SkyWalker * @create 2019 - 07 - 28 - 17:28 */public class Demo &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps1 = null; PreparedStatement ps2 = null; try &#123; conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); String sql1 = "update account set balance = balance - ? where `name` = ?"; String sql2 = "update account set balance = balance + ? where `name` = ?"; ps1 = conn.prepareStatement(sql1); ps2 = conn.prepareStatement(sql2); // jack 给 skywalker 转账500 ps1.setDouble(1, 500); ps1.setString(2, "jack"); ps2.setDouble(1, 500); ps2.setString(2, "skywalker"); //开始执行事务的操作 ps1.executeUpdate(); //手动制造了一个异常，若不进行回滚操作，则数据库中的数据会发生问题。事务的一致性无法保持。 int i = 3 / 0; ps2.executeUpdate(); //事务完成后，提交事务 conn.commit(); &#125; catch (Exception e) &#123; //事务未完成，回滚事务 if (conn != null) &#123; try &#123; conn.rollback(); &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(conn, ps1, null); if (ps2 != null) &#123; try &#123; ps2.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 数据库连接池 概念：其实就是一个容器（集合），存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处： 节约资源 用户访问高效 方便对连接进行统一管理 连接池的实现： 标准接口：DataSource javax.sql包下的 获取连接：getConnection() 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 分类： C3P0 导包 定义配置文件 可以是properties形式的，也可以是xml形式的 需要将配置文件放在src下 创建核心对象，数据库连接池对象 ComboPooledDataSource 调用getConnction()方法获取连接 Druid 导包 定义配置文件 是properties形式的 可以叫任意名称 可以放在任意目录下 手动加载配置文件 获取数据库连接池对象：通过工厂类来获取 DruidDataSourceFactory 调用getConnction()方法获取连接 Spring JDBC Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发。 步骤： 导入jar包 创建JdbcTemplate对象。依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 update():执行DML语句。增、删、改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList():查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query():查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject：查询结果，将结果封装为对象 一般用于聚合函数的查询 对于Spring JDBC的练习： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import cn.skywalker.Druid.JDBCUtils;import org.junit.Test;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import cn.skywalker.domain.Employee;import java.util.List;import java.util.Map;/** * @author SkyWalker * @create 2019 - 07 - 30 - 15:24 */public class Demo &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 将编号为1011的工资更新为7500 */ @Test public void test01() &#123; template.update("update emp set salary = ? where id = ?", 7500, 1011); &#125; /** * 添加一条记录 */ @Test public void test02() &#123; template.update("insert into emp(id,ename,dept_id) values (?,?,?)", 1015, "张飞", 20); &#125; /** * 删除刚才的记录 */ @Test public void test03() &#123; template.update("delete from emp where id = ?", 1015); &#125; /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test04() &#123; Map&lt;String, Object&gt; map = template.queryForMap("select * from emp where id = ?", 1001); System.out.println(map); &#125; /** * 5. 查询所有记录，将其封装为List */ @Test public void test05() &#123; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList("select * from emp"); for (Map&lt;String, Object&gt; map : list) &#123; System.out.println(map); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test06() &#123; List&lt;Employee&gt; emplist = template.query("select * from emp", new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class)); for (Employee emp : emplist) &#123; System.out.println(emp); &#125; &#125; /** * 7. 查询总记录数 */ @Test public void test07() &#123; Integer count = template.queryForObject("select count(*) from emp", Integer.class); System.out.println(count); &#125; /** * 8. 查询id为1008的员工，封装为Emp对象 */ @Test public void test08()&#123; Employee employee = template.queryForObject("select * from emp where id = ?", new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class), 1008); System.out.println(employee); &#125;&#125; C3P0配置文件12345678910111213141516171819202122232425262728&lt;c3p0-config&gt; &lt;!-- 使用默认的配置读取连接池对象 --&gt; &lt;default-config&gt; &lt;!-- 连接参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/skywalker&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;123&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;10&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;3000&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name="otherc3p0"&gt; &lt;!-- 连接参数 --&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/skywalker&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;123&lt;/property&gt; &lt;!-- 连接池参数 --&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;8&lt;/property&gt; &lt;property name="checkoutTimeout"&gt;1000&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; tips： c3p0连接池既可以使用xml配置文件，也可以使用properties配置文件 c3p0连接池必须将配置文件放置在模块下的src目录下，因为c3p0会自动在src下寻找配置文件，自动加载 Druid配置文件1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/skywalkerusername=rootpassword=123initialSize=5maxActive=10maxWait=3000 tips： druid配置文件只能是properties格式 druid配置文件可以放置在项目的任意目录下，因为在使用时需要手动加载配置文件。 BeanUtils工具类 用于封装JavaBean的，简化了数据封装过程。 几个概念： JavaBean：标准的Java类 要求： 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 功能：封装数据 属性：setter和getter方法截取后的产物例如：getUsername() –&gt; Username–&gt; username 成员变量：类中定义的变量 工具类中的常用方法： 方法名 描述 static void setProperty(Object bean, String name, Object value) 设置指定的属性值，根据需要执行类型转换，以符合目标属性的类型。 static String getProperty(Object bean, String name) 以字符串的形式返回指定bean的指定属性的值，无论使用哪种属性引用格式。 static void populate(Object bean, Map properties) 将map集合的键值对信息，封装到对应的JavaBean对象中 对于JDBC的复习与总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197package cn.skywalker.review;import cn.skywalker.domain.Employee;import com.alibaba.druid.pool.DruidDataSourceFactory;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.junit.Test;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.sql.*;import java.util.List;import java.util.Map;import java.util.Properties;/** * @author SkyWalker * @create 2019 - 08 - 03 - 22:46 */public class Demo &#123; @Test public void testBaseJDBC() throws Exception &#123; //1.导入驱动jar包mysql-connector-java-5.1.37-bin.jar //2.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //3.获取Connection连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/skywalker", "root", "123"); //4.定义sql语句 String sql = "insert into stu(id,name) values(?,?)"; //5.获取sql执行对象PreparedStatement PreparedStatement pst = conn.prepareStatement(sql); //6.执行sql pst.setInt(1, 2); pst.setString(2, "skywalker"); int count = pst.executeUpdate(); //7.处理结果 System.out.println(count + "行数据受到影响"); //8.释放资源 pst.close(); conn.close(); &#125; @Test public void testJDBCUtils() throws SQLException &#123; //1.通过工具类获取Connection连接对象（省略了导入驱动jar包、注册驱动步骤） Connection conn = JDBCUtils.getConnection(); //2.定义sql语句 String sql = "select * from stu"; //3.通过conn获取sql执行对象pst PreparedStatement pst = conn.prepareStatement(sql); //4.执行sql，获取结果集 ResultSet rs = pst.executeQuery(); //5.处理结果 System.out.println("id\tname"); while (rs.next()) &#123; int id = rs.getInt("id"); String name = rs.getString("name"); System.out.println(id + "\t" + name);// System.out.println("id: " + id + " , name: " + name); &#125; //6.释放资源 JDBCUtils.release(rs, pst, conn); &#125; @Test public void testTransaction() &#123; //准备连接对象、sql执行对象 Connection conn = null; PreparedStatement pst1 = null; PreparedStatement pst2 = null; try &#123; //开启事务 conn = JDBCUtils.getConnection(); conn.setAutoCommit(false); //定义sql语句 String sql1 = "update account set balance = balance - ? where name = ?"; String sql2 = "update account set balance = balance + ? where name = ?"; pst1 = conn.prepareStatement(sql1); pst2 = conn.prepareStatement(sql2); //执行sql pst1.setInt(1, 500); pst1.setString(2, "skywalker"); pst2.setInt(1, 500); pst2.setString(2, "jack"); pst1.executeUpdate(); pst2.executeUpdate(); //手动制造一个异常 int i = 3 / 0; //提交事务 conn.commit(); &#125; catch (Exception e) &#123; //捕获异常并回滚 if (conn != null) &#123; try &#123; conn.rollback(); System.out.println("检测到发生异常，已对本次事务进行回滚操作。"); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125; finally &#123; //释放资源 JDBCUtils.release(null, pst1, conn); if (pst2 != null) &#123; try &#123; pst2.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Test public void testC3P0() throws Exception &#123; //1.导包 //2.定义配置文件 //3.创建核心对象ComboPooledDataSource（C3P0默认从src目录下找c3p0-config.xml或者c3p0-config.properties） DataSource ds = new ComboPooledDataSource(); //4.通过ds获取连接 Connection conn = ds.getConnection(); //5.获取到连接后，即可对数据库进行操作 //.... //6.归还连接（并没有释放资源，而是将资源归还给了连接池） conn.close(); &#125; @Test public void testDruid() throws Exception &#123; //1.导包 //2.定义配置文件 //3.手动加载配置文件 Properties prop = new Properties(); prop.load(Demo.class.getClassLoader().getResourceAsStream("druid.properties")); //4.通过DruidDataSourceFactory获取DataSource对象 DataSource ds = DruidDataSourceFactory.createDataSource(prop); //5.使用DataSource获取Connection连接对象 Connection conn = ds.getConnection(); //6.对数据库进行操作 //... //7.归还连接 conn.close(); &#125; @Test public void testTemplate() throws Exception &#123; //1.导包 //2.创建JdbcTemplate对象，依赖于数据源DataSource，一般使用druid获取数据源 Properties prop = new Properties(); prop.load(Demo.class.getClassLoader().getResourceAsStream("druid.properties")); DataSource ds = DruidDataSourceFactory.createDataSource(prop); JdbcTemplate template = new JdbcTemplate(ds); //3.调用JdbcTemplate的方法对数据库进行操作 /* ------&gt;3.1 update(String sql, ...args)方法：执行DML语句，对数据进行增，删，改。 */ int updateCount = template.update("update stu set name = ? where id = ?", "jack", 2); System.out.println(updateCount + "行数据受到影响"); /* ------&gt;3.2 queryForMap(String sql, ...args)方法：查询结果将结果集封装为Map集合， 将列名作为key，将值作为value。将这一条记录封装为一个Map集合。 注意：这个方法的结果集长度只能为1。 */ Map&lt;String, Object&gt; map = template.queryForMap("select * from stu where id = ?", 1); System.out.println(map); /* ------&gt;3.3 queryForList(String sql, ...args)方法：查询结果将结果集封装为List集合 注意：此方法是将每一行结果封装为一个Map集合，然后在将Map对象封装到List集合中 */ List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList("select * from stu"); for (Map&lt;String, Object&gt; maps : list) &#123; System.out.println(maps); &#125; /* ------&gt;3.4 query(String sql, RowMapper&lt;T&gt; rowMapper, ...args)方法： 查询结果集并将结果集以指定的类型封装到List集合中。 注意：RowMapper&lt;T&gt; 是一个接口， */ List&lt;Employee&gt; employees = template.query("select * from emp where id = ? or id = ?", new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class), 1001, 1002); for (Employee emp : employees) &#123; System.out.println(emp); &#125; /* ------&gt;3.5 queryForObject(String sql , Class&lt;? extends Object&gt;)方法： 查询结果，将结果封装为一个指定类型的对象 一般用于聚合函数的查询 */ Integer count = template.queryForObject("select count(*) from stu", Integer.class); System.out.println("count = " + count); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>Java</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2FDatabase%2F12_redis%2F</url>
    <content type="text"><![CDATA[.imp{ color:red; } .lg{ font-size:25px; } 概念 Redis是一款高性能的NoSQL系列的非关系型数据库 什么是NoSQL&nbsp;&nbsp;&nbsp;&nbsp;NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。&nbsp;&nbsp;&nbsp;&nbsp;随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。### NOSQL和关系型数据库比较优点：1. 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。2. 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。3. 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。4. 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。缺点：1. 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。2. 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。3. 不提供关系型数据库对事务的处理。### 非关系型数据库的优势1. 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。2. 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。### 关系型数据库的优势1. 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。2. 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。### 总结&nbsp;&nbsp;&nbsp;&nbsp;关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据。 主流的NoSQL产品键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 什么是Redis&nbsp;&nbsp;&nbsp;&nbsp;Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedset redis的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离 下载安装 官网：https://redis.io 中文网：http://www.redis.net.cn/ 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端 命令操作redis的数据结构 redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构： 字符串类型 string 哈希类型 hash ： map格式 列表类型 list ： linkedlist格式。支持重复元素 集合类型 set ： 不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 字符串类型 string 存储： set key value12127.0.0.1:6379&gt; set username zhangsanOK 获取： get key12127.0.0.1:6379&gt; get username&quot;zhangsan&quot; 删除： del key12127.0.0.1:6379&gt; del age(integer) 1 哈希类型 hash 存储： hset key field value1234127.0.0.1:6379&gt; hset myhash username lisi(integer) 1127.0.0.1:6379&gt; hset myhash password 123(integer) 1 获取： hget key field：获取指定field的value hgetall key：获取所有的field和value 12345678910127.0.0.1:6379&gt; hget myhash username&quot;lisi&quot;-----------------------------------------------127.0.0.1:6379&gt; hgetall myhash1) &quot;username&quot;2) &quot;lisi&quot;3) &quot;password&quot;4) &quot;123&quot; 删除： hdel key field12127.0.0.1:6379&gt; hdel myhash username(integer) 1 列表类型 list 可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加： lpush key value: 将元素加入列表左表 rpush key value：将元素加入列表右边 123456127.0.0.1:6379&gt; lpush myList a(integer) 1127.0.0.1:6379&gt; lpush myList b(integer) 2127.0.0.1:6379&gt; rpush myList c(integer) 3 获取： lrange key start end ：范围获取1234127.0.0.1:6379&gt; lrange myList 0 -11) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot; 删除： lpop key： 删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 集合类型 set set类型不允许重复元素 存储：sadd key value 1234127.0.0.1:6379&gt; sadd myset a(integer) 1127.0.0.1:6379&gt; sadd myset a(integer) 0 获取：smembers key:获取set集合中所有元素 12127.0.0.1:6379&gt; smembers myset1) &quot;a&quot; 删除：srem key value:删除set集合中的某个元素 12127.0.0.1:6379&gt; srem myset a(integer) 1 有序集合类型 sortedset 不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 123456127.0.0.1:6379&gt; zadd mysort 60 zhangsan(integer) 1127.0.0.1:6379&gt; zadd mysort 50 lisi(integer) 1127.0.0.1:6379&gt; zadd mysort 80 wangwu(integer) 1 获取：zrange key start end [withscores] 123456789101112127.0.0.1:6379&gt; zrange mysort 0 -11) &quot;lisi&quot;2) &quot;zhangsan&quot;3) &quot;wangwu&quot;127.0.0.1:6379&gt; zrange mysort 0 -1 withscores1) &quot;zhangsan&quot;2) &quot;60&quot;3) &quot;wangwu&quot;4) &quot;80&quot;5) &quot;lisi&quot;6) &quot;500&quot; 删除：zrem key value 12127.0.0.1:6379&gt; zrem mysort lisi(integer) 1 通用命令 keys * : 查询所有的键 type key ： 获取键对应的value的类型 del key：删除指定的key value 持久化 redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制 RDB：默认方式，不需要进行配置，默认就使用这种机制 AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 RDB 在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windwos.conf文件 123456# after 900 sec (15 min) if at least 1 key changedsave 900 1# after 300 sec (5 min) if at least 10 keys changedsave 300 10# after 60 sec if at least 10000 keys changedsave 60 10000 重新启动redis服务器，并指定配置文件名称 1D:\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf AOF 编辑redis.windwos.conf文件 12345appendonly no（关闭aof） --&gt; appendonly yes （开启aof）# appendfsync always ： 每一次操作都进行持久化appendfsync everysec ： 每隔一秒进行一次持久化# appendfsync no ： 不进行持久化 Java客户端 Jedis 一款Java操作redis数据库的工具。 使用步骤 下载jedis的jar包 使用 123456//1. 获取连接Jedis jedis = new Jedis("localhost",6379);//2. 操作jedis.set("username","zhangsan");//3. 关闭连接jedis.close(); Jedis操作各种redis中的数据结构字符串类型String1234567891011121314 /** * 操作String的方法 * 1. public String set(String key, String value) * 2. public String get(String key) * 3. public Long del(String key) */@Testpublic void testString() &#123; Jedis jedis = new Jedis(); jedis.set("username", "zhangsan"); String username = jedis.get("username"); System.out.println("username = " + username); jedis.close();&#125; 哈希类型Hash Hash类型其实是以Map格式存储的（键值对） 123456789101112131415 /** * 操作Hash类型的方法 * 1. public Long hset(String key, String field, String value) * 2. public String hget(String key, String field) * 3. public Map&lt;String, String&gt; hgetAll(String key) * 4. public Long hdel(String key, String... fields) */@Testpublic void testHash() &#123; Jedis jedis = new Jedis(); jedis.hset("myHash", "username", "zhangsan"); String username = jedis.hget("myHash", "username"); System.out.println("username = " + username); jedis.close();&#125; 列表类型List LinkedList格式。支持重复元素 1234567891011121314151617 /** * 操作List的方法 * 1. public Long lpush(String key, String... strings) * 2. public String lpop(String key) * 3. public Long rpush(String key, String... strings) * 4. public String rpop(String key) * 5. public List&lt;String&gt; lrange(String key, long start, long end) */@Testpublic void testList() &#123; Jedis jedis = new Jedis(); jedis.lpush("myList", "hehe"); jedis.rpush("myList", "hello"); List&lt;String&gt; myList = jedis.lrange("myList", 0, -1); System.out.println("myList = " + myList); jedis.close();&#125; 集合类型Set 不允许重复元素 1234567891011121314 /** * 操作Set的方法 * 1. public Long sadd(String key, String... members) * 2. public Long srem(String key, String... members) * 3. public Set&lt;String&gt; smembers(String key) */@Testpublic void testSet() &#123; Jedis jedis = new Jedis(); jedis.sadd("mySet", "password", "hehe"); Set&lt;String&gt; mySet = jedis.smembers("mySet"); System.out.println("mySet = " + mySet); jedis.close();&#125; 有序集合类型SortedSet 不允许重复元素，且元素有序 1234567891011121314151617181920212223 /** * 操作SortedSet的方法 * 1. public Long zadd(String key, double score, String member) * 2. public Long zrem(String key, String... members) * 3. public Set&lt;String&gt; zrange(String key, long start, long end) * 4. public Set&lt;Tuple&gt; zrangeWithScores(String key, long start, long end) */@Testpublic void testSortedSet() &#123; Jedis jedis = new Jedis(); jedis.zadd("mySortedSet", 666, "hello world!"); Long zrem = jedis.zrem("mySortedSet", "hello world!"); System.out.println("zrem = " + zrem); Set&lt;String&gt; mySortedSet = jedis.zrange("mySortedSet", 0, -1); System.out.println("mySortedSet = " + mySortedSet); Set&lt;Tuple&gt; mySortedSetWithScores = jedis.zrangeWithScores("mySortedSet", 0, -1); for (Tuple set : mySortedSetWithScores) &#123; String element = set.getElement(); double score = set.getScore(); System.out.println(element + ":" + score); &#125; jedis.close();&#125; 通用的操作方法123456789101112131415161718 /** * 通用的操作方法 * 1. public Set&lt;String&gt; keys(String pattern) * 2. public String type(String key) * 3. public Long del(String key) */@Testpublic void testGeneric() &#123; Jedis jedis = new Jedis(); Set&lt;String&gt; keys = jedis.keys("*"); System.out.println("keys = " + keys); String myListType = jedis.type("myList"); System.out.println("myListType = " + myListType); //先添加一个属性username jedis.set("username", "hehe"); Long del = jedis.del("username"); System.out.println("del number = " + del);&#125; Jedis连接池使用步骤 导包 创建JedisPool连接池对象 调用方法 getResource()方法获取Jedis连接 12345678910111213141516//0.创建一个配置对象JedisPoolConfig config = new JedisPoolConfig();config.setMaxTotal(50);config.setMaxIdle(10);//1.创建Jedis连接池对象JedisPool jedisPool = new JedisPool(config,"localhost",6379);//2.获取连接Jedis jedis = jedisPool.getResource();//3. 使用jedis.set("hehe","heihei");//4. 关闭 归还到连接池中jedis.close(); 连接池工具类123456789101112131415161718192021222324252627282930313233343536373839404142public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty("host"),Integer.parseInt(pro.getProperty("port"))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;/** * 测试jedis连接池工具类 */@Testpublic void testMyJedisPoolUtils() &#123; Jedis jedis = JedisPoolUtils.getJedis(); Set&lt;String&gt; keys = jedis.keys("*"); System.out.println("keys = " + keys); jedis.close();&#125; 注意事项 使用redis缓存一些不经常发生变化的数据。 数据库的数据一旦发生改变，则需要更新缓存。 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入。 在service对应的增删改方法中，将redis数据删除。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery3.0]]></title>
    <url>%2Funcategorized%2F10_jQuery3-0%2F</url>
    <content type="text"><![CDATA[.imp{ color:red; } .lg{ font-size:25px; } JQuery基础 jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 使用步骤 下载JQuery 1234567891011121314151617目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。 jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 导入JQuery的js文件：导入min.js文件 使用 1234&lt;script&gt; var div1 = $("#div1"); alert(div1.html());&lt;/script&gt; JQuery对象和JavaScript对象区别与转换 JQuery对象在操作时，更加方便。 JQuery对象和js对象方法不通用的. 两者相互转换 12* JQ -- &gt; js : jq对象[索引] 或者 JQ对象.get(索引)* js -- &gt; JQ : $(js对象) 选择器 筛选具有相似特征的元素(标签) 基本操作学习 事件绑定 1234//1.获取b1按钮$("#b1").click(function()&#123; alert("abc");&#125;); 入口函数 123456789 $(function () &#123; &#125;);/*window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 */ 样式控制：css方法 12// $("#div1").css("background-color","red");$("#div1").css("backgroundColor","pink"); 分类基本选择器 标签选择器（元素选择器） 语法： $(“html标签名”) 获得所有匹配标签名称的元素 id选择器 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素 类选择器 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素 并集选择器 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素 层级选择器 后代选择器 语法： $(“A B “) 选择A元素内部的所有B元素 子选择器 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素 属性选择器 属性名称选择器 语法： $(“A[属性名]”) 包含指定属性的选择器 属性选择器 语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器 复合属性选择器 语法： $(“A[属性名=’值’] [ 属性名=’值’] …”) 包含多个属性条件的选择器 过滤选择器 首元素选择器 语法： :first 获得选择的元素中的第一个元素 尾元素选择器 语法： :last 获得选择的元素中的最后一个元素 非元素选择器 语法： :not(selector) 不包括指定内容的元素 偶数选择器 语法： :even 偶数，从 0 开始计数 奇数选择器 语法： :odd 奇数，从 0 开始计数 等于索引选择器 语法： :eq(index) 指定索引元素 大于索引选择器 语法： :gt(index) 大于指定索引元素 小于索引选择器 语法： :lt(index) 小于指定索引元素 标题选择器 语法： :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器 语法： :enabled 获得可用元素 不可用元素选择器 语法： :disabled 获得不可用元素 选中选择器 语法： :checked 获得单选/复选框选中的元素 选中选择器 语法： :selected 获得下拉框选中的元素 DOM操作内容操作123456789101. html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt;2. text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容3. val()： 获取/设置元素的value属性值 属性操作 通用属性操作 attr(): 获取/设置元素的属性 removeAttr():删除属性 prop():获取/设置元素的属性 removeProp():删除属性 attr和prop的区别？ 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素自定义的属性，则建议使用attr 对class属性操作 addClass():添加class属性值 removeClass():删除class属性值 toggleClass():切换class属性 toggleClass(“one”)：判断如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加 css()：修改元素的style样式 CRUD操作正向操作： append A.append(B) —&gt; A追加B,B默认A里面的最后面 prepend A.prepend(B) —&gt; A追加B,B默认A里面的最前面 after A.after(B) —&gt; A的后面添加一个B before A.before(B) —-&gt;A的前面添加一个B 反向操作（与正向操作类似）： appendTo prependTo insertAfter insertBefore 其他操作： empty —-&gt;清空所有的后代元素 remove—-&gt;删除自己 clone —–&gt;克隆一个对象 JQuery高级动画 三种方式显示和隐藏元素 默认方式 滑动方式 淡入淡出方式 默认方式 show([speed,[easing],[fn]]) 参数： speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000) easing：用来指定切换效果，默认是”swing”，可用参数”linear” swing：动画执行时效果是 先慢，中间快，最后又慢 linear：动画执行时速度是匀速的 fn：在动画完成时执行的函数，每个元素执行一次。 hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动方式 slideDown([speed],[easing],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出方式 fadeIn([speed],[easing],[fn]) fadeOut([speed],[easing],[fn]) fadeToggle([speed,[easing],[fn]]) 遍历方式JS的遍历方式 for(初始化值;循环结束条件;步长) JQ的遍历方式 jq对象.each(callback) 语法 jquery对象.each(function(index,element){}); index:就是元素在集合中的索引 element：就是集合中的每一个元素对象 this：集合中的每一个元素对象 回调函数的返回值 true:如果当前function返回为false，则结束循环(break)。 false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) $.each(object, [callback]) for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 事件绑定jquery标准的绑定方式 jq对象.事件方法(回调函数)； 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit();//让表单提交 on绑定事件/off解除绑定 jq对象.on(“事件名称”,回调函数) jq对象.off(“事件名称”) 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 事件切换：toggle jq对象.toggle(fn1,fn2…) 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2….. 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 1&lt;script src="../js/jquery-migrate-1.0.0.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; 插件 增强JQuery的功能 实现方式 $.fn.extend(object) 增强通过Jquery获取的对象的功能 $(“#id”) $.extend(object) 增强JQeury对象自身的功能 $/jQuery]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>JQuery</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStrap]]></title>
    <url>%2FFront%2F07_BootStrap%2F</url>
    <content type="text"><![CDATA[概念Bootstrap，一个前端开发的框架，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。 框架一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。 好处 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 响应式布局。 同一套页面可以兼容不同分辨率的设备。 快速入门 下载Bootstrap 在项目中将这三个文件夹复制 创建html页面，引入必要的资源文件 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- ie的适配 --&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Hello world&lt;/title&gt; &lt;!-- 新 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt; &lt;!-- 可选的Bootstrap主题文件（一般不用引入） --&gt; &lt;link rel="stylesheet" href="css/bootstrap-theme.min.css"&gt; &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt; &lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 响应式布局概念同一套页面可以兼容不同分辨率的设备。 实现依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子 步骤 定义容器。相当于之前的table、div 容器分类： container：两边留白 container-fluid：每一种设备都是100%宽度 定义行。相当于之前的tr 样式：row 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目 设备代号： xs：超小屏幕 手机 (&lt;768px)：col-xs-12 sm：小屏幕 平板 (≥768px) md：中等屏幕 桌面显示器 (≥992px) lg：大屏幕 大桌面显示器 (≥1200px) 注意： 一行中如果格子数目超过12，则超出部分自动换行。 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 补充： visible-xs/sm/md/lg：在某个范围内显示（可以多选） hidden-xs/sm/md/lg：在某个范围内隐藏（可以多选） CSS样式和JS插件全局CSS样式 按钮：class=”btn btn-default” 图片： class=”img-responsive”：图片在任意尺寸都占100% 图片形状 &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形 &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形 &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框 表格： table table-bordered table-hover 表单： 给表单项添加：class=”form-control” 组件 导航条 分页条 插件 轮播图 注意： 1234567891011121314轮播图的大小不一，就会造成小的图片不能居中，使用.center-block后发现却只能水平居中1.比较好的办法是之一：.carousel-inner img &#123;width:100%;&#125;问题是：这样设置后图片显示的大小还是不一样，但是至少不会有多余的空白，还有就是小的图片可能会比较模糊。2.可能最好的就是规定图片的大小和比例3.压缩图片(还没尝试过)]]></content>
      <categories>
        <category>Front</category>
      </categories>
      <tags>
        <tag>BootStrap</tag>
        <tag>Front</tag>
        <tag>Front Frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2FJavaScript%2F06_JavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript基础 概念：一门客户端脚本语言 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行了 功能：可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 JavaScript发展史 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C - - ，后来更名为：ScriptEase 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 1996年，微软抄袭JavaScript开发出JScript语言 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM) ECMAScript：客户端脚本语言的标准基本语法 与html结合方式 内部JS： 定义&lt;script&gt;，标签体内容就是js代码 外部JS： 定义&lt;script&gt;，通过src属性引入外部的js文件 注意： &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。 &lt;script&gt;可以定义多个。 注释 单行注释：//注释内容 多行注释：/*注释内容*/ JavaScript中的特殊语法 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 变量的定义使用var关键字，也可以不使用 用： 定义的变量是局部变量 不用：定义的变量是全局变量(不建议) 数据类型 原始数据类型(基本数据类型) number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型) string：字符串。 字符串 “abc” “a” ‘abc’ boolean: true和false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined 引用数据类型：对象 变量 变量：一小块存储数据的内存空间 Java语言是强类型语言，而JavaScript是弱类型语言。 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 语法：var 变量名 = 初始化值; typeof运算符：获取变量的类型。 - 注：null运算后得到的是object 运算符 一元运算符：只有一个运算数的运算符++，– ， +(正号)++ –: 自增(自减)++(–) 在前，先自增(自减)，再运算++(–) 在后，先运算，再自增(自减) +(-)：正负号 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换 其他类型转number： string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） boolean转number：true转为1，false转为0 null转number：0 undefined转number：NaN 运算符算数运算符+ - * / % ... 赋值运算符= += -+.... 比较运算符&gt; &lt; &gt;= &lt;= == ===(全等于)比较方式： 类型相同：直接比较 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 类型不同：先进行类型转换，再比较===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false 逻辑运算符​ &amp;&amp; || !​ 其他类型转boolean： number：0或NaN为假，其他为真 string：除了空字符串(“”)，其他都是true null&amp;undefined:都是false对象：所有对象都为true 三元运算符​ 语法：表达式? 值1:值2;​ 判断表达式的值，如果是true则取值1，如果是false则取值2； 123456789//测试代码：var a = 3;var b = 4;var c = a &gt; b ? 1:0;document.write(c);//运行结果：0 流程控制语句 if…else… switch while do…while for 总体用法与Java无太大差异。特别注意一点的是： JS中switch可以接受的数据类型和case中的数据类型可以是任意类型。 基本对象Function：函数(方法)对象 定义格式 定义方式1： 123456789var 方法名 = new Function(参数列表,方法体); //不推荐;//例如：var fun1 = new Function(“a”,”b”,”alert(a + b)”);//调用：fun1(3,4);//解析: 会将3赋值给a,4赋值给b, 最后将a + b的结果弹出 定义方式2： 12345678910111213function 方法名(参数列表)&#123; 方法体;&#125;//例如：function fun1(a, b)&#123; return a + b;&#125;//调用：var result = fun1(3,4);//解析: 会将3赋值给a,4赋值给b, 最后将a + b的结果返回 定义方式3： 12345678910111213var 方法名 = function (参数列表)&#123; 方法体;&#125; //例如:var fun1 = function(a , b)&#123; return a + b;&#125; //调用:var result = fun1(3,4);//解析: 会将3赋值给a,4赋值给b, 最后将a + b的结果返回 调用var 返回值 = 方法名(实际的参数); 属性length —&gt;决定了形参的个数,一般用的比较少 特点 形式的数据类型可以省略,返回值类型也可以省略 方法可以重复,后面的方法会将前面的方法覆盖 方法的调用只和方法名有关,和参数没有关系 里面有一个内置的对象 arguments ,这个对象是一个数组,里面存储所有的调用方法时,传入的实际参数 Array：数组对象 定义格式 定义方式1： 1var 数组名 =new Array (元素1,元素2,....); 定义方式2： 1var 数组名 =new Array (数组长度); 定义方式3： 1var 数组名 = [元素1,元素2,...]; 属性 length：数组的长度 特点 长度可以变,数据类型可以变 方法 pop() —&gt; 删除并返回数组的最后一个元素 push() —&gt; 向数组的末尾添加一个或更多元素，并返回新的长度。其实可以被 “arr[arr.length] = 值” 替代 join(参数) —&gt; 将数组的元素按照指定的”拼接符”拼接例如: 12345var arr = [1,2,3];arr.join("#"); // ----&gt; 1#2#3//访问方式:数组名[索引] shift() —&gt; 删除并返回数组的第一个元素 unshift() —&gt; 向数组的开头添加一个或更多元素，并返回新的长度 Boolean可以理解为boolean的包装类型，不做过多阐述。 Date：日期对象 创建 1var date = new Date(); 方法 toLocaleString() —-&gt; 将日期变成当地能看懂的字符串(其实根据电脑的语言) getTime() —-&gt; 返回 1970 年 1 月 1 日上午 8 时 0 分 0 秒至今的毫秒数。不会重复，解决缓冲问题 Math：数学对象 定义方式特点：Math对象不用创建，直接使用。 Math.方法名(); 方法 random():返回 0 ~ 1 之间的随机数。 含0不含1 ceil(x)：对数进行上舍入。 floor(x)：对数进行下舍入。 round(x)：把数四舍五入为最接近的整数。 属性 PI Number可以理解为boolean的包装类型，不做过多阐述。 String可以理解为boolean的包装类型，与JavaSE中的String类型用法类似。不做过多阐述。 RegExp：正则表达式对象 作用：首先正则在多种语言中都是有效的, 他的作用就是规定字符串的书写规则。 定义方式： 定义方式1（推荐使用）： 1var reg = /正则表达式/; 定义方式2： 1var reg = new RegExp("正则表达式"); 定义方式3： 1234567var RegExp = new RegExp(pattern, attributes);//参数pattern：指定正则表达式的规则或者表示正则表达式模式的字符串//参数attributes：可选参数，表示匹配模式的修饰符。//参数attributes的3个可选参数：// i：执行对大小写不敏感匹配;// g：执行全局匹配（查找所有匹配项而非找到第一个匹配项后停止）;// m：执行多行匹配（若不设置该属性，^（$）只与整个被搜索字符串的开始（结尾）位置开始匹配；若设置该属性，^（$）还可以与被搜索字符串的“\r”或“\n”之后位置开始匹配）。 &lt;p style = &quot;color:red; font-size:25px&quot;&gt;定义方式3的参数详解：&lt;/p&gt; - i：执行对大小写不敏感匹配 1234567&lt;script text="text/javascript"&gt; var txt = 'Hello World!' var reg = new RegExp('hello', 'i'); if(reg.test(txt)) &#123; console.log(txt.match(reg)); &#125;&lt;/script&gt; - g：执行全局匹配（查找所有匹配项而非找到第一个匹配项后停止） 123456789&lt;script text="text/javascript"&gt; var txt = 'This is just a test.'; var reg = new RegExp('is', 'g');//区分大小写 var reg01 = new RegExp('is', 'gi');//不区分大小写 if(reg.test(txt)) &#123; console.log(txt.match(reg));//["is", "is"] console.log(txt.match(reg).length);//2 &#125;&lt;/script&gt; - m：执行多行匹配（若不设置该属性，^（$）只与整个被搜索字符串的开始（结尾）位置开始匹配；若设置该属性，^（$）还可以与被搜索字符串的“\r”或“\n”之后位置开始匹配） 1234567891011121314151617181920&lt;script type="text/javascript"&gt; //以下代码不能够匹配字符串"an"，尽管"an"后面已经换行了，但"an"并不是字符串行的结尾。 var txt1 = 'This is an\n apple'; var reg1 = /an$/; console.log(txt1.match(reg1));//null //以下代码能够匹配到字符串"an" var txt2 = 'This is an\n apple'; var reg2 = /an$/m; console.log(txt2.match(reg2));//["an", index: 8, input: "This is an↵ apple"] //以下是多行匹配开头示例 var txt3 = 'This is an\n apple'; var reg3 = /^\sapp/; console.log(txt3.match(reg3));//null var txt4 = 'This is an\n apple'; var reg4 = /^\sapp/m;// /^ app/m console.log(txt4.match(reg4));//[" app", index: 11, input: "This is an↵ apple"]&lt;/script&gt; 方法： test(字符串)：判断这个字符串是否符合正则表达式例如： 1234var regx = \^\d&#123;8,12&#125;$\;var qq = “123456789”;var result = regx.test(qq);var result = qq.match(regx); //了解, 这个方式,是通过字符串的match方法来去判断是否符合某个正则 语法： 方括号：限定单个字符例如： 12345[a] //要求你的字符串只能是一个,而且只能是a [abc] //要求你的字符串只能是一个,而且只能是abc中间的其中一个\w //单词字符[a-zA-Z0-9_]\d //[0-9]. //代表匹配所有字符 量词： 1234567? //0或者1次* //0或多次+ //1次或多次 //什么都不写: 有且只能一次&#123;m,n&#125; //可以出现m到n次,包含m和n&#123;m,&#125; //至少m次&#123;n&#125; //必须出现n次 注意： 123456789101112^ //以什么开始$ //这个是以什么结尾 //如果在""之中, 反斜杠要成对出现, 如果在在\\里面, 反斜杠不能成对出现/* 一般来说，正则中的^表示开头，$表示结束 比如： ^\d+$ 匹配的字符串只能是数字，因为他开头结尾都是数字，那么他就只能匹配： 1 、 12、 123....等等 \d+$ 这个就匹配结尾是数字：比如 ：abc123 ^\d+ 就匹配开头是数字，比如：123abc*/ 全局函数 方法名 描述 decodeURI() 解码某个编码的 URI。 decodeURIComponent() 解码一个编码的 URI 组件。 encodeURI() 把字符串编码为 URI。 encodeURIComponent() 把字符串编码为 URI 组件。 parseInt() 将字符串变成数字, 会将前面是数字的部分转成数字 eval() 可以将字符串变成js对象或者js代码来去执行 isNaN() 判断一个值是否是NaN。 值得一提的是： NaN六亲不认，连自己都不认。NaN参与的==比较全部问false URL编码：会将中文按照某个编码的格式转化成十六进制，每一个字节使用一个%隔开。 JavaScript高级BOM概念BOM（Browser Object Module），浏览器对象模型。将浏览器的各个组成部分封装成对象。 组成 Window：窗口对象 Navigator：浏览器对象 Screen：显示器屏幕对象 History：历史记录对象 Location：地址栏对象 DOM初步 获取元素 12var element = document.getElementById("要从HTML页面中获取的对象id");var arr = document.getElementsByTagName("要从HTML页面中获取的对象标签名"); 操作 12345671. 修改属性值： 1. 明确获取的对象是哪一个？ 2. 查看API文档，找其中有哪些属性可以设置2. 修改标签体内容： * 属性：innerHTML 1. 获取元素对象 2. 使用innerHTML属性修改标签体内容 属性 1234//查看该元素的文档,看支持的属性//格式: 对象.属性名 = 属性值; div.style.background = “red”; 内容 12//格式: 对象.innerHTML = "内容"; //覆盖的操作,如果不想覆盖就用+= 案例（DOM的简单操作） 12345678910111213141516171819202122232425262728293031323334353637题目&lt;!-- 开场就一个空的div 通过js来控制div的宽度和高度是50px,边框设置 1px solid red 通过js来控制div的内容为"我很帅"或者"我很美"--&gt;代码:&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;!-- 开场就一个空的div 通过js来控制div的宽度和高度是50px,边框设置 1px solid red 通过js来控制div的内容为"我很帅"或者"我很美"--&gt; &lt;body&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;script&gt; //获取div元素对象 var div1 = document.getElementById("div1"); //给div1的属性设置值 div1.style.width = "50px"; div1.style.height = "50px"; div1.style.border = "1px solid red"; //设置div1中的内容 div1.innerHTML = "我好帅";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件的简单学习 事件：某些组件被执行了某些操作后，触发某些代码的执行。 如何绑定事件： 直接在html标签上，指定事件的属性(操作)，属性值就是js代码事件：onclick— 单击事件 通过js获取元素对象，指定事件属性，设置一个函数 案例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041* 案例1：电灯开关&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;电灯开关&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img id="light" src="img/off.gif"&gt; &lt;script&gt; /* 分析： 1.获取图片对象 2.绑定单击事件 3.每次点击切换图片 * 规则： * 如果灯是开的 on,切换图片为 off * 如果灯是关的 off,切换图片为 on * 使用标记flag来完成 */ //1.获取图片对象 var light = document.getElementById("light"); var flag = false;//代表灯是灭的。 off图片 //2.绑定单击事件 light.onclick = function()&#123; if(flag)&#123;//判断如果灯是开的，则灭掉 light.src = "img/off.gif"; flag = false; &#125;else&#123; //如果灯是灭的，则打开 light.src = "img/on.gif"; flag = true; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Window：窗口对象 创建 Window对象不需要创建可以直接使用 window使用。 window.方法名(); window引用可以省略。 方法名(); 方法 与弹出框有关的方法： alert()：显示带有一段消息和一个确认按钮的警告框。 confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框。 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt()：显示可提示用户输入的对话框。返回值：获取用户输入的值 与打开关闭有关的方法： close()：关闭浏览器窗口。 谁调用我 ，我关谁 open()：打开一个新的浏览器窗口 返回新的Window对象 与定时器有关的方法： setTimeout()：在指定的毫秒数后调用函数或计算表达式。 参数： js代码或者方法对象 毫秒值 返回值：唯一标识，用于取消定时器 clearTimeout()：取消由 setTimeout() 方法设置的 timeout。 setInterval()：按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval()：取消由 setInterval() 设置的 timeout。 属性 获取其他BOM对象： history location navigator screen 获取DOM对象 document Location：地址栏对象 创建（获取）： window.location location 方法： reload()：重新加载当前文档。刷新 search()：获取地址栏中?及后面的参数字符串。 属性： href：设置或返回完整的 URL。 History：历史记录对象 创建（获取）： window.history history 方法： back()：加载 history 列表中的前一个 URL。 forward()：加载 history 列表中的下一个 URL。 go(参数)：加载 history 列表中的某个具体页面。 参数： 正数：前进几个历史记录 负数：后退几个历史记录 属性： length：返回当前窗口历史列表中的 URL 数量。 Screen &amp; Navigator一般用不到，暂不做阐述。 DOMDOM：， 概念DOM（Document Object Module），文档对象模型。将浏览器的各个组成部分封装成对象。 组成 核心DOM：针对任何结构化文档的标准模型 Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment:注释对象 Node：节点对象，其他5个的父对象 HTML DOM：针对 HTML 文档的标准模型 XML DOM：针对 XML 文档的标准模型 核心DOM模型Document：文档对象 获取/创建 在HTML DOM模型中可以使用window对象来获取 window.document document 方法 获取Element对象： getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() 属性 Element：元素对象 获取/创建 通过document来获取和创建 方法 removeAttribute()：删除属性 setAttribute()：设置属性 Node：节点对象 其他5个的父对象 特点：所有DOM对象都可以被认为是一个节点 方法：CRUD DOM树 appendChild()：向节点的子节点列表的结尾添加新的子节点。 removeChild()：删除（并返回）当前节点的指定子节点。 replaceChild()：用新节点替换一个子节点。 值得注意的是：方法中的参数，均为节点对象。 属性：parentNode 返回节点的父节点。 HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 使用元素的style属性来设置 12345678//如：//修改样式方式1div1.style.border = "1px solid red";div1.style.width = "200px";//font-size --&gt; fontSizediv1.style.fontSize = "20px"; 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。 事件监听机制 概念：某些组件被执行了某些操作后，触发某些代码的执行。 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 事件源：组件。如： 按钮 文本输入框… 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 举例： 123456/* 事件：踹了一脚 事件源：电动车 监听器：电动车的报警器 将监听器绑定在事件源（注册监听）：厂家在出厂的时候会将“电动车的报警器”安装到“电动车”上*/ 常见的事件： 点击事件 onclick：单击事件 ondblclick：双击事件 焦点事件 onblur：失去焦点 onfocus：元素获得焦点。 加载事件 onload：一张页面或一幅图像完成加载。 鼠标事件 onmousedown：鼠标按钮被按下。 onmouseup：鼠标按键被松开。 onmousemove：鼠标被移动。 onmouseover：鼠标移到某元素之上。 onmouseout：鼠标从某元素移开。 键盘事件 onkeydown：某个键盘按键被按下。 onkeyup：某个键盘按键被松开。 onkeypress：某个键盘按键被按下并松开。 选择和改变 onchange：域的内容被改变。 onselect：文本被选中。 表单事件 onsubmit：确认按钮被点击。 onreset：重置按钮被点击。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2FDatabase%2F03_MySQL%2F</url>
    <content type="text"><![CDATA[数据库的基本概念 数据库的英文单词： DataBase 简称 ： DB 什么数据库？ 用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 – SQL 常见的关系型数据库软件 Oracle MySQL SQL Server DB2 MySQL数据库软件 安装 如果勾选Enable root access from remote machines选项，则可以使用root用户进行远程访问本MySQL服务器。（或者以后在mysql数据库下的user表中，自己手动添加一个主机名为’%’的root用户，也可以访问本机MySQL服务器。） 卸载 （1）去mysql的安装目录找到my.ini文件，复制 datadir=”C:/ProgramData/MySQL/MySQL Server 5.5/Data/“ （2）在控制面板卸载MySQL （3）删除C:/ProgramData目录下的MySQL文件夹。 配置 MySQL服务启动 cmd–&gt; services.msc 打开服务的窗口 使用管理员打开cmd net start mysql : 启动mysql的服务net stop mysql:关闭mysql服务 MySQL登录 mysql -uroot -p密码 mysql -h连接目标ip -uroot -p连接目标的密码 mysql –host=连接目标ip –user=root –password=连接目标的密码 MySQL退出 exit quit MySQL目录结构 MySQL安装目录：basedir=”D:/develop/MySQL/“ 配置文件 my.ini MySQL数据目录：datadir=”C:/ProgramData/MySQL/MySQL Server 5.5/Data/“ 在数据库中，可以将数据库想象成一个文件夹，表就是一个文件，数据则是该文件中的数据。 数据库 → 文件夹 表 → 文件 数据 → 数据 SQL 什么是SQL？Structured Query Language：结构化查询语言其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL：操作数据库、表DDL：Data Definition Language 数据定义语言 使用数据库 查询当前正在使用的数据库名称 select database(); 使用数据库 use 数据库名称; 操作数据库：CRUD C(Create):创建 创建数据库： create database 数据库名称; 创建数据库，判断不存在，再创建： create database if not exists 数据库名称; 创建数据库，并指定字符集 create database 数据库名称 character set 字符集名; 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk create database if not exists db4 character set gbk; R(Retrieve)：查询 查询所有数据库的名称: show databases; 查询某个数据库的字符集:查询某个数据库的创建语句 show create database 数据库名称; U(Update):修改 修改数据库的字符集 alter database 数据库名称 character set 字符集名称; D(Delete):删除 删除数据库 drop database 数据库名称; 判断数据库存在，存在再删除 drop database if exists 数据库名称; 操作表：CRUD C(Create):创建 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); 注意：最后一列，不需要加逗号（,） 数据库类型： int：整数类型 age int, double:小数类型 score double(5,2) date:日期，只包含年月日，yyyy-MM-dd datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp:时间戳类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar：字符串 name varchar(20):姓名最大20个字符 zhangsan 8个字符 张三 2个字符 创建表 ​ create table student(​ id int,​ name varchar(32),​ age int ,​ score double(4,1),​ birthday date,​ insert_time timestamp​ ); 复制表： create table 表名 like 被复制的表名; R(Retrieve)：查询 查询某个数据库中所有的表名称 show tables; 查询表结构 desc 表名; U(Update):修改 修改表名 alter table 表名 rename to 新的表名; rename table 表名 to 新的表名; 修改表的字符集 alter table 表名 character set 字符集名称; 添加一列 alter table 表名 add 列名 数据类型; 修改列名称 类型 alter table 表名 change 列名 新列名 新数据类型; alter table 表名 modify 列名 新数据类型; 删除列 alter table 表名 drop 列名; D(Delete):删除 drop table 表名; drop table if exists 表名 ; 客户端图形化工具：SQLYog DML：增删改表中数据DML：Data Manipulation Language 数据操作语言 添加数据 语法： insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n); 注意： 列名和值要一一对应。 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,…值n); 除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据 语法： delete from 表名 [where 条件] 注意： 如果不加条 件，则删除表中所有记录。 如果要删除所有记录 delete from 表名; – 不推荐使用。有多少条记录就会执行多少次删除操作 TRUNCATE TABLE 表名; – 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 修改数据 语法： update 表名 set 列名1 = 值1, 列名2 = 值2,… [where 条件]; 注意： 如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录（单表查询）DQL：Data QueryLanguage 数据查询语言 语法select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序列名 [ASC | DESC] limit 起始索引,长度; 基础查询 多个字段的查询 select 字段名1，字段名2… from 表名； 注意： 如果查询所有字段，则可以使用*来替代字段列表。 去除重复： distinct 计算列 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1：哪个字段需要判断是否为null 如果该字段为null后的替换值。 起别名： as：as也可以省略 条件查询 where子句后跟条件 运算符 >、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; BETWEEN…AND IN( 集合) LIKE：模糊查询 占位符： _:单个任意字符 %：多个任意字符 IS NULL and 或 &amp;&amp; * or 或 || * not 或 ! 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE '马%'; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE "_化%"; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE '___'; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE '%德%'; 排序查询 语法： order by 子句 排序方式： ASC：升序 DESC：降序 注意： 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 聚合函数将一列数据作为一个整体，进行纵向的计算。 count：计算个数 一般选择非空的列：主键 count(*) max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 注意：聚合函数的计算，排除null值。 解决方案： 选择不包含非空的列进行计算 IFNULL函数 分组查询 语法：group by 分组字段; 注意： 分组之后查询的字段：分组字段、聚合函数 where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 案例： 12345678910111213-- 按照性别分组。分别查询男、女同学的平均分SELECT sex , AVG(math) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 分页查询 语法：limit 起始索引,长度; 公式：起始索引 = （当前的页码 - 1） * 每页显示的条数 limit是一个MySQL“方言” 注意点： limit a,b 在sql语句最后，表示从索引为a的记录开始查询，最多查询b条记录，a可以省略，如果不写，则默认从索引为0的记录开始查询 约束 概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。 分类： 主键约束：primary key 非空约束：not null 唯一约束：unique 外键约束：foreign key 非空约束非空约束：not null，某一列的值不能为null 创建表时添加约束 1234CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空); 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); 默认约束default 创建表时添加约束 123456create table stu ( id INT; name VARCHAR(32) DEFAULT '张三');INSERT INTO stu VALUES(1); -- 不会报错，name有默认值'张三' 删除默认约束 ALTER TABLE stu MODIFY name VARCHAR(32); 创建表之后添加默认约束 ALTER TABLE stu MODIFY name VARCHAR(32) DEFAULT &#39;李四&#39;; 唯一约束唯一约束：unique，某一列的值不能重复 注意： 唯一约束可以有NULL值，而且可以有多个，因为NULL没有数据，不存在重复的问题 在创建表时，添加唯一约束 1234CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 手机号); 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 在表创建完后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; 主键约束主键约束：primary key。 注意： 含义：非空且唯一 一张表只能有一个字段为主键 主键就是表中记录的唯一标识 在创建表时，添加主键约束 1234create table stu( id int primary key,-- 给id添加主键约束 name varchar(20)); 删除主键 12-- 错误 alter table stu modify id int ;ALTER TABLE stu DROP PRIMARY KEY; 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 自动增长： 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 在创建表时，添加主键约束，并且完成主键自增长 1234create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20)); 删除自动增长 ALTER TABLE stu MODIFY id INT; 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 外键约束外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 在创建表时，可以添加外键 12345create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)); 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 级联操作 添加级联操作 语法： 123456ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE; 分类： 级联更新：ON UPDATE CASCADE 级联删除：ON DELETE CASCADE 数据库的设计多表之间的关系 分类 一对一： 如：人和身份证 分析：一个人只有一个身份证，一个身份证只能对应一个人 一对多（多对一）： 如：部门和员工 分析：一个部门有多个员工，一个员工只能对应一个部门 多对多： 如：学生和课程 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 实现关系 一对多(多对一)： 如：部门和员工 实现方式：在多的一方建立外键，指向一的一方的主键。 多对多： 如：学生和课程 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 一对一： 如：人和身份证 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 数据库设计的范式（重点） 概念：设计数据库时，需要遵循的一些规范。 要遵循后边的范式要求，必须先遵循前边的所有范式要求。 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 分类 第一范式（1NF）：每一列都是不可分割的原子数据项 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） 几个概念： 1、函数依赖：A–&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号–&gt;姓名。 （学号，课程名称） –&gt; 分数 2、完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） –&gt; 分数 3、部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） – &gt; 姓名 4、传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号–&gt;系名，系名–&gt;系主任 5、码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） 主属性：码属性组中的所有属性 非主属性：除过码属性组的属性 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原 命令行方式 语法： 备份：mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 还原： 登录数据库 创建数据库 使用数据库 执行文件。source文件路径 图形化工具 DQL：查询表中的记录（多表查询）【重点】笛卡尔积有两个集合A,B .取这两个集合的所有组成情况。 要完成多表查询，需要消除无用的数据 内连接查询使用内连接查询时，要明确以下几点： 从哪些表中查询数据 条件是什么 查询哪些字段 隐式内连接使用where条件消除无用数据 例子： 12345678910111213141516-- 查询所有员工信息和对应的部门信息SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;-- 查询员工表的名称，性别。部门表的名称SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称FROM emp t1, dept t2WHERE t1.`dept_id` = t2.`id`; 显式内连接语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 例如： 12SELECT * FROM emp INNER JOIN dept ON emp.dept_id = dept.id; SELECT * FROM emp JOIN dept ON emp.dept_id = dept.id; 外连接查询左外连接 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； 查询的是左表所有数据以及其交集部分。 例子： 12-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 右外连接 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； 查询的是右表所有数据以及其交集部分。 例子： 1SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 全外连接MySQL不支持full join，Oracle和SQLServer才支持。 语法： 12345SELECT o.Id_o,o.orderNo, p.Id_P,p.name,p.Address,p.CityFROM person pfull join oders o ON o.Id_P = p.Id_P; MySQL要达到全连接的效果，必须使用left join + union + right join 的方式实现，如下： 123SELECT * FROM persons p left join orders o on p.Id_P = o.Id_PunionSELECT * FROM persons p right join orders o ON p.Id_P = o.Id_P; 全连接，满足条件的数据就连接，不满足条件的数据会保留（对两张表中的所有数据都不过滤，只起到了对两张表的笛卡尔积去除重复的作用） 子查询 概念：查询中嵌套查询，称嵌套查询为子查询。 123456789-- 查询工资最高的员工信息-- 1 查询最高的工资是多少 9000SELECT MAX(salary) FROM emp;-- 2 查询员工信息，并且工资等于9000的SELECT * FROM emp WHERE emp.`salary` = 9000;-- 一条sql就完成这个操作。子查询SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); 子查询不同情况 子查询的结果是单行单列的： 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = 12-- 查询员工工资小于平均工资的人SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 子查询的结果是多行单列的： 子查询可以作为条件，使用运算符in来判断 12345-- 查询'财务部'和'市场部'所有的员工信息SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部';SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;-- 子查询SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部'); 子查询的结果是多行多列的： 子查询可以作为一张虚拟表参与查询 1234567-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息-- 子查询SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; '2011-11-11') t2WHERE t1.id = t2.dept_id; -- 普通内连接SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; '2011-11-11' 事务 概念：Transaction，相当于是一个容器（盒子），可以将一个操作的多个步骤（SQL代码）装起来之后，形成了一个不可分割的最小整体（原子性），这个操作整体要么都成功，要么都失败。 使用场景：例如转账操作。 事务的三个操作： 开启事务 start transaction; 回滚：如果事务中至少有一个操作失败，就可以回滚 rollback; 提交事务：如果事务中的多个操作全部成功，就可以提交事务 commit; 事务的提交方式 自动提交 MySQL默认就是自动提交，执行一条DML语句就自动提交一次。 查询默认的提交方式： select @@autocommit; -- 1：自动提交 0：手动提交 修改默认的提交方式： set @@autocommit = 0; -- 修改默认提交方式为手动提交 手动提交 如果自己开启了事务，被事务管理的sql执行完之后，需要手动提交 123start transaction;...commit; 事务的四大特征 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或者回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间，相互独立。 一致性：事务操作前后，数据总量不变。 事务的隔离级别 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 存在问题： 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别： read uncommitted：读未提交 产生的问题：脏读、不可重复读、幻读 read committed：读已提交 （Oracle默认级别） 产生的问题：不可重复读、幻读 repeatable read：可重复读 （MySQL默认级别） 产生的问题：幻读 serializable：串行化 可以解决所有的问题 - 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 - 数据库查询隔离级别：`select @@tx_isolation;` - 数据库设置隔离级别：`set global transaction isolation level 级别字符串;` 演示： 12345set global transaction isolation level read uncommitted;start transaction;-- 转账操作update account set balance = balance - 500 where id = 1;update account set balance = balance + 500 where id = 2; DCL：访问控制 对数据库用户的增删改查 添加用户 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;; 删除用户 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;; 修改用户密码 方式1：切到mysql数据库，然后使用普通的update语句修改。 update user set password = password(&#39;新密码&#39;) where user = &#39;用户名&#39;; 方式2：set password for &#39;用户名&#39;@&#39;主机名&#39; = password(&#39;新密码&#39;); mysql中忘记了root用户的密码？ 1234567891011找回密码步骤：1、cmd -- &gt; net stop mysql 停止mysql服务 tips：需要管理员运行该cmd2、使用无验证方式启动mysql服务： mysqld --skip-grant-tables3、打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功4、use mysql;5、update user set password = password('你的新密码') where user = 'root';6、关闭两个窗口7、打开任务管理器，手动结束mysqld.exe 的进程8、启动mysql服务9、使用新密码登录。 查询用户 123456-- 1. 切换到mysql数据库USE mysql;-- 2. 查询user表SELECT * FROM USER;tips：通配符 % 表示可以在任意主机使用用户登录数据库 对数据库用户的权限管理 查询用户现有的权限 1234-- 查询权限SHOW GRANTS FOR '用户名'@'主机名';-- 例子SHOW GRANTS FOR 'lisi'@'%'; 为用户授予权限 1234-- 授予权限grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';-- 给张三用户授予所有权限，在任意数据库任意表上GRANT ALL ON *.* TO 'zhangsan'@'localhost'; 撤销用户权限 123-- 撤销权限：revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%';]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>-MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE Error Log]]></title>
    <url>%2FJava%2F02_JavaSE-Error-Log%2F</url>
    <content type="text"><![CDATA[Java中protected方法访问权限的问题在cn.skywalker.test05包下的Student类： 123456789101112package cn.skywalker.test05;/** * @author SkyWalker * @create 2019 - 06 - 29 - 19:40 */public class Student &#123; protected void display()&#123; System.out.println("display....."); &#125;&#125; 在cn.skywalker.test06包下的Test类： 12345678910111213141516171819package cn.skywalker.test06;import cn.skywalker.test05.Student;/** * @author SkyWalker * @create 2019 - 06 - 29 - 20:13 */public class Test extends Student&#123; public static void main(String[] args) &#123; Student student = new Student();// student.display(); //在不同包实例化Student类对象，该对象对Student类中声明的protected方法的调用不属于本类调用 Test t = new Test(); t.display(); &#125;&#125; 这里我用cn.skywalker.test06包下的Test类继承了cn.skywalker.test05包下的Student类，但是在Test类中的main()函数中实例化了一个Student对象，该对象却无法调用Student类中使用protected修饰的方法。 这里再给出《java in a nutshell》中的一段话： protected access requires a little more elaboration. Suppose class A declares a protected field x and is extended by a class B, which is defined in a different package (this last point is important). Class B inherits the protected field x, and its code can access that field in the current instance of B or in any other instances of B that the code can refer to. This does not mean, however, that the code of class B can start reading the protected fields of arbitrary instances of A! If an object is an instance of A but is not an instance of B, its fields are obviously not inherited by B, and the code of class B cannot read them. 翻译：protected访问是需要一些准备的。假如类A定义了一个protected的属性x，并且被定义在不同包中的类B扩展了类A。A和B不再同一个包内这一点非常重要。从而，B继承了A的protected属性x，而且在当前B 的实例中这个属性是能够被访问的又或者其他代码中涉及到访问这个属性的B的实例中也是可以访问这个属性的。然而，这并不表示B 的代码可以任意访问A的实例中protected修饰的属性！如果一个对象是A而不是B的实例，显然B是没有继承该对象的属性的，从而B的代码无法访问它们。 方法的访问控制： public protected default private 同类 ✔ ✔ ✔ ✔ 同包 ✔ ✔ ✔ 子类（不同包） ✔ ✔ 不同包中无继承关系的类 ✔ 使用同名局部变量的问题话不多说，直接上代码： 12345678910111213141516171819public class Test &#123; public int age = 5; //成员变量age，默认初始化值为5 public void setAge(int age)&#123; //成员方法，有一个局部变量形参age age = age; &#125; public int getAge()&#123; //成员方法，返回成员变量age的值 return this.age; &#125; public static void main(String[] args)&#123; //主函数 //创建对象，进行测试 Test t = new Test(); t.setAge(10); System.out.println(t.getAge()); //运行结果为5 &#125;&#125; 很明显，我们能看到在Test类中的setAge(int age)方法中，没有使用this关键字对成员变量age进行赋值。而且从运行结果来看，不难发现，在setAge(int age)方法中age = age;这句代码，两个age均指的是形参age这个局部变量。如没有用this显式指明age，则会遵循就近原则，就会发生局部变量age对自己赋值的情况。 局部变量使用范围问题123456789101112131415161718class Demo&#123; String s = "Outer"; public static void main(String[] args)&#123; S2 s2 = new S2(); s2.display(); &#125;&#125;class S1&#123; String s = "S1"; public void display()&#123; System.out.println(s); &#125;&#125;class S2 extends S1&#123; String s = "S2";&#125; 代码如上所示，最终运行结果为S1。 可以总结出：就近原则在使用时，应注意方法对变量的调用也是遵循就近原则的。 多态中关于变量的使用1234567891011121314151617181920212223public class Demo&#123; public static void main(String[] args)&#123; Fu f = new Zi(); System.out.println(f.a); f.method;//这是子类的method方法 &#125;&#125;class Fu&#123; int a = 1; public void method()&#123; System.out,println("这是父类的method方法"); &#125;&#125;class Zi extends Fu&#123; int a = 2; public void method()&#123; System.out.println("这是子类的method方法"); &#125;&#125; 代码如上所示。 我的错误选项： 如果将父类中的成员变量a删除，修改代码如下： 12345class Fu&#123; public void method()&#123; System.out,println("这是父类的method方法"); &#125;&#125; 则运行结果为： 122这是子类的method方法 上面的选项是错误的。正确的运行结果为：编译器报错。 因为如果将Fu类中的成员变量a删除后，在Demo的主函数中f.a的用法将会无法通过编译。 关于println()与toString()的联系12345678910111213141516public class ToStringTest &#123; static int i = 1; public static void main(String args[]) &#123; // 调用ToStringTest的 toString方法 System.out.println("love " + new ToStringTest()); ToStringTest a = new ToStringTest(); a.i++; System.out.println("me " + a.i); &#125; public String toString() &#123; System.out.print("I "); return "java "; &#125;&#125; 运行结果： 12I love java me 2 从结果中，猛一下似乎看不太明白，但静下心来仔细分析，我们会发现在主函数的第一句代码 System.out.println(&quot;love &quot; + new ToStringTest()); 执行过程中，JVM优先解析了 “ + “后面的new ToStringTest()，而我们知道，在JVM调用println()时，底层是调用了该Object对象的toString()方法，所以会最先执行ToStringTest类中重写的toString()方法。结果也就在逻辑之中了。 String类型的深度解析String的本质打开String的源码，类注释中有这么一段话 “Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings.Because String objects are immutable they can be shared.”。 这句话总结归纳了String的一个最重要的特点： String是值不可变(immutable)的常量，是线程安全的(can be shared)。 接下来，String类使用了final修饰符，表明了String类的第二个特点：String类是不可继承的。 下面是String类的成员变量定义，从类的实现上阐明了String值是不可变的(immutable)。 private final char value[]; private final int count; 因此，我们看String类的concat方法。实现该方法第一步要做的肯定是扩大成员变量value的容量，扩容的方法重新定义一个大容量的字符数组buf。第二步就是把原来value中的字符copy到buf中来，再把需要concat的字符串值也copy到buf中来，这样子，buf中就包含了concat之后的字符串值。下面就是问题的关键了，如果value不是final的，直接让value指向buf，然后返回this，则大功告成，没有必要返回一个新的String对象。但是。。。可惜。。。由于value是final型的，所以无法指向新定义的大容量数组buf，那怎么办呢？“return new String(0, count + otherLen, buf);”，这是String类concat实现方法的最后一条语句，重新new一个String对象返回。这下真相大白了吧！ ​ 总结：String实质是字符数组，两个特点： 该类不可被继承 不可变性(immutable)。 12345String s1 = "ab";String s2 = "abc";String s3 = s1 + "c";System.out.println(s3 == s2); //falseSystem.out.println(s3.equals(s2)); //true 1234String s1 = "a" + "b" + "c";String s2 = "abc";System.out.println(s1 == s2);//trueSystem.out.println(s1.equals(s2));//true java网络编程Socket文件上传过程中的中文乱码问题文件上传功能的实现 要求 1、开启文件上传服务器后，侦听TCP连接，若有新连接，则创建一条新的线程去处理连接。 2、文件上传的流程： 123456789101112131415161718192021222324（1） 客户端要求用户录入一个文件路径。客户端对路径进行合理性判断。 （2） 第一次通信： 如果路径正确，则客户端将文件名（getName()方法）发送给服务器。服务器进行接收。 （3） 第二次通信： 服务器接收到文件名后，判断给定的目录中是否存在该文件（exists()方法）， 如果不存在，则反馈false;如果存在则反馈true。 客户端等待反馈结果。 （4） 第三次通信（文件复制的核心部分）： if (反馈为false) &#123; 客户端：将文件读入，通过socket输出流传递 服务器端：通过socket输入流接收，将文件写出 &#125; else &#123; 提示文件已存在，上传失败 &#125; （5） 第四次通信： 复制成功后，服务器反馈复制成功信息。 问题解决很简单（突然感觉自己好蠢）： 不要使用windows自带的鼠标右键新建-&gt;新建文本文档。因为会默认使用GBK格式。 需要使用一些UTF-8编码格式的或者其他格式的都可以识别，只要编码解码格式相同，就不会出现乱码问题。 关于java中true和false是否为Object类型的问题在调用方法时，形参要求的是Object类型，我传了一个false进去，没报错也运行出来了，然后就有点小疑惑，仔细想了想，想到了boolean的包装类Boolean。在参数传进去的时候，应该是把false当作一个Boolean类型了。 Scanner类中next()和nextLine()的区别对于键盘录入对象Scanner对象的两个录入字符串方法的区别Scanner sc = new Scanner(System.in);sc.next()和 sc.nextLine();的区别next() 对于录入的字符串碰到空格就会停止录入nextLine()会把整行字符串全部录入并且sc.next() 在录入字符串后会在尾部加一个 \r\n 因而sc.nextLine()会录入 \r\n 而导致原来nextLine要录入的字符串没有录入 1234567891011121314//例1：import java.util.Scanner;public class nextAndNextLine &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(“请输入第一个字符串”); String a = sc.next(); System.out.println(“请输入第二个字符串”); String b = sc.nextLine(); System.out.println(“字符串1:” + a); System.out.println(“字符串2:” + b); sc.close(); &#125;&#125; 运行结果： 请输入第一个字符串 abc 请输入第二个字符串 字符串1：abc 字符串2： 这里我们可以看出来我们本来要录入两个字符串，但是只录入和打印了一个字符串，这个原因是next()方法会在尾部加一个换行符，windows系统的换行符是\r\n,因而后面的nextLine()方法将\r\n录入进去，从而造成第二次没有录入字符串的情况。 1234567891011121314//例2：import java.util.Scanner;public class nextAndNextLine &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(“请输入第一个字符串”); String a = sc.nextLine(); System.out.println(“请输入第二个字符串”); String b = sc.next(); System.out.println(“字符串1:” + a); System.out.println(“字符串2:” + b); sc.close(); &#125;&#125; 运行结果： 请输入第一个字符串 abc 请输入第二个字符串 字符串1：abc 字符串2：abc 这时候我们可以看到,键盘允许你录入两个数据,并且正确的输出了两个数据。这里我们可以看出nextLine()方法后面并不会加默认的符号，因此我建议录入字符串尽量用nextLine方法。 1234567891011121314//例3：import java.util.Scanner;public class nextAndNextLine &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(“请输入第一个字符串”); String a = sc.nextLine(); System.out.println(“请输入第二个字符串”); String b = sc.next(); System.out.println(“字符串1:” + a); System.out.println(“字符串2:” + b); sc.close(); &#125;&#125; 运行结果： 请输入第一个字符串 abc 请输入第二个字符串 ab c 字符串1：abc 字符串2：ab 这里我们可以看出来，next()方法碰到空格就会停止录入,因此只录入abc，而nextLine()方法会将这行字符串全部录入。因此建议用nextLine()方法录入字符串。 单例模式什么是单例模式? 1一个对象从tomcat启动到tomcat 结束(假设运行24小时) ,再次期间如果对象只被创建了一次,则对象是单例的 单利有什么好处? 12345我们知道每个new 一个对象,对内存中就需要开辟一部分空间存储该对象,如果一个对象每次被访问都需要new 一次,极大的浪费了内存空间,导致系统性能下降单例的好处: 1) 节约内存弊端: 如果有全局变量则有安全问题 java 如何实现单例模式? 1234567891011121314151617181920//懒汉式和饿汉式两种//所谓“懒汉式”与“饿汉式”的区别，是在与建立单例对象的时间的不同。//“懒汉式”是在你真正用到的时候才去建这个单例对象：public class Singleton&#123; private Singleton()&#123;&#125; private static Singleton singleton = null； //不建立对象 public static synchronized Singleton getInstance()&#123; if(singleton == null) &#123; //先判断是否为空 singleton = new Singleton (); //懒汉式做法 &#125; return singleton ； &#125;&#125;// “饿汉式”是在不管你用的用不上，一开始就建立这个单例对象：public class Singleton&#123; public Singleton()&#123;&#125; private static Singleton singleton = new Singleton(); //建立对象 public static Singleton getInstance()&#123; return singleton ;//直接返回单例对象 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-ErrorLog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE]]></title>
    <url>%2FJava%2F01_JavaSE%2F</url>
    <content type="text"><![CDATA[环境变量的配置 右键 “我的电脑” – “属性” – “高级系统设置” – “高级” – “环境变量” 打开环境变量设置。 新建系统变量“JAVA_HOME”，值的内容为JDK的根目录。 在“Path”环境变量的值中，增加“%JAVA_HOME%\bin;” 此时再使用cmd即可直接使用javac和java命令。 JDK9的JShell的简单使用直接在cmd中输入jshell，回车，即可启动JShell。 JShell一般用于极其简单、轻量的情况。 编译器的两点优化（对于变量的赋值）第一个优化对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。 如果没有超过左侧的范围，编译器补上强转。 如果右侧超过了左侧范围，那么直接编译器报错。 123456789101112131415public class Demo01 &#123; public static void main(String[] args) &#123; // 右侧确实是一个int数字，但是没有超过左侧的范围，就是正确的。 // int --&gt; byte, 不是自动类型转换 byte num1 = /*(byte)*/ 30; // 右侧没有超过左侧范围 System.out.println(num1); // 30 // byte num2 = 128; // 右侧超过了左侧的范围，编译器报错 // int --&gt; char, 没有超过范围 // 编译器将会自动补上一个隐含的(char) char c1 = /*(char)*/ 65; System.out.println(c1); // A &#125; &#125; 第二个优化在给变量进行赋值的时候，如果右侧的表达式当中全部都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。 short result = 5 + 8; // 等号右边全部都是常量，没有任何变量参与运算 编译之后，得到的.class字节码文件当中相当于【直接就是】： short result = 13; 右侧的常量结果数值，没有超过左侧范围，所以正确。 这称为“编译器的常量优化” 但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。 12345678910111213141516public class Demo02 &#123; public static void main(String[] args) &#123; short num1 = 10; // 正确写法，右侧没有超过左侧范围 short a = 5; short b = 8; // short + short --&gt; int + int --&gt; int // short result = a + b; // 错误写法！左侧需要是int类型 // 右侧不用变量，而是采用常量，而且只有两个常量，没有别人 short result = 5 + 8; System.out.println(result); short result2 = 5 + a + 8; // 结果应该是18，但是编译器报错 &#125;&#125; switch语句使用的注意事项 多个case后面的数值不可以重复 switch后面小括号当中只能是下列数据类型： 基本数据类型：byte / short / char / int 引用数据类型：String字符串 / enum枚举 switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。 匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者switch的整体结束为止。 关于switch的穿透代码示例： 123456789101112131415public class Debug01 &#123; public static void main(String[] args) &#123; int a = 1; switch (a) &#123; case 1: System.out.println("1."); case 2: case 3: default: // switch的穿透，所以会执行下面的输出语句。 System.out.println("default."); &#125; &#125;&#125; 代码的运行结果为： 121.default. 数组的定义 方式1： 动态初始化：数据类型[] 数组名称 = new 数据类型[数组长度]; 方式2： 标准的静态初始化：数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … }; 方式3： 省略的静态初始化：数据类型[] 数组名称 = { 元素1, 元素2, … }; 注意事项： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。 静态初始化标准格式可以拆分成为两个步骤。 动态初始化也可以拆分成为两个步骤。 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。 使用建议：如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。 1234567891011121314151617181920public class Demo03 &#123; public static void main(String[] args) &#123; // 省略格式的静态初始化 int[] arrayA = &#123; 10, 20, 30 &#125;; // 静态初始化的标准格式，可以拆分成为两个步骤 int[] arrayB; arrayB = new int[] &#123; 11, 21, 31 &#125;; // 动态初始化也可以拆分成为两个步骤 int[] arrayC; arrayC = new int[5]; // 静态初始化的省略格式，不能拆分成为两个步骤。// int[] arrayD;// arrayD = &#123; 10, 20, 30 &#125;; &#125;&#125; 数组中的内存图 Random类 作用：用于产生一个随机数 所属包：java.util.Random 格式： 12Random random = new Random();int number = random.nextInt(int index); // 获取数据的范围：[0,index) 左闭右开的一个区间。 拓展： Math类下的static double random()方法的返回值为double。值为正号，大于等于 0.0 ，小于 1.0 。 即获取数据的范围：[0.0, 1.0) 左闭右开的一个区间。 常用案例： 生成一个1~100的随机数字 1234int num = (int)(Math.random() * 100) + 1; // 使用Math类下的random()静态方法Random r = new Random();int num1 = r.nextInt(100) + 1; // 使用Random类生成 方法重载的注意点 与返回值类型无关 123456789public class MethodDemo&#123; public static void fn(int a)&#123; //method body &#125; public static int fn(int a)&#123; //method body &#125;&#125; 上面的代码不构成方法的重载：因为形参列表相同。虽然返回值类型不同，但方法重载与返回值类型无关。 集成开发环境IntelliJ IDEA IDE（Integrated Development Environment）集成开发环境。 至于本章主题描述 一句话 IDEA牛逼。。。OK就这样233 IDEA中Debug的使用如何加断点选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可。 如何运行加了断点的程序在代码区域右键Debug执行。 看哪里看Debugger窗口 点哪里点Step Into（F7）这个箭头，也可以直接按F7，运行完之后，点击Stop结束。 如何删除断点选择要删除的断点，单击鼠标左键即可。 如果是多个断点，可以每一个再点击一次，也可以一次性全部删除。 注意事项如果数据来自于键盘输入（Scanner），一定要记住输入数据，不然就不能继续往下查看了。 Java中的内存分配JVM简介 Java虚拟机（Java Virtual Machine 简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 一个运行时的Java虚拟机实例的天职是：负责运行一个java程序。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。 JVM的体系结构包含几个主要的子系统和内存区： 垃圾回收器（Garbage Collection）：负责回收堆内存（Heap）中没有被使用的对象，即这些对象已经没有被引用了。 类装载子系统（ClassLoader Sub-System）：除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。 执行引擎（Execution Engine）：负责执行那些包含在被装载类的方法中的指令。 运行时数据区（Java Memory Allocation Area）：又叫虚拟机内存或者Java内存，虚拟机运行时需要从整个计算机内存划分一块内存区域存储许多东西。例如：字节码、从已装载的class文件中得到的其他信息、程序创建的对象、传递给方法的参数，返回值、局部变量等等。 Java内存分区从上节知道，运行时数据区即是java内存，而且数据区要存储的东西比较多，如果不对这块内存区域进行划分管理，会显得比较杂乱无章。 根据存储数据的不同，java内存通常被划分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Method Area）、栈（Stack）、堆（Heap）。 程序计数器（Program Count Register）：又叫程序寄存器。JVM支持多个线程同时运行，当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）。如果线程正在执行的是一个Java方法（非native），那么PC寄存器的值将总是指向下一条将被执行的指令，如果方法是 native的，程序计数器寄存器的值不会被定义。 JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。 栈（Stack）：又叫堆栈。JVM为每个新创建的线程都分配一个栈。也就是说,对于一个Java程序来说，它的运行就是通过对栈的操作来完成的。栈以帧为单位保存线程的状态。JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。我们知道,某个线程正在执行的方法称为此线程的当前方法。我们可能不知道，当前方法使用的帧称为当前帧。当线程激活一个Java方法，JVM就会在线程的 Java堆栈里新压入一个帧，这个帧自然成为了当前帧。在此方法执行期间，这个帧将用来保存参数、局部变量、中间计算过程和其他数据。从Java的这种分配机制来看,堆栈又可以这样理解：栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。 方法区（Method Area）：当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，如下图所示。本地方法区存在一块特殊的内存区域，叫常量池（Constant Pool），这块内存将与String类型的分析密切相关。 堆（Heap）：Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。在此区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存，但是这个对象的引用却是在栈（Stack）中分配。因此，执行String s = new String(“s”)时，需要从两个地方分配内存：在堆中为String对象分配内存，在栈中为引用（这个堆对象的内存地址，即指针）分配内存。 继承 格式：public class 子类名 extends 父类名 { } 范例：public class Zi extends Fu { } 代码范例： 1234567891011121314151617181920212223public class Demo04 &#123; public static void main(String[] args) &#123; //创建对象，调用方法 Fu f = new Fu(); f.show(); Zi z = new Zi(); z.method(); z.show();//调用继承于父类的show方法 &#125;&#125;class Fu &#123; public void show()&#123; System.out.println("父类的show方法"); &#125;&#125;class Zi extends Fu &#123; public void method()&#123; System.out.println("子类的method方法"); &#125;&#125; 注意：父类的构造器无法继承下来，如需调用，使用super关键字即可。 继承的好处与弊端 好处： 提高了代码的 复用性（多个类相同的成员可以放到同一个类中） 提高了代码的 维护性（如果方法的代码需要修改，修改一处即可） 弊端： 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性 继承体现的关系： is a 继承中成员变量的访问特点通过子类对象访问一个变量 ，遵循就近原则： 先找局部范围 再找子类成员范围 再找父类成员范围 如果都没有就报错(不考虑父亲的父亲…) 继承中成员方法的访问特点与成员变量的“就近原则”类似。 再找子类成员范围 再找父类成员范围 如果都没有就报错(不考虑父亲的父亲…) 继承中构造函数的访问特点 子类会继承父类的数据，可能还会使用父类的数据。所以子类初始化之前，一定要先完成父类的初始化。 每一个子类构造方法的第一条语句默认都是：super(); 如果想要控制子类的构造方法调用父类的哪一个构造方法，使用super进行调用即可。 示例代码： 1234567891011121314151617181920212223242526272829public class Demo05 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); &#125;&#125;class Fu &#123; public Fu() &#123; System.out.println("Fu的无参"); &#125; public Fu(int age) &#123; System.out.println("Fu的有参"); &#125;&#125;class Zi extends Fu &#123; public Zi() &#123;// super();//调用父类的无参构造函数 super(10);//调用父类的有参构造函数 System.out.println("Zi的无参"); &#125; public Zi(int age) &#123; //默认调用super();即无参构造函数，可以使用super(int值)显式调用父类的有参构造函数 super(10); System.out.println("Zi的有参"); &#125;&#125; Super内存图 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 方法重写 在重写方法时，可以在声明前加入@Override注解，可以帮助我们检查我们要重写的方法声明是否错误 父类中私有的方法不能被重写 子类的方法的声明和父类的方法的声明一般一致，但是有些地方可以不一致，遵循以下原则： 一大：子类重写的方法的权限修饰符必须大于或者等于父类方法的权限修饰符 private &lt; default &lt; protected &lt; public 两同： 方法名必须相同 参数列表必须相同 两小： 子类重写的方法的返回值类型必须小于等于父类方法的返回值类型（针对的是引用类型，一般小于说的是子类与父类的关系，对基本类型无效） 子类重写的方法抛出的异常必须小于等于或者少于等于父类的方法抛出的异常，如果父类方法没有抛出异常，则子类重写之后的方法绝对不能抛出异常 继承的注意事项 Java中的类只支持单继承，不支持多继承（一个类只能有一个父类） Java中的类支持多层继承 final、static修饰符 final修饰符： 修饰方法：该方法无法被重写 修饰变量：该变量无法被赋值 修饰类：该类无法被继承 static修饰符： 被类的所有对象共享 可以通过类名调用 非静态的成员方法 能访问静态的成员变量 能访问非静态的成员变量 能访问静态的成员方法 能访问非静态的成员方法 静态的成员方法 能访问静态的成员变量 能访问静态的成员方法 总结成一句话就是：静态成员方法只能访问静态成员 示例代码： 123456789101112131415161718192021222324class Student &#123; public String name; //姓名 public int age; //年龄 public static String university; //学校 共享数据！所以设计为静态！ public void show() &#123; System.out.println(name + "," + age + "," + university); &#125;&#125;public class Demo06 &#123; public static void main(String[] args) &#123; // 为对象的共享数据赋值 Student.university = "Tsinghua"; Student s1 = new Student(); s1.name = "lcw"; s1.age = 30; s1.show(); Student s2 = new Student(); s2.name = "ld"; s2.age = 33; s2.show(); &#125;&#125; 多态 概念 一个事物在不同情况下表现出的多种形态 前提 有继承/实现关系 有方法的重写（不一定是必须有） 父类的引用指向子类的对象 多态中成员访问的特点 成员变量：编译看左边（父类），运行看左边（父类） 成员方法：编译看左边（父类），运行看右边（子类） 总结：编译都看左边，运行也都看左边（非静态的成员方法除外）。 多态的好处与弊端 好处：提高了程序的扩展性 弊端：不能使用子类的特有属性、功能 多态的转型（引用类型的转换） 向上转型：小类型（子类）转为大类型（父类），自动转 格式：父类类型 变量名 = 子类对象; 比如：Animal a = new Cat(); 其实多态的体现就是向上转型 向下转型：大类型（父类）转为小类型（子类），强制转 格式：子类类型 对象名 = （子类类型）父类类型的对象名; 比如：Cat c = (Cat)a; 抽象类 概念：使用abstract关键字修饰的类 格式：public abstract class 类名 { } 抽象类的特点 抽象类和抽象方法必须使用 abstract 关键字修饰 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类 抽象类不能实例化 抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态 抽象类的子类 要么重写抽象类中的所有抽象方法 要么是抽象类 抽象类的成员特点 成员变量 既可以是变量 也可以是常量 构造方法 空参构造 有参构造 成员方法 抽象方法 普通方法 接口 概念：公共的规范和标准，只要按照这些规范来就可以正确使用 接口的特点 接口用关键字interface修饰 1public interface 接口名 &#123;&#125; 类实现接口用implements表示 1public class 类名 implements 接口名 &#123;&#125; 接口不能实例化 接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。 多态的形式：具体类多态，抽象类多态，接口多态。 接口的子类 要么重写接口中的所有抽象方法 要么子类也是抽象类 内部类 概念：就是在一个类中定义一个类 格式 ： 1234public class 类名&#123; 修饰符 class 类名&#123; &#125;&#125; ​ 内部类的访问特点 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 分类 成员内部类 局部内部类 匿名内部类 常用API工具类设计思想 构造方法用 private 修饰 成员用 public static 修饰 java.util.Arrays public static String toString(int[] a) ：将指定给定数组以指定格式的字符串返回 [元素1, 元素2, 元素3] 如果直接使用System.out.println()打印一个数组，其实得到的是地址值（字符数组除外，字符数组打印出来的是元素内容） public static void sort(int[] a) ：将指定的数组元素进行排序，默认升序排列 java.util.Math 1、Math类概述 Math 包含执行基本数字运算的方法 2、Math中方法的调用方式 Math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用 3、Math类的常用方法 方法名 说明 public static int abs(int a) 返回参数的绝对值 public static double ceil(double a) 返回大于或等于参数的最小double值，等于一个整数 public static double floor(double a) 返回小于或等于参数的最大double值，等于一个整数 public static int round(float a) 按照四舍五入返回最接近参数的int public static int max(int a,int b) 返回两个int值中的较大值 public static int min(int a,int b) 返回两个int值中的较小值 public static double pow (double a,double b) 返回a的b次幂的值 public static double random() 返回值为double的正值，[0.0,1.0) java.lang.Object toString() equals() java.lang.System System类的常用方法 方法名 说明 public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前时间(以毫秒为单位) java.util.Date void setTime(long millis) long getTime() Date()：代表的当前系统时间 Date(long millis)：代表基准时间+毫秒值落到的时间 java.text.SimpleDateFormat SimpleDateFormat(String str) String format(Date d) Date parse(String str) java.util.Calendar get(int field) void set(int year, int month, int date) setTime(Date date) add(int field,int amount) 注意： 月份是从0~11 ，0表示1月，1表示2月，以此类推… 星期是从1-7，1表示星期日，2表示星期一，以此类推… 包装类 基本类型包装类的作用 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 基本类型对应的包装类 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean Integer经典使用案例（String与int类型转换） int —&gt; String 方式一： 123int num = 100;String s1 = num + "";System.out.println(s1); 方式二： 123int num = 100;String s2 = String.valueOf(num);System.out.println(s2); 方式三： 123int num = 100;String s3 = Integer.toString(num);System.out.println(s3); String —&gt; int 方式一： 1234String s = "100";Integer i = Integer.valueOf(s);int x = i.intValue();System.out.println(x); 方式二： 123String s = "100";int y = Integer.parseInt(s);System.out.println(s); 案例： 需求：有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：“27 38 46 50 91” 思路： 定义一个字符串 把字符串中的数字数据存储到一个int类型的数组中 得到字符串中每一个数字数据？ public String[] split(String regex) 定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中 public static int parseInt(String s) 对 int 数组进行排序 把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现 输出结果 代码： 1234567891011121314151617181920212223242526public class IntegerTest &#123; public static void main(String[] args) &#123; //定义一个字符串 String s = "91 27 46 38 50"; //把字符串中的数字数据存储到一个int类型的数组中 String[] strArray = s.split(" "); int arr[] = new int[strArray.length]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = Integer.parseInt(strArray[i]); &#125; //对 int 数组进行排序 Arrays.sort(arr); //把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现 StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; if (i == arr.length - 1) &#123; sb.append(arr[i]); &#125; else &#123; sb.append(arr[i]).append(" "); &#125; &#125; //输出结果 System.out.println(sb); &#125;&#125; Integer的注意点：在自动装箱与自动拆箱的过程中，同样的赋值语句，可能对应不同的地址。例如： 1234567Integer i1 = Integer.valueOf(100);Integer i2 = Integer.valueOf(100);System.out.println(i1 == i2); // trueInteger i3 = Integer.valueOf(200);Integer i4 = Integer.valueOf(200);System.out.println(i3 == i4); // false 然后我们扒Integer的源码，发现： 123456789101112131415public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; int h = 127; high = h; //然后是其他部分的源码，不再赘述，只取部分说明 ...&#125; 异常异常的概念 程序在编译或者运行的过程中出现的错误 Java中的异常指的都是异常类 异常类的体系 Throwable Error：不研究 Exception 编译时异常（检查异常）：Exception下除了RuntimeException及其子类之外的都是编译时异常 运行时异常（非检查异常）：RuntimeException及其子类都是运行时异常 集合 集合的体系结构： 单列集合： Collection接口 List接口：可以存储重复元素、存取有序、有索引可以根据索引操作元素 ArrayList类 LinkedList类 Set接口：不可以存储重复元素、存取无序、无索引不可以根据索引操作元素 HashSet类 TreeSet类 双列集合： Map接口 HashMap类 单列集合Collection常用方法： 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定的元素 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合中是否存在指定的元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中元素的个数 List接口存储的数据是可重复的、与添加顺序一致的（存取有序） ArrayList集合 ​ 底层是数组结构实现，查询快、增删慢 LinkedList集合 ​ 底层是链表结构实现，查询慢、增删快 ArrayList特有的常用方法： 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 List中，使用迭代器Iterator可能会导致并发修改异常的情况： 出现的原因 ​ 迭代器遍历的过程中，通过集合对象修改了集合中的元素 （添加和删除），造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：ConcurrentModificationException 解决的方案 ​ 用for循环遍历，然后用集合对象做对应的操作即可 示例代码 123456789101112131415161718192021222324252627282930public class ListDemo &#123; public static void main(String[] args) &#123; //创建集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add("hello"); list.add("world"); list.add("java"); //遍历集合，得到每一个元素，看有没有"world"这个元素，如果有，我就添加一个"javaee"元素，请写代码实现// Iterator&lt;String&gt; it = list.iterator();// while (it.hasNext()) &#123;// String s = it.next();// if(s.equals("world")) &#123;// list.add("javaee");// &#125;// &#125; for(int i=0; i&lt;list.size(); i++) &#123; String s = list.get(i); if(s.equals("world")) &#123; list.add("javaee"); &#125; &#125; //输出集合对象 System.out.println(list); &#125;&#125; 列表迭代器 ListIterator介绍 通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器 用于允许程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置 示例代码 1234567891011121314151617181920212223public class ListIteratorDemo &#123; public static void main(String[] args) &#123; //创建集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add("hello"); list.add("world"); list.add("java"); //获取列表迭代器 ListIterator&lt;String&gt; lit = list.listIterator(); while (lit.hasNext()) &#123; String s = lit.next(); if(s.equals("world")) &#123; lit.add("javaee"); &#125; &#125; System.out.println(list); &#125;&#125; LinkedList集合的特有功能 特有方法 方法名 说明 public void addFirst(E e) 在该列表开头插入指定的元素 public void addLast(E e) 将指定的元素追加到此列表的末尾 public E getFirst() 返回此列表中的第一个元素 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 Set接口方法与List接口几乎一模一样。 主要实现类有HashSet、TreeSet、LinkedHashSet。 存储的数据是不可重复的、不保证与添加顺序一致的（存取无序）。 双列集合MapMap集合的特点 键值对映射关系 一个键对应一个值 键不能重复，值可以重复 元素存取无序 方法介绍 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 根据键删除键值对元素 void clear() 移除所有的键值对元素 boolean containsKey(Object key) 判断集合是否包含指定的键 boolean containsValue(Object value) 判断集合是否包含指定的值 boolean isEmpty() 判断集合是否为空 int size() 两种遍历方式： keySet() entrySet() Collections工具类常用方法： shuffle() reverse() sort() IOFile类构造方法 File(String pathname) File(String parent , String child) File(File parent , String child) 常用方法 创建文件 boolean createNewFile() 创建文件 创建文件夹 boolean mkdir() 创建目录 boolean mkdirs() 创建多级目录 判断 boolean isDirectory() boolean isFile() boolean exists() 获取 String getAbsolutePath() String getPath() String getName() String[] list 获取当前文件夹下，所有的文件或者单级子文件夹名称数组 File[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 删除 boolean delete() API中没有直接提供级联删除方法，只提供了这一个删除方法，如果调用此方法的File是非空目录，则会拒绝删除请求，返回false。 IO流的体系【IO重点】 字节流 InputStream FileInputStream BufferedInputStream OutputStream FileOutputStream BufferedOutputStream 字符流 Reader InputStreamReader FileReader BufferedReader Writer OutputStreamWriter FileWriter BufferedWriter Properties（集合与IO相结合）Properties作为Map集合的使用 Properties介绍 是一个Map体系的集合类 Properties可以保存到流中或从流中加载 属性列表中的每个键及其对应的值都是一个字符串 Properties基本使用 12345678910111213141516171819public class PropertiesDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象// Properties&lt;String,String&gt; prop = new Properties&lt;String,String&gt;(); //错误 Properties prop = new Properties(); //存储元素 prop.put("it001", "lcw"); prop.put("it002", "ld"); prop.put("it003", "lgl"); //遍历集合 Set&lt;Object&gt; keySet = prop.keySet(); for (Object key : keySet) &#123; Object value = prop.get(key); System.out.println(key + "," + value); &#125; &#125;&#125; Properties作为Map集合的特有方法 特有方法 方法名 说明 Object setProperty(String key, String value) 设置集合的键和值，都是String类型，底层调用 Hashtable方法 put String getProperty(String key) 使用此属性列表中指定的键搜索属性 Set&lt;String&gt; stringPropertyNames() 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 示例代码 12345678910111213141516171819202122232425262728293031323334public class PropertiesDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Properties prop = new Properties(); //Object setProperty(String key, String value)：设置集合的键和值，都是String类型，底层调用Hashtable方法put prop.setProperty("it001", "lcw"); /* Object setProperty(String key, String value) &#123; return put(key, value); &#125; Object put(Object key, Object value) &#123; return map.put(key, value); &#125; */ prop.setProperty("it002", "ld"); prop.setProperty("it003", "lgl"); //String getProperty(String key)：使用此属性列表中指定的键搜索属性// System.out.println(prop.getProperty("it001"));// System.out.println(prop.getProperty("it0011"));// System.out.println(prop); //Set&lt;String&gt; stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 Set&lt;String&gt; names = prop.stringPropertyNames(); for (String key : names) &#123;// System.out.println(key); String value = prop.getProperty(key); System.out.println(key + "," + value); &#125; &#125;&#125; Properties和IO流相结合的方法 和IO流结合的方法 方法名 说明 void load(InputStream inStream) 从输入字节流读取属性列表（键和元素对） void load(Reader reader) 从输入字符流读取属性列表（键和元素对） void store(OutputStream out, String comments) 将此属性列表（键和元素对）写入此 Properties表中，以适合于使用 load(InputStream)方法的格式写入输出字节流 void store(Writer writer, String comments) 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 示例代码 12345678910111213141516171819202122232425262728293031323334public class PropertiesDemo03 &#123; public static void main(String[] args) throws IOException &#123; //把集合中的数据保存到文件// myStore(); //把文件中的数据加载到集合 myLoad(); &#125; private static void myLoad() throws IOException &#123; Properties prop = new Properties(); //void load(Reader reader)： FileReader fr = new FileReader("myOtherStream\\fw.txt"); prop.load(fr); fr.close(); System.out.println(prop); &#125; private static void myStore() throws IOException &#123; Properties prop = new Properties(); prop.setProperty("it001","lcw"); prop.setProperty("it002","ld"); prop.setProperty("it003","lgl"); //void store(Writer writer, String comments)： FileWriter fw = new FileWriter("myOtherStream\\fw.txt"); prop.store(fw,null); fw.close(); &#125;&#125; 游戏次数案例 案例需求 实现猜数字小游戏只能试玩3次，如果还想玩，提示：游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn) 分析步骤 写一个游戏类，里面有一个猜数字的小游戏 写一个测试类，测试类中有main()方法，main()方法中写如下代码： ​ 从文件中读取数据到Properties集合，用load()方法实现 文件已经存在：game.txt 里面有一个数据值：count=0 ​ 通过Properties集合获取到玩游戏的次数 ​ 判断次数是否到到3次了 如果到了，给出提示：游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn) 如果不到3次： 次数+1，重新写回文件，用Properties的store()方法实现玩游戏 代码实现 123456789101112131415161718192021222324252627282930public class PropertiesTest &#123; public static void main(String[] args) throws IOException &#123; //从文件中读取数据到Properties集合，用load()方法实现 Properties prop = new Properties(); FileReader fr = new FileReader("myOtherStream\\game.txt"); prop.load(fr); fr.close(); //通过Properties集合获取到玩游戏的次数 String count = prop.getProperty("count"); int number = Integer.parseInt(count); //判断次数是否到到3次了 if(number &gt;= 3) &#123; //如果到了，给出提示：游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn) System.out.println("游戏试玩已结束，想玩请充值(www.skywalkerkkkk.cn)"); &#125; else &#123; //玩游戏 GuessNumber.start(); //次数+1，重新写回文件，用Properties的store()方法实现 number++; prop.setProperty("count",String.valueOf(number)); FileWriter fw = new FileWriter("myOtherStream\\game.txt"); prop.store(fw,null); fw.close(); &#125; &#125;&#125; 对象序列化流 对象序列化介绍 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化 对象序列化流： ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 构造方法 方法名 说明 ObjectOutputStream(OutputStream out) 创建一个写入指定的OutputStream的ObjectOutputStream 序列化对象的方法 方法名 说明 void writeObject(Object obj) 将指定的对象写入ObjectOutputStream 示例代码 学生类 123456789101112131415161718192021222324252627282930313233343536public class Student implements Serializable &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 测试类 123456789101112131415public class ObjectOutputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\oos.txt")); //创建对象 Student s = new Student("lcw",34); //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream oos.writeObject(s); //释放资源 oos.close(); &#125;&#125; 注意事项 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 Serializable是一个标记接口，实现该接口，不需要重写任何方法 对象反序列化流 对象反序列化流： ObjectInputStream ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象 构造方法 方法名 说明 ObjectInputStream(InputStream in) 创建从指定的InputStream读取的ObjectInputStream 反序列化对象的方法 方法名 说明 Object readObject() 从ObjectInputStream读取一个对象 示例代码 1234567891011121314public class ObjectInputStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\oos.txt")); //Object readObject()：从ObjectInputStream读取一个对象 Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + "," + s.getAge()); ois.close(); &#125;&#125; serialVersionUID&amp;transient serialVersionUID 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ 会出问题，会抛出InvalidClassException异常 如果出问题了，如何解决呢？ 重新序列化 给对象所属的类加一个serialVersionUID private static final long serialVersionUID = 42L; transient 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？ 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程 示例代码 学生类 1234567891011121314151617181920212223242526272829303132333435363738public class Student implements Serializable &#123; private static final long serialVersionUID = 42L; private String name;// private int age; private transient int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;// @Override// public String toString() &#123;// return "Student&#123;" +// "name='" + name + '\'' +// ", age=" + age +// '&#125;';// &#125;&#125; 测试类 1234567891011121314151617181920212223public class ObjectStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123;// write(); read(); &#125; //反序列化 private static void read() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myOtherStream\\oos.txt")); Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + "," + s.getAge()); ois.close(); &#125; //序列化 private static void write() throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myOtherStream\\oos.txt")); Student s = new Student("lcw", 30); oos.writeObject(s); oos.close(); &#125;&#125; 多线程 概念： 进程：正在运行的应用程序 线程：是进程中的单个顺序控制流，是一条执行路径 实现多线程实现多线程方式一：继承Thread类 方法介绍 方法名 说明 void run() 在线程开启后，此方法将被调用执行 void start() 使此线程开始执行，Java虚拟机会调用run方法() 实现步骤 定义一个类MyThread继承Thread类 在MyThread类中重写run()方法 创建MyThread类的对象 启动线程 实现多线程方式二：实现Runnable接口 Thread构造方法 方法名 说明 Thread(Runnable target) 分配一个新的Thread对象 Thread(Runnable target, String name) 分配一个新的Thread对象 实现步骤 定义一个类MyRunnable实现Runnable接口 在MyRunnable类中重写run()方法 创建MyRunnable类的对象 创建Thread类的对象，把MyRunnable对象作为构造方法的参数 启动线程 设置和获取线程名称 方法介绍 方法名 说明 void setName(String name) 将此线程的名称更改为等于参数name String getName() 返回此线程的名称 Thread currentThread() 返回对当前正在执行的线程对象的引用 线程优先级 线程调度 两种调度方式 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些 Java使用的是抢占式调度模型 随机性 假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的 优先级相关方法 方法名 说明 final int getPriority() 返回此线程的优先级 final void setPriority(int newPriority) 更改此线程的优先级。线程默认优先级是5；线程优先级的范围是：1-10 线程控制 相关方法 方法名 说明 static void sleep(long millis) 使当前正在执行的线程停留（暂停执行）指定的毫秒数 void join() 等待这个线程死亡（如果某个线程调用了此方法，则其他并发的线程必须等待这个线程死亡后才有机会调用） void setDaemon(boolean on) 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 线程的生命周期 线程同步卖票 案例需求 某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票 实现步骤 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100; 在SellTicket类中重写run()方法实现卖票，代码步骤如下 判断票数大于0，就卖票，并告知是哪个窗口卖的 卖了票之后，总票数要减1 票没有了，也可能有人来问，所以这里用死循环让卖票的动作一直执行 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下 创建SellTicket类的对象 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 启动线程 卖票案例的问题 卖票出现了问题 相同的票出现了多次 出现了负数的票 问题产生原因 线程执行的随机性导致的 生产者与消费者 网络编程入门网络编程概述 计算机网络 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统 网络编程 在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换 网络编程三要素 IP地址 要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识 端口 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识 协议 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议 IP地址IP地址：是网络中设备的唯一标识 IP地址分为两大类 IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题 DOS常用命令： ipconfig：查看本机IP地址 ping IP地址：检查网络是否连通 特殊IP地址： 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用 InetAddressInetAddress：此类表示Internet协议（IP）地址 相关方法 方法名 说明 static InetAddress getByName(String host) 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 String getHostName() 获取此IP地址的主机名 String getHostAddress() 返回文本显示中的IP地址字符串 代码演示 1234567891011121314public class InetAddressDemo &#123; public static void main(String[] args) throws UnknownHostException &#123; //InetAddress address = InetAddress.getByName("skywalker"); InetAddress address = InetAddress.getByName("192.168.1.66"); //public String getHostName()：获取此IP地址的主机名 String name = address.getHostName(); //public String getHostAddress()：返回文本显示中的IP地址字符串 String ip = address.getHostAddress(); System.out.println("主机名：" + name); System.out.println("IP地址：" + ip); &#125;&#125; 端口和协议 端口 设备上应用程序的唯一标识 端口号 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败 协议 计算机网络中，连接和通信的规则被称为网络通信协议 UDP协议 用户数据报协议(User Datagram Protocol) UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议 TCP协议 传输控制协议 (Transmission Control Protocol) TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手” 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 第一次握手，客户端向服务器端发出连接请求，等待服务器确认 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 第三次握手，客户端再次向服务器端发送确认信息，确认连接 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等 UDP通信程序UDP发送数据 Java中的UDP通信 UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念 Java提供了DatagramSocket类作为基于UDP协议的Socket 构造方法 方法名 说明 DatagramSocket() 创建数据报套接字并将其绑定到本机地址上的任何可用端口 DatagramPacket(byte[] buf,int len,InetAddress add,int port) 创建数据包,发送长度为len的数据包到指定主机的指定端口 相关方法 方法名 说明 void send(DatagramPacket p) 发送数据报包 void close() 关闭数据报套接字 void receive(DatagramPacket p) 从此套接字接受数据报包 发送数据的步骤 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包 调用DatagramSocket对象的方法发送数据 关闭发送端 代码演示 12345678910111213141516171819202122public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口 DatagramSocket ds = new DatagramSocket(); //创建数据，并把数据打包 //DatagramPacket(byte[] buf, int length, InetAddress address, int port) //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。 byte[] bys = "hello,udp,我来了".getBytes(); DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName("192.168.1.66"),10086); //调用DatagramSocket对象的方法发送数据 //void send(DatagramPacket p) 从此套接字发送数据报包 ds.send(dp); //关闭发送端 //void close() 关闭此数据报套接字 ds.close(); &#125;&#125; UDP接收数据 接收数据的步骤 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 构造方法 方法名 说明 DatagramPacket(byte[] buf, int len) 创建一个DatagramPacket用于接收长度为len的数据包 相关方法 方法名 说明 byte[] getData() 返回数据缓冲区 int getLength() 返回要发送的数据的长度或接收的数据的长度 示例代码 123456789101112131415161718public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength())); &#125; &#125;&#125; UDP通信程序练习 案例需求 UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束 UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* UDP发送数据： 数据来自于键盘录入，直到输入的数据是886，发送数据结束 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); //自己封装键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = br.readLine()) != null) &#123; //输入的数据是886，发送数据结束 if ("886".equals(line)) &#123; break; &#125; //创建数据，并把数据打包 byte[] bys = line.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.1.66"), 12345); //调用DatagramSocket对象的方法发送数据 ds.send(dp); &#125; //关闭发送端 ds.close(); &#125;&#125;/* UDP接收数据： 因为接收端不知道发送端什么时候停止发送，故采用死循环接收 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength())); &#125; //关闭接收端// ds.close(); &#125;&#125; TCP通信程序TCP发送数据 Java中的TCP通信 Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。 Java为客户端提供了Socket类，为服务器端提供了ServerSocket类 构造方法 方法名 说明 Socket(InetAddress address,int port) 创建流套接字并将其连接到指定IP指定端口号 Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 相关方法 方法名 说明 InputStream getInputStream() 返回此套接字的输入流 OutputStream getOutputStream() 返回此套接字的输出流 示例代码 123456789101112131415public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; //创建客户端的Socket对象(Socket) //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 Socket s = new Socket("192.168.1.66",10000); //获取输出流，写数据 //OutputStream getOutputStream() 返回此套接字的输出流 OutputStream os = s.getOutputStream(); os.write("hello,tcp,我来了".getBytes()); //释放资源 s.close(); &#125;&#125; TCP接收数据 构造方法 方法名 说明 ServletSocket(int port) 创建绑定到指定端口的服务器套接字 相关方法 方法名 说明 Socket accept() 监听要连接到此的套接字并接受它 示例代码 123456789101112131415161718192021public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //创建服务器端的Socket对象(ServerSocket) //ServerSocket(int port) 创建绑定到指定端口的服务器套接字 ServerSocket ss = new ServerSocket(10000); //Socket accept() 侦听要连接到此套接字并接受它 Socket s = ss.accept(); //获取输入流，读数据，并把数据显示在控制台 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); String data = new String(bys,0,len); System.out.println("数据是：" + data); //释放资源 s.close(); ss.close(); &#125;&#125; TCP通信程序练习 案例需求 客户端：数据来自于文本文件，接收服务器反馈 服务器：接收到的数据写入文本文件，给出反馈，代码用线程进行封装，为每一个客户端开启一个线程 案例分析 创建客户端对象，创建输入流对象指向文件，每读入一行数据就给服务器输出一行数据，输出结束后使用shutdownOutput()方法告知服务端传输结束 创建多线程类，在run()方法中读取客户端发送的数据，为了防止文件重名，使用计数器给文件名编号，接受结束后使用输出流给客户端发送反馈信息。 创建服务端对象，每监听到一个客户端则开启一个新的线程接受数据。 客户端接受服务端的回馈信息 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; //创建客户端Socket对象 Socket s = new Socket("192.168.1.66",10000); //封装文本文件的数据 BufferedReader br = new BufferedReader(new FileReader("myNet\\InetAddressDemo.java")); //封装输出流写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); String line; while ((line=br.readLine())!=null) &#123; bw.write(line); bw.newLine(); bw.flush(); &#125; s.shutdownOutput(); //接收反馈 BufferedReader brClient = new BufferedReader(new InputStreamReader(s.getInputStream())); String data = brClient.readLine(); //等待读取数据 System.out.println("服务器的反馈：" + data); //释放资源 br.close(); s.close(); &#125;&#125;public class ServerThread implements Runnable &#123; private Socket s; public ServerThread(Socket s) &#123; this.s = s; &#125; @Override public void run() &#123; try &#123; //接收数据写到文本文件 BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream())); //解决名称冲突问题 int count = 0; File file = new File("myNet\\Copy["+count+"].java"); while (file.exists()) &#123; count++; file = new File("myNet\\Copy["+count+"].java"); &#125; BufferedWriter bw = new BufferedWriter(new FileWriter(file)); String line; while ((line=br.readLine())!=null) &#123; bw.write(line); bw.newLine(); bw.flush(); &#125; //给出反馈 BufferedWriter bwServer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); bwServer.write("文件上传成功"); bwServer.newLine(); bwServer.flush(); //释放资源 s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //创建服务器Socket对象 ServerSocket ss = new ServerSocket(10000); while (true) &#123; //监听客户端连接，返回一个对应的Socket对象 Socket s = ss.accept(); //为每一个客户端开启一个线程 new Thread(new ServerThread(s)).start(); &#125; &#125;&#125; Lambda&amp;方法引用 Lambda表达式为JDK1.8的新特性。 Lambda表达式：简化匿名内部类的一种方式，只能用于有且只有一个抽象方法的接口。 由这三部分组成：(形式参数) -&gt; {代码块} (形式参数): 括号中是参数列表，如果是空参方法，不需要传参。比如Runnable接口中的run()方法。 参数类型可以省略，但是有多个参数的情况下，不能只省略一个。 而且，如果参数有且只有一个那么小括号可以省略。 -&gt;: 固定用法，表示传递 {代码块}: 重写的方法的方法体 如果代码块的语句只有一条，可以省略大括号和分号（如果有return，return也得省略掉） 接口新特性 静态方法（JDK1.8） 格式 public static 返回值类型 方法名(参数列表) { } 范例 12public static void show() &#123;&#125; 注意事项 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 默认方法（JDK1.8） 格式 public default 返回值类型 方法名(参数列表) { } 范例 12public default void show3() &#123; &#125; 注意事项 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字 public可以省略，default不能省略 私有方法（JDK1.9） 主要作用：抽取接口中共性的代码 私有方法产生原因 Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java 9增加私有方法的必然性 定义格式 格式1 private 返回值类型 方法名(参数列表) { } 范例1 12private void show() &#123; &#125; 格式2 private static 返回值类型 方法名(参数列表) { } 范例2 12private static void method() &#123; &#125; 注意事项 默认方法可以调用私有的静态方法和非静态方法 静态方法只能调用私有的静态方法 函数式接口@FunctionalInterface注解：用于检测一个接口是否是函数式接口。 常用的函数式接口： Supplier 属于生产型接口。 接口中只有一个方法 T get(); 获得结果。 Consumer 属于消费型接口 接口中有两个方法： void accept(T t); 对给定的参数执行此操作。 default Consumer andThen(Consumer &lt;? super T&gt; after); 返回一个组合的 Consumer ，按顺序执行该操作，然后执行 after操作。 Predicate 表示一个参数的谓词（布尔值函数）。 五个常用方法，其中boolean test( T t )是该FunctionalInterface的功能方法 Modifier and Type Method and Description default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) 返回一个组合的谓词，表示该谓词与另一个谓词的短路逻辑AND。 static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) 返回根据 Objects.equals(Object, Object)测试两个参数是否相等的 谓词 。 default Predicate&lt;T&gt; negate() 返回表示此谓词的逻辑否定的谓词。 default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) 返回一个组合的谓词，表示该谓词与另一个谓词的短路逻辑或。 boolean test(T t) 在给定的参数上评估这个谓词。 Function 表示接受一个参数并产生结果的函数。 Modifier and Type Method and Description default &lt;V&gt; Function&lt;T,V&gt; andThen(Function&lt;? super R,? extends V&gt; after) 返回一个组合函数，首先将该函数应用于其输入，然后将 after函数应用于结果。 R apply(T t) 将此函数应用于给定的参数。 default &lt;V&gt; Function&lt;V,R&gt; compose(Function&lt;? super V,? extends T&gt; before) 返回一个组合函数，首先将 before函数应用于其输入，然后将此函数应用于结果。 static &lt;T&gt; Function&lt;T,T&gt; identity() 返回一个总是返回其输入参数的函数。 Stream流 类似于车间的生产线，可以更加方便的对集合或者数组中的元素进行操作 操作步骤 1、根据数据源（集合或者数组）生成Stream流对象 2、流操作（使用Stream接口中的方法） 如何将集合或者数组转为Stream流对象（集合/数组-&gt;Stream流） 单列集合通过Collection接口的默认方法stream()，比如： 123456//list List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Stream&lt;String&gt; listStream = list.stream(); //set Set&lt;String&gt; set = new HashSet&lt;String&gt;(); Stream&lt;String&gt; setStream = set.stream(); 双列集合不能直接转为Stream流对象，需要先转为单列集合，然后再调用stream()方法转为流对象，比如： 1234567Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;Integer&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream() 数组通过Stream接口的静态方法of(T… values)，比如： 1234 String[] strArray = &#123;"hello","world","java"&#125;; Stream&lt;String&gt; strArrayStream = Stream.of(strArray); 或者Stream&lt;String&gt; strArrayStream2 = Stream.of("hello", "world", "java"); Stream接口中的方法 12345678910111213141516延迟方法（中间操作）：如果一个方法的返回还是Stream流对象，则称之为延迟方法Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)：用于过滤流中不满足条件的数据Stream&lt;T&gt; limit(long n) :截取流中的前n个数据Stream&lt;T&gt; skip(long n)：跳过流中的前n个数据，截取剩余的数据public static &lt;T&gt; Stream&lt;T&gt; concat(Stream a, Stream b)：用于合并两个流Stream&lt;T&gt; distinct() ：将流中重复的元素去除Stream&lt;T&gt; sorted()：按照自然顺序对流中的数据进行排序Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator):按照指定的比较器规则对流中的数据进行排序&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) ：将流中的元素从一种类型转换为另一种类型的数据IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper) :将流中的数据转为int类型返回一个新的流（IntStream）&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector) ：将流中的数据收集到集合中终结方法（终结操作）：如果一个方法的返回不是Stream流对象，则称之为终结方法void forEach(Consumer&lt;? super T&gt; action) ：用于遍历流中的数据long count()：用于统计流中数据的个数 Stream流的收集（Stream流-&gt;集合/数组）收集到集合 收集到List集合 stream.collect(Collectors.toList()); 比如： List&lt;String&gt; names = listStream.collect(Collectors.toList()); 收集到Set集合 stream.collect(Collectors.toSet()); 比如： Set&lt;Integer&gt; ages = setStream.collect(Collectors.toSet()); 收集到Map集合 stream.collect(Collectors.toMap(Function fun1,Function fun2)); 比如： Map&lt;String, Integer&gt; map = arrayStream.collect(Collectors.toMap( s -&gt; s.split(&quot;,&quot;)[0], s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1]) ) ); 收集到数组 123456789Stream&lt;String&gt; stream = Stream.of("hello", "world", "java", "php", "mysql");// 只要后三个元素Stream&lt;String&gt; skipStream = stream.skip(2);//String[] strings = skipStream.toArray(length-&gt;new String[length]);String[] strings = skipStream.toArray(String[]::new);for (String s : strings) &#123; System.out.println(s);&#125; 类加载器类加载 类加载的描述 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化 类的加载 就是指将class文件读入内存，并为之创建一个 java.lang.Class 对象 任何类被使用时，系统都会为之建立一个 java.lang.Class 对象 类的连接 验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致 准备阶段：负责为类的类变量分配内存，并设置默认初始化值 解析阶段：将类的二进制数据中的符号引用替换为直接引用 类的初始化 在该阶段，主要就是对类变量进行初始化 类的初始化步骤 假如类还未被加载和连接，则程序先加载并连接该类 假如该类的直接父类还未被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 注意：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3 类的初始化时机 创建类的实例 调用类的类方法 访问类或者接口的类变量，或者为该类变量赋值 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 类加载器类加载器的作用 负责将.class文件加载到内存中，并为之生成对应的 java.lang.Class 对象。虽然我们不用过分关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行！ JVM的类加载机制 全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区 Java中的内置类加载器 Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为null ，并且没有父null Platform class loader：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类 System class loader：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap ClassLoader 中的两个方法 方法分类 方法名 说明 static ClassLoader getSystemClassLoader() 返回用于委派的系统类加载器 ClassLoader getParent() 返回父类加载器进行委派 示例代码 1234567891011121314public class ClassLoaderDemo &#123; public static void main(String[] args) &#123; //static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器 ClassLoader c = ClassLoader.getSystemClassLoader(); System.out.println(c); //AppClassLoader //ClassLoader getParent()：返回父类加载器进行委派 ClassLoader c2 = c.getParent(); System.out.println(c2); //PlatformClassLoader ClassLoader c3 = c2.getParent(); System.out.println(c3); //null &#125;&#125; 反射 概念 将类封装成一个Class对象，然后将类的各个组成部分也封装成对象，然后在运行阶段可以获取各个组成部分并且操作它们。 成员变量 -&gt; Filed类 构造方法 -&gt; Constructor类 成员方法 -&gt; Method类 反射称之为Java中的解剖学，反射相当于是对Java中的类进行解剖 获取Class对象 类名.class 比如：Class clazz = Student.class; 对象名.getClass() 比如：Class clazz = stu.getClass(); Class.forName(“全类名”) 比如：Class.forName(&quot;cn.skywalker.Student&quot;); 以上三种方式获取的字节码对象是同一个。 Class类 123456789101112131415 Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：获取指定参数的public修饰的构造方法 Constructor&lt;?&gt;[] getConstructors()：获取所有public修饰的构造方法 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) ：获取指定参数的构造方法，权限修饰符不限 Constructor&lt;?&gt;[] getDeclaredConstructors() ：获取所有的构造方法，权限修饰符不限T newInstance() ：使用空参构造创建对象 Field getField(String name) Field[] getFields() Field getDeclaredField(String name) Field[] getDeclaredFields() Method getMethod(String name, Class&lt;?&gt;... parameterTypes) Method[] getMethods() Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) Method[] getDeclaredMethods() Constructor类 如何获取 如何操作 public修饰的构造方法使用空参构造创建对象方式一：（1）获取字节码对象（Class对象）（2）调用Class类中的getConstructor()方法获取Constructor对象（3）调用Constructor类中的newInstance()方法创建对象 Class&lt;?&gt; c = Class.forName(“com.itheima_02.Student”);Constructor&lt;?&gt; con = c.getConstructor();Object obj = con.newInstance(); 方式二：（1）获取字节码对象（Class对象）（2）调用Class类中的newInstance()方法创建对象 Class&lt;?&gt; clazz = Class.forName(“com.myReflect.itheima_02.Student”); Object obj = clazz.newInstance(); 使用有参构造创建对象 （1）获取字节码对象（Class对象） （2）调用Class类中的getConstructor(参数类型)方法获取Constructor对象 （3）调用Constructor类中的newInstance(实参)方法创建对象 Class&lt;?&gt; c = Class.forName(“com.itheima_02.Student”);Constructor&lt;?&gt; con = c.getConstructor(String.class, int.class, String.class);Object obj = con.newInstance(“林青霞”, 30, “西安”); 非public修饰的构造方法（1）获取字节码对象（Class对象）（2）调用Class类中的getDeclaredConstructor(参数类型)方法获取Constructor对象（3）调用Constructor类中的setAccessible(true)方法（4）调用Constructor类中的newInstance(实参)方法创建对象 ​ Filed类 如何获取 如何操作 1、获取Class对象 2、使用Class类中的getField(String name)获取指定的成员变量的Field对象 3、反射创建对象 4、调用Field类中的set给指定对象的该成员变量赋指定的值 模块化 在不同模块之间建立模块依赖关系，可以使用不同模块的资源。 使用不同模块的类： exports 包名; requires 模块名; 使用不同模块提供的接口（包含实现类，主要思想是面向接口编程）服务： 提供服务端： exports 接口所在的包; provides 接口名 with 实现类名; 使用服务端： uses 接口名;（使用编译器会自动帮你导包） 注解概念注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 作用 说明程序的，给计算机看的 携带数据取代部分xml（框架用的东西！） 编译检查。例如： @Override @FunctionalInterface 等等 JDK中预定义的一些注解 @Override：检测被该注解标注的方法是否是继承自父类(接口)的 @Deprecated：该注解标注的内容，表示已过时 @SuppressWarnings：压制警告（一般传递参数all @SuppressWarnings(“all”)） 等等 自定义注解1234567891011121314151617//定义一个类:public class 类名&#123; 成员变量 成员方法 构造函数&#125;//定义一个接口：public interface 接口名&#123; 常量 抽象方法&#125;//定义一个注解：public @interface 注解名&#123; //原来你的本质是接口 抽象方法&#125; 格式： 12345元注解public @interface 注解名称&#123; 属性列表;(抽象方法) public abstract 数据类型 方法名();&#125; 本质：注解本质上就是一个接口，该接口默认继承Annotation接口。public interface MyAnno extends java.lang.annotation.Annotation {} 属性：接口中的抽象方法 要求： 抽象方法的返回值类型有下列取值 12345基本数据类型String枚举注解以上类型的一维数组 定义了属性，在使用时需要给属性赋值 1231. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。3. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略 元注解：用于描述注解的注解 12345678910111213141516171819202122@Target：描述注解能够作用的位置/* 默认:如果你不写, 你的注解默认可以加在任何地方!!!! ElementType取值： TYPE：可以作用于类上 METHOD：可以作用于方法上 FIELD：可以作用于成员变量上*/ @Retention：描述注解被保留的阶段 /* 如果你不写, 你的注解只有在"源码"中有效。 例如：@Retention(RetentionPolicy.RUNTIME) 当前被描述的注解，会保留到class字节码文件中，并被JVM读取到*/@Documented：描述注解是否被抽取到api文档中@Inherited：描述注解是否被子类继承 解析注解 在程序使用(解析)注解：获取注解中定义的属性值, 必须通过反射才可以获取注解 步骤： 获取注解定义的位置的对象 （Class，Method,Field） 获取指定的注解,通过反射的三大对象(Field(字段),Method(方法),Class(类上)), 调用以下两个api可以获取和判断 123456789101112131415//第一个Annotation getAnnotation(注解的字节码Class) //获取身上的注解//其实就是在内存中生成了一个该注解接口的子类实现对象public class ProImpl implements Pro&#123; public String className()&#123; return "cn.itcast.annotation.Demo1"; &#125; public String methodName()&#123; return "show"; &#125;&#125;//第二个boolean isAnnotationPresent(注解.class); //判断注解是否存在 调用注解中的抽象方法获取配置的属性值]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2Fmarkdown%2F9999_markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 再一次感谢您花费时间阅读，祝您在这里记录、阅读、分享愉快！]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>-markdown -笔记 -工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML/CSS]]></title>
    <url>%2FHTML-CSS%2F05_HTML-CSS%2F</url>
    <content type="text"><![CDATA[软件架构 C/S（Client/Server）：客户端/服务器端 在用户本地有一个客户端程序，在远程有一个服务器端程序 如：QQ，迅雷… 优点 用户体验好 缺点 开发、安装、部署、维护麻烦 B/S（Browser/Server）：浏览器/服务器端 只需要一个浏览器，用户通过不同的网址（URL），客户访问不同的服务器端程序 优点 开发、安装、部署、维护简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高 B/S架构详解 资源分类： 静态资源 使用静态网页开发技术发布的资源。 特点： 所有用户访问，得到的结果是一样的。 如：文本，图片，音频，视频，HTML，CSS，JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源 动态资源 使用动态网页及时发布的资源。 特点： 所有用户访问，得到的结果可能不一样 如：jsp/servlet，php，asp… 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 我们要学习动态资源，必须先学习静态资源！ 静态资源： HTML：用于搭建基础网页，展示页面的内容 CSS：用于美化页面，布局页面 JavaScript：控制页面的元素，让页面有一些动态的效果 HTML 概念：是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本：超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. 标记语言： 由标签构成的语言。&lt;标签名称&gt; 如 html，xml 标记语言不是编程语言 快速入门： 语法： html文档后缀名 .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写。 代码： 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 文本标签1234567891011121314&lt;em&gt;&lt;/em&gt;表示语义上的强调（自动斜体）&lt;strong&gt;&lt;/strong&gt;表示内容上的强调（自动加粗）&lt;i&gt;&lt;/i&gt;i标签的内容会以斜体显示&lt;b&gt;&lt;/b&gt;b标签的内容会以加粗显示&lt;small&gt;&lt;/small&gt;内容以细小的字体显示&lt;cite&gt;&lt;/cite&gt;引用（加书名号的）&lt;q&gt;&lt;/q&gt;行引用&lt;blockquote&gt;&lt;/blockquote&gt;块儿引用&lt;sup&gt;&lt;/sup&gt;上标&lt;sub&gt;&lt;/sub&gt;下标&lt;del&gt;&lt;/del&gt;删除线&lt;ins&gt;&lt;/ins&gt;插入内容&lt;pre&gt;&lt;/pre&gt;预格式&lt;code&gt;&lt;/code&gt;代码块（一般和pre标签一起使用） 图片标签 img标签：展示图片 属性： src：指定图片的位置 代码： 1234567891011121314&lt;!--展示一张图片 img--&gt;&lt;img src="image/pic1.jpg" align="right" alt="图片1" width="500" height="500"/&gt;&lt;!-- 相对路径 * 以.开头的路径 * ./：代表当前目录 ./image/1.jpg * ../:代表上一级目录--&gt;&lt;img src="./image/pic1.jpg"&gt;&lt;img src="../image/pic2.jpg"&gt; 列表标签 有序列表： ol li 无序列表： ul li 代码： 1234567891011121314151617&lt;!--有序列表 ol--&gt;早上起床干的事情&lt;ol type="A" start="5"&gt; &lt;li&gt;睁眼&lt;/li&gt; &lt;li&gt;看手机&lt;/li&gt; &lt;li&gt;穿衣服&lt;/li&gt; &lt;li&gt;洗漱&lt;/li&gt;&lt;/ol&gt;&lt;!-- 无序列表 ul--&gt;早上起床干的事情&lt;ul type="disc"&gt; &lt;li&gt;睁眼&lt;/li&gt; &lt;li&gt;看手机&lt;/li&gt; &lt;li&gt;穿衣服&lt;/li&gt; &lt;li&gt;洗漱&lt;/li&gt;&lt;/ul&gt; 链接标签 a标签：定义一个超链接 属性： href：指定访问资源的URL(统一资源定位符) href是Hypertext Reference的缩写。意思是指定超链接目标的URL。是css代码的一种。href 属性的值可以是任何有效文档的相对或绝对URL，包括片段标识符和JavaScript代码段。 target：指定打开资源的方式 _self:默认值，在当前页面打开 _blank：在空白页面打开 代码： 1234567891011121314151617&lt;!--超链接 a--&gt;&lt;a href="http://www.skywalkerkkkk.cn"&gt;点我&lt;/a&gt;&lt;br&gt;&lt;a href="http://www.skywalkerkkkk.cn" target="_self"&gt;点我&lt;/a&gt;&lt;br&gt;&lt;a href="http://www.skywalkerkkkk.cn" target="_blank"&gt;点我&lt;/a&gt;&lt;br&gt;&lt;!-- 也可以跳转至项目内的页面 --&gt;&lt;a href="./anotherPage.html"&gt;点我跳转&lt;/a&gt;&lt;br&gt;&lt;a href="mailto:skywalkerkkkk@skywalkerkkkk.cn"&gt;联系我们&lt;/a&gt;&lt;br&gt;&lt;a href="http://www.skywalkerkkkk.cn"&gt;&lt;img src="image/pic1.jpg"&gt;&lt;/a&gt; 语义化标签 html5中为了提高程序的可读性，提供了一些标签。 &lt;header&gt;：页眉 &lt;footer&gt;：页脚 表格标签 table：定义表格 width：宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条 bgcolor：背景色 align：对齐方式 tr：定义行 bgcolor：背景色 align：对齐方式 td：定义单元格 colspan：合并列 rowspan：合并行 th：定义表头单元格 &lt;caption&gt;：表格标题 &lt;thead&gt;：表示表格的头部分 &lt;tbody&gt;：表示表格的体部分 &lt;tfoot&gt;：表示表格的脚部分 表单标签 概念：用于采集用户输入的数据的。用于和服务器进行交互。 form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 属性： action：指定提交数据的URL method:指定提交方式 分类：一共7种，2种比较常用 get： 请求参数会在地址栏中显示。会封装到请求行中。 请求参数大小是有限制的。 不太安全。 post： 请求参数不会再地址栏中显示。会封装在请求体中。 请求参数的大小没有限制。 较为安全。 表单项中的数据要想被提交：必须指定其name属性 表单项标签 input：可以通过type属性值，改变元素展示的样式 type属性： text：文本输入框，默认值 placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 password：密码输入框 radio:单选框 注意： 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 checkbox：复选框 注意： 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息。 按钮： submit：提交按钮。可以提交表单 button：普通按钮 image：图片提交按钮 src属性指定图片的路径 label：指定输入项的文字描述信息 注意： label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 select: 下拉列表 子元素：option，指定列表项 textarea：文本域 cols：指定列数，每一行有多少个字符 rows：默认多少行。 外部样式表格式1&lt;link rel = "stylesheet" type = "text/css" href = "css文件路径" /&gt; CSS 概念：CSS（Cascading Style Sheet，层叠样式表）。将多个样式叠加作用在HTML元素上面，可以同时起效果，让页面更加好看。 好处： 降低CSS样式和HTML元素的耦合度，将这两部分进行了分离 功能更加强大 CSS和HTML的3种结合方式： 内联样式 内部样式 外部样式 内联样式 在HTML标签内使用style属性，在属性值内编写CSS代码。 缺点： CSS代码和HTML代码耦合在一起，并没有做到分离 作用范围太小，只能作用在该标签上 内部样式 在HTML页面的head标签内定义一个style标签在style标签体中定义CSS代码。 代码： 1234567&lt;style&gt; 选择器｛ 属性名1:属性值1; 属性名2:属性值2; 属性名3:属性值3; ｝&lt;/style&gt; 缺点： 只能在本HTML页面内起效果，出了该页面无法起效果 外部样式 在外部定义一个CSS文件，在文件中编写CSS代码 在HTML页面中如何使用外部样式： 使用link标签 1&lt;link rel = "stylesheet" type = "text/css" href = "css文件路径" /&gt; 在style标签中引入 123&lt;style&gt; @import 关联css文件的路径;&lt;/style&gt; CSS语法 格式： 12345选择器 &#123; 属性名1:属性值1; 属性名2:属性值2; ...&#125; 选择器:筛选具有相似特征的元素 注意：每一对属性需要使用；隔开，最后一对属性可以不加分号 选择器 概念：筛选具有相似特征的元素 分类： 基础选择器 id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 语法：#id属性值{} 元素选择器：选择具有相同标签名称的元素 语法： 标签名称{} 类选择器：选择具有相同的class属性值的元素。 语法：.class属性值{} 优先级关系：id选择器 &gt; 类选择器 &gt; 元素选择器 扩展选择器 选择所有元素 语法： *{} 并集选择器 选择器1,选择器2{} 后代选择器：筛选选择器1元素下的选择器2元素 语法： 选择器1 选择器2{} 子选择器：筛选选择器2的父元素选择器1 语法： 选择器1 &gt; 选择器2{} 属性选择器：选择元素名称，属性名=属性值的元素 语法： 元素名称[属性名=”属性值”]{} 元素状态选择器（伪类选择器） 语法： 元素:状态{} 如：&lt;a&gt; 状态： link：初始化的状态 visited：被访问过的状态 active：正在访问状态 hover：鼠标悬浮状态 属性 字体、文本 font-size：字体大小 color：文本颜色 text-align：对齐方式 line-height：行高 背景 background 边框 border：设置边框，符合属性 尺寸 width：宽度 height：高度 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况下内边距会影响整个盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 float：浮动 left right 案例：注册页面 html页面代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;link rel="stylesheet" href="../../css/register.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="rg_layout"&gt; &lt;div class="rg_left"&gt; &lt;p&gt;新用户注册&lt;/p&gt; &lt;p&gt;USER REGISTER&lt;/p&gt; &lt;/div&gt; &lt;div class="rg_middle"&gt; &lt;form action="#" method="post"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="username"&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="text" id="username" name="username" placeholder="请输入用户名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="password"&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="password" id="password" name="password" placeholder="请输入密码"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="email"&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="email" id="email" name="email" placeholder="请输入邮箱"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="name"&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="text" id="name" name="name" placeholder="请输入真实姓名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="tel"&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="tel" id="tel" name="tel" placeholder="请输入您的手机号"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt; &lt;input type="radio" name="gender" value="male" checked&gt;男 &lt;input type="radio" name="gender" value="female"&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="birthday"&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt;&lt;input type="date" id="birthday" name="birthday"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="left_side"&gt;&lt;label for="verify_code"&gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class="right_side"&gt; &lt;input type="img" id="verify_code" name="verify_code"&gt; &lt;img src="../../img/verify_code.jpg" id="img_check"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" align="center"&gt;&lt;input type="submit" id="sub" name="sub" value="注册"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class="rg_right"&gt; &lt;p&gt;已有账号？&lt;a href="#"&gt;立即登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css样式表代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697* &#123; padding: 0px; margin: 0px; box-sizing: content-box;&#125;body &#123; background: url("../img/register_bg.png") no-repeat; background-size: cover; padding-top: 5%;&#125;.rg_layout &#123; /*让div水平居中*/ margin: auto; width: 1000px; height: 650px; border: 8px solid rgb(238, 238, 238); background-color: white;&#125;.rg_left p:first-child &#123; color: rgb(255, 225, 128); font-size: 25px;&#125;.rg_left p:last-child &#123; color: rgb(168, 172, 191); font-size: 25px;&#125;.rg_left &#123; float: left; margin: 30px;&#125;.left_side &#123; text-align: right; width: 100px; height: 60px; color: rgb(185, 185, 185); font-size: 20px;&#125;.right_side &#123; padding-left: 50px;&#125;#username, #password, #email, #name, #tel, #birthday, #verify_code &#123; border-radius: 5px; border: 1px rgb(221, 221, 221) solid; height: 5px; width: 270px; font-size: 17px; padding: 15px;&#125;#verify_code &#123; width: 130px;&#125;#img_check &#123; vertical-align: middle; height: 30px; padding-left: 20px;&#125;#sub&#123; background-color: rgb(255, 222, 101); width: 150px; height: 40px; border: 0px; font-size: 15px;&#125;.rg_middle &#123; /*border: 1px solid red;*/ float: left; margin: 30px; width: 48%;&#125;.rg_right p a &#123; color: rgb(253, 185, 178);&#125;.rg_right &#123; float: right; margin: 30px;&#125; 效果图：]]></content>
      <categories>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>-HTML -CSS -H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb]]></title>
    <url>%2FJava%2F09_JavaWeb%2F</url>
    <content type="text"><![CDATA[.imp{ color:red; } Web相关概念 软件架构 C/S架构：客户端/服务器端 B/S架构：浏览器端/服务器端 资源分类 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析，如：HTML，CSS，JavaScript等。 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，再返回给浏览器，如：servlet，jsp，php，asp等。 网络通信三要素 IP：电子设备(计算机)在网络中的唯一标识。 端口：应用程序在计算机中的唯一标识。 0~65535 传输协议：规定了数据传输的规则 TCP：安全协议，三次握手。 速度稍慢 UDP：不安全协议。 速度快 JavaEE Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Web服务器软件 服务器：安装了服务器软件的计算机 服务器软件：接收用户的请求，处理请求，做出响应 Web服务器软件：接收用户的请求，处理请求，做出响应 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 web容器 常见的java相关的web服务器软件： webLogic： oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 webSphere： IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat： Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 Tomcat 概念：Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。 Tomcat的安装和启动以及常见问题安装 下载：http://tomcat.apache.org/ 安装：解压压缩包即可。 注意：安装目录建议不要有中文和空格 卸载 删除目录就行了 启动 安装目录/bin/startup.bat,双击运行该文件即可 访问： 在浏览器中输入http://localhost:8080地址访问自己的Tomcat服务器 在浏览器中输入http://别人的IP:别人的Tomcat端口号，就可以访问别人的Tomcat服务器 常见问题 黑窗口一闪而过 原因： 没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量 启动报错 原因：Tomcat所使用的端口被占用。 解决方案： 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程netstat -ano 温柔：修改自身的端口号 conf/server.xml &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。好处：在访问时，就不用输入端口号了 关闭 正常关闭 bin/shutdown.bat ctrl + c 强制关闭 点击服务器黑窗口右上角的x直接关闭 任务管理器 Tomcat常见发布项目的方式 部署项目的方式： 直接将项目放到webapps目录下即可。 /hello：项目的访问路径–&gt;虚拟目录 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。war包会自动解压缩 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt; docBase：项目存放的路径 path：虚拟目录 在tomcat安装目录的conf\Catalina\localhost创建任意名称的xml文件。内容：&lt;Context docBase=&quot;D:\hello&quot; /&gt; 虚拟目录：xml文件的名称 将Tomcat配置到idea中 Tomcat与idea的相关配置 IDEA会为每一个tomcat部署的项目单独建立一份配置文件 查看控制台输出的日志信息：Using CATALINA_BASE: “C:\Users\SkyWalker.IntelliJIdea2018.3\system\tomcat_JavaWeb” 工作空间项目（src源代码目录） 和 tomcat部署的web项目（out字节码文件输出目录） tomcat真正访问的是“tomcat部署的web项目”，”tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源 WEB-INF目录下的资源不能被浏览器直接访问 断点调试：使用”小虫子”启动 dubug 启动 动态Web项目的目录结构12345|-- 项目的根目录 |--- WEB-INF目录 |----- web.xml：web项目的核心配置文件 |----- classes目录：放置字节码文件的目录 |----- lib目录：放置依赖的jar包 HTTP概念HTTP：Hyper Text Transfer Protocol 超文本传输协议。 传输协议：定义了，客户端和服务器端通信时，发送数据的格式。 特点 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的:一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本 1.0：每一次请求响应都会建立新的连接 1.1：复用连接 请求请求的消息数据格式： 请求行 格式：请求方式 请求url 请求协议/版本 比如：GET /login.html HTTP/1.1 请求方式：HTTP协议有7中请求方式，常用的有2种 Get 请求参数在请求行中，在url后。 请求的url长度有限制的 不太安全 Post 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求头 客户端浏览器告诉服务器一些信息 格式：请求头名称: 请求头值 常见的请求头： User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：http://localhost/login.html 告诉服务器，我(当前请求)从哪里来？作用：防盗链 统计工作 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 请求体 封装POST请求消息的请求参数的 123456789101112字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan 响应响应消息数据格式： 12345678910111213HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; 响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 响应状态码： 状态码都是3位数字 分类： 1xx：服务器就收客户端消息，但没有接收完成，等待一段时间后，发送1xx多状态码 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误。代表：404（请求路径没有对应的资源），405：(请求方式没有对应的doXxx方法) 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：头名称： 值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 值： in-line:默认值,在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行 空行，就是用于分割响应头，和响应体的。 响应体 传输的数据 Servlet 概念：Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态Web内容。 本质：Servlet的本质就是一个接口，我们想要处理逻辑的代码， 必须遵循Servlet的规范，写的代码不是我们自己调用的，而是Tomcat调用的，所以我们得让Tomcat认识我们的代码。 Servlet入门 定义一个类实现Servlet的接口 重写里面的所有的抽象方法 在service方法中编写逻辑 在web.xml中配置(或者使用注解配置) 12345678&lt;servlet&gt; &lt;servlet-name&gt;skywalker&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.skywalker.web.servlet.DemoServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;skywalker&lt;/servlet-name&gt; &lt;url-pattern&gt;/skywalker&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; XML和注解方式的原理 虚拟路径 Servlet的执行原理 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容 如果有，则在找到对应的&lt;servlet-class&gt;全类名 Tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 Servlet的生命周期 被创建：执行init方法，只执行一次 Servlet什么时候被创建？ 默认情况下，第一次被访问时，Servlet被创建 可以配置执行Servlet的创建时机。 12345在&lt;servlet&gt;标签下配置：1. 第一次被访问时，创建 &lt;load-on-startup&gt;的值为负数2. 在服务器启动时，创建 &lt;load-on-startup&gt;的值为0或正整数 Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 多个用户同时访问时，可能存在线程安全问题。 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 提供服务：执行service方法，执行多次 每次访问Servlet时，Service方法都会被调用一次。 被销毁：执行destroy方法，只执行一次 Servlet被销毁时执行。服务器关闭时，Servlet被销毁 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 3.0后的注解编写Servlet 好处：支持注解配置。可以不需要web.xml了。 步骤： 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 12345678910111213141516171819202122232425262728@WebServlet("资源路径")//此注解加在Servlet类前，即可完成对Servlet的配置。相当方便。//附上WebServlet注解的源码@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet &#123; String name() default "";//相当于&lt;Servlet-name&gt; String[] value() default &#123;&#125;;//代表urlPatterns()属性配置 String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default &#123;&#125;; boolean asyncSupported() default false; String smallIcon() default ""; String largeIcon() default ""; String description() default ""; String displayName() default "";&#125; Servlet的体系结构123|-- Servlet |---- GenericServlet |------ HttpServlet GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 HttpServlet：对http协议的一种封装，简化操作 定义类继承HttpServlet 复写doGet/doPost方法 Servlet相关配置 urlpartten:Servlet访问路径 一个Servlet可以定义多个访问路径 ： @WebServlet({“/d4”,”/dd4”,”/ddd4”}) 路径定义规则： /xxx：路径匹配 /xxx/xxx:多层路径，目录结构 *.do：扩展名匹配 Requestrequest对象和response对象的原理 request和response对象是由服务器创建的。我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 request对象继承体系结构123|-- ServletRequest |---- HttpServletRequest |------ org.apache.catalina.connector.RequestFacade 类(tomcat) request功能 获取请求消息数据 获取请求行数据 请求行的数据：GET /day14/demo1?name=zhangsan HTTP/1.1 方法： 获取请求方式 ：GETString getMethod() 获取虚拟目录：/demo1String getContextPath() 获取Servlet路径: /servlet1 String getServletPath() 获取get方式请求参数：name=zhangsanString getQueryString() 获取请求URI：/skywalker/demo1 123456String getRequestURI(): /skywalker/demo1StringBuffer getRequestURL():http://localhost/skywalker/demo1URI:统一资源标识符: /skywalker/demo1 冠军URL:统一资源定位符：http://localhost/skywalker/demo1 省冠军 获取协议及版本：HTTP/1.1String getProtocol() 获取客户机的IP地址：String getRemoteAddr() 获取请求头数据 方法： String getHeader(String name)：通过请求头的名称获取请求头的值 Enumeration&lt;String&gt; getHeaderNames()：获取所有的请求头名称 获取请求体数据 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 再从流对象中拿数据 其他功能 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 Modifier and Type Method and Description String getParameter(String name) 根据参数名称获取参数值 String[] getParameterValues(String name) 根据参数名称获取参数值的数组 Enumeration&lt;String&gt; getParameterNames() 获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap() 获取所有参数的map集合 中文乱码问题： - get方式：tomcat 8 已经将get方式乱码问题解决了 - post方式：会乱码 解决：在获取参数前，设置request的编码`request.setCharacterEncoding(&quot;utf-8&quot;);` 请求转发：一种在服务器内部的资源跳转方式 步骤： 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 特点： 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中 转发是一次请求 共享数据： 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： Modifier and Type Method and Description void setAttribute(String name,Object obj) 设置属性 Object getAttitude(String name) 获取属性 void removeAttribute(String name) 移除属性 获取ServletContextServletContext getServletContext() Response 与Request对象类似，使用实现了HttpServletResponse接口的response对象 功能：设置响应消息 设置响应行 格式：HTTP/1.1 200 ok 设置状态码：setStatus(int sc) 设置响应头setHeader(String name, String value) 设置响应体步骤： 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 如果不设置响应格式，中文会乱码 乱码解决方案设置request的编码格式：解决post请求中文乱码12HttpServletResponse request = new HttpServletRequest();request.setCharacterEncoding("utf-8"); 设置响应格式：解决响应中文乱码123HttpServletResponse response = new HttpServletResponse();response.setContentType("application/msword");//设置响应类型为word文档。//具体可以在tomcat/config/web.xml中查找需要格式对应的值 常见的媒体格式类型如下： ​ text/html ： HTML格式 ​ text/plain ：纯文本格式 ​ text/xml ： XML格式 ​ image/gif ：gif图片格式 ​ image/jpeg ：jpg图片格式 ​ image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml ： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json ： JSON数据格式 application/pdf ：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ：&lt;form encType=&quot;&quot;&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： ​ multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 转发和重定向的区别请求的转发 是由request请求发出的 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 “ / ” 代表的是当前Web应用（localhost:port/WebApps）的根目录 请求的重定向 是由response响应发出的 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 “ / ” 代表的是当前Web站点（localhost:port）的根目录 相对路径与绝对路径 *相对路径 通过相对路径不可以确定唯一资源 12345678910/* 规则：找到当前资源和目标资源之间的相对位置关系 ./ ： 代表当前目录 ../ ： 代表上一级目录 例如： ./index.html tip：html+异步请求会使用.*/ 绝对路径 通过绝对路径可以确定唯一资源 12345678910/* 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 1.给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * 常用位置：&lt;a&gt;，&lt;form&gt;，重定向... 2.给服务器使用：不需要加虚拟目录 * 转发路径 tip：jsp建议使用.*/ ServletContext对象 代表整个web应用，可以和程序的容器(服务器)来通信 获取 通过request对象获取：request.getServletContext(); 通过HttpServlet获取：this.getServletContext(); 功能 获取MIME类型 MIME类型:在互联网通信过程中定义的一种文件数据类型 格式： 大类型/小类型 text/html image/jpeg 域对象：共享数据 ServletContext对象范围：所有用户所有请求的数据 getAttribute(String name) setAttribute(String name,Object value) removeAttribute(String name) 获取文件的真实(服务器)路径 方法：String getRealPath(String path) 12345678910//获取真实路径例子：String b = context.getRealPath("/b.txt");//web目录下资源访问System.out.println(b);String c = context.getRealPath("/WEB-INF/c.txt");//WEB-INF目录下的资源访问System.out.println(c);String a = context.getRealPath("/WEB-INF/classes/a.txt");//src目录下的资源访问System.out.println(a); 会话技术Cookie &amp; Session 会话：用户打开浏览器，不断的访问，最后关闭浏览器的过程，称为一次会话(一次会话可以产生多次请求和响应)。 作用：在一次会话中的多次请求和响应间”共享数据” —-&gt;存数据,取数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie 客户端会话技术，将数据保存到客户端 使用步骤 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 Cookie细节 一次可不可以发送多个cookie? 1234/* 1. 可以 2. 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。*/ cookie在浏览器中保存多长时间？ 1234567/* - 默认情况下，当浏览器关闭后，Cookie数据被销毁 - 持久化存储：setMaxAge(int seconds) 1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 2. 负数：默认值 3. 零：删除cookie信息*/ cookie能不能存中文？ 12345/* 1. 在tomcat 8 之前 cookie中不能直接存储中文数据。 - 需要将中文数据转码---一般采用URL编码(%E3) 2. 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析*/ cookie共享问题？ 123456789/* 1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ - 默认情况下cookie不能共享 - setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录。 - 如果要共享，则可以将path设置为"/" 2. 不同的tomcat服务器间cookie共享问题？ - setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 - setDomain(".baidu.com"),那么tieba.baidu.com和news.baidu.com中cookie可以共享*/ Cookie的特点和作用 特点： cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 Session 服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 使用步骤 获取HttpSession对象： HttpSession session = request.getSession(); 使用HttpSession对象： 123Object getAttribute(String name) void setAttribute(String name, Object value)void removeAttribute(String name) 实现原理Session的实现是依赖于Cookie的。 第一次获取Session，没有Cookie，会在服务器内存中创建一个新的Session对象 将JSESSIONID放到响应头set-cookie中 等下一次访问的时候，请求头中的cookie会带有JSESSIONID 服务器会根据JSESSIONID去内存中查找session对象 Session细节 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ 12345678910111213//默认情况下。不是。//如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。Cookie c = new Cookie("JSESSIONID",session.getId());c.setMaxAge(60*60);response.addCookie(c);//--------------------------------------------------------------------------//关于Session的一个面试题 /* session的默认失效时间是一次会话? 答案：错误。session并没有失效,只是jsessionid的cookie不见了 */ 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 1234//不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作//session的钝化：在服务器正常关闭之前，将session对象系列化到硬盘上//session的活化：在服务器启动后，将session文件转化为内存中的session对象即可。 session什么时候被销毁？ 123456789&lt;!-- 1.服务器关闭 2. session对象调用invalidate() 。 3. session默认失效时间 30分钟 选择性配置修改 --&gt;&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; Session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 Session与Cookie的区别 session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全 JSP JSP（Java Server Pages）： Java服务器端页面 JSP运行原理 JSP是简Servlet编写的一种技术，他将Java代码和HTML语句混合在同一个文件中编写。只对网页中的要动态产生的内容才用Java代码来编写，而对固定不变的静态内容才用普通静态HTML页面的方式编写。 JSP继承了HttpJspBase类，而HttpJspBase又继承了HttpServlet，即jsp间接继承了HttpServlet，即JSP本质上就是一个Servlet。 JSP中如何定义Java代码12345678910111213141516171819202122232425262728293031323334353637&lt;% %&gt;: 定义的代码在service方法里面&lt;%! %&gt;:定义的代码在成员区域 -----&gt;因为servlet中不要定义成员变量&lt;%= %&gt; :在out.print()的小括号中//常见的面试题 1. &lt;% private int age;%&gt; //典型错误:因为&lt;%%&gt;在service方法里面, 我们变量不能加修饰符. 2. &lt;%int age;%&gt; &lt;%sout(age);%&gt; //典型错误:因为&lt;%%&gt;在service方法里面,方法中变量没有默认值, 不赋值不能使用 3. &lt;%!int age;%&gt; &lt;%sout(age);%&gt; //正确 4. &lt;%!int age = 3;%&gt; &lt;%int age = 4;%&gt; &lt;%sout(age);%&gt; //结果:4, 原因service方法里面有就近原则 &lt;%!int age = 3;%&gt; &lt;%int age = 4;%&gt; &lt;%sout(this.age);%&gt; //结果:3, 原因this找的是成员变量 5. &lt;% int age = 10;%&gt; &lt;%=age;%&gt; //典型错误:因为&lt;%=%&gt;是在print()小括号中, 不能加;号 6. &lt;% public void aa()&#123; &#125; %&gt; //典型错误: 方法中不能再定义方法 JSP八大内置对象（实际上9个） 类名 对象实例名（可直接调用） HttpServletRequest request HttpServletResoponse response PageContext pageContext HttpSession session ServletContext application ServletConfig config JspWriter out Object page Exception exception request：HttpServletRequest的一个对象。 response：HttpServletResponse的一个对象（在JSP页面中几乎不会调用response的任何方法）。 pageContext：页面的上下文，是PageContext的一个对象。可以从该对象中获取到其他8个隐含对象。亦可以从中获取到当前页面的其他信息。（学习自定义标签时使用他。在JSP页面上很少直接使用他。） session：代表浏览器和服务器的一次会话，是HttpSession的一个对象。 application：代表当前Web应用。是ServletContext的一个对象。（可以获取初始化参数等。） config：当前JSP对应的Servlet的ServletConfig对象。（开发时几乎不使用。若需要访问当前JSP配置的初始化参数，需要通过映射的地址才可以。） out：JspWriter对象。调用out.println()可以直接把字符串打印到浏览器上。（在两次out.println()时，中间不会换行，需要添加HTML的换行标签&lt;br>。） page：指向当前JSP对应的Servlet对象的引用，但为Object类型，只能调用Object类的方法（几乎不使用。） exception：一定的条件下才可以用。（只有主动声明了isErrorPage=”true”的时候，才可以使用。） 标红均为开发时常用对象。 pageContext，request，session，application对属性的作用域范围从小到大。 JSP表达式​ JSP表达式（expression）提供了将一个java变量或表达式的计算结果输出到客户端的简化方式，他将要输出的变量或表达式直接封装在&lt;%= 和 %&gt;中。 JSP注释的格式：&lt;%– JSP注释 –%&gt; HTML注释的格式：&lt;!– HTML注释 –> 区别 : ​ JSP注释可以阻止Java代码的执行，而HTML注释surround with &lt;% Java代码 %&gt;时，不能阻止Java代码的执行。 域对象的属性操作 和属性相关的方法： Object getAttribute(String name)：获取指定的属性 Enumeration getAttributeNames()：获取所有的属性的名字组成的Enumeration对象 void removeAttribute(String name)：移除指定的属性 void setAttribute(String name, Object obj)：设置属性 域对象： pageContext request response application 作用范围 pageContext：属性的作用范围仅限于当前JSP页面。（在Servlet中无法得到pageContext对象。） request：属性的作用范围仅限于同一个请求。 session：属性的作用范围限于一次会话。（会话：浏览器打开直到关闭称之为一次会话。（会话在此期间不失效的情况下。）） application：属性的作用范围限于当前Web应用。是范围最大的属性作用范围，只要在一处设置属性，在其他各处的JSP或Servlet中都可以获取到。 JSP指令 include 用于通知JSP引擎在翻译当前JSP页面时将其他文件中的内容合并进当前JSP页面转换成的Servlet源文件中，这种在源文件级别进行引入的方式称之为静态引入，当前JSP页面与静态引入的页面紧密结合为一个Servlet。 file属性的设置值必须使用相对路径。 如果以“ / ”开头，表示相对于当前Web应用程序的根目录（注意不是站点根目录），否则，表示相对于当前文件。 page page指令用于定义JSP页面的各种属性，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面，为了保持程序的可读性和遵循良好的变成习惯，page指令最好是放在整个JSP页面的起始位置。 page指令常用的属性： import属性：指定当前JSP页面对应的Servlet需要导入的类。&lt;%@page import=”全类名”%&gt; session属性：取值为true或false，指定当前页面的session隐藏变量是否可用，也可以说访问当前页面时，是否一定要生成HttpSession对象。 errorPage和isErrorPage：前者表示指定若当前页面出现错误的实际响应页面是什么，其中“ / ” 表示的是当前Web应用的根目录。后者表示指定当前页面是否为错误处理页面，可以说明当前页面是否可以使用exception隐藏内置对象。 需要注意的是：若指定isErrorPage=”true”，并使用exception的方法了，一般不建议能够直接访问该页面。 contentType：指定当前JSP页面的响应类型。实际调用的是response.setContentType(“text/html;charset=UTF-8”);通常情况下，对于JSP页面而言其取值均为 text/html; charset=UTF-8 pageEncoding：指定当前JSP页面的字符编码。通常情况下该值和contentType中的charset一致。 isELIgnored：指定当前JSP页面是否可以使用EL表达式。通常取值为true。 如何使客户不能直接访问一个页面呢？ 12345678910111213141516&lt;!-- 1. 对于Tomcat服务器而言，WEB-INF下的文件是不能通过在浏览器中直接输入来访问的。但通过请求的转发是可以访问的！ 2. 还可以在web.xml文件中配置错误页面。--&gt;&lt;!-- 方式1.指定出错的代码，404没有指定资源，500内部错误。 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;!-- 指定响应页面的位置 --&gt;&lt;/error-page&gt;&lt;!-- 方式2.指定异常的类型 --&gt;&lt;error-page&gt; &lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;!-- 指定响应页面的位置 --&gt;&lt;/error-page&gt; taglib 导入资源 12&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;!-- prefix：前缀，自定义的 --&gt; JSP标签 jsp:include标签： &lt;jsp:include page = &quot;path&quot;&gt; &lt;/jsp:include&gt; 动态引入：并不是像include指令生成一个Servlet源文件，而是生成两个Servlet源文件，然后通过一个方法的方式把目标页面包含进来。org.apache.jasper.runtime.JspRuntimeLibrary.include(request,response,&quot;path&quot;,out,false); include指令和jsp:include标签： 是在当前JSP页面的执行期间插入被引入资源的输出内容。 被动态引入的资源必须是一个能独立被Web容器调用和执行的资源。 include指令只能引入遵循JSP格式的文件，被引入文件与当前JSP文件共同合被翻译成一个Servlet源文件。 jsp:forward标签： &lt;jsp:forward page = &quot;path&quot;&gt;&lt;/jsp:forward&gt; 相当于request.getRequestDispatcher(&quot;path&quot;).forward(request,response); 但使用jsp:forward可以使用jsp:param子标签向path传入一些参数，同样jsp:include也可以使用jsp:param子标签。 中文乱码核心思路：编码格式 = 解码格式即可解决乱码问题。 MVC设计模式MVC即Model-View-Controller。模型-视图-控制器。 JSP演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来有jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 模型（Model） JavaBean 模型是应用程序的主体部分。模型表示业务数据和业务逻辑，完成具体的业务操作，如：查询数据库，封装对象 一个模型能为多个视图提供数据。 由于应用于模型的代码只需要写一次就可以被多个视图重用，所以提高了代码的可重用性。 视图（View） JSP 视图是用户看到并与之交互的界面，作用如下： 视图向用户显示相关的数据。 接受用户的输入。 不进行任何实际的业务处理。 控制器（Controller） Servlet 控制器接受用户的输入并调用模型和视图去完成用户的需求。 控制器接受请求并决定调用哪个模型组建去处理请求，然后决定调用哪个视图来显示模型处理返回的数据。 优缺点优点 耦合性低，方便维护，可以利于分工协作 重用性高 缺点 使得项目架构变得复杂，对开发人员要求高 EL表达式 Expression Language 表达式语言 作用替换和简化jsp页面中java代码的编写 语法${表达式} 注意jsp默认支持el表达式的。如果要忽略el表达式 设置jsp中page指令中：isELIgnored=”true” 忽略当前jsp页面中所有的el表达式 \${表达式} ：使用转义字符忽略当前这个el表达式 使用 运算 运算符 算数运算符： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 获取值 el表达式只能从域对象中获取值 语法： ${域名称.键名}：从指定域中获取指定键的值 ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 获取对象、List集合、Map集合的值 123456789101. 对象： * $&#123;域名称.键名.属性名&#125; * 本质上会去调用对象的getter方法2. List集合： * $&#123;域名称.键名[索引]&#125;3. Map集合： * $&#123;域名称.键名.key名称&#125; * $&#123;域名称.键名["key名称"]&#125; 隐式对象 el表达式中有11个隐式对象 pageContext：获取jsp其他八个内置对象，特别常用的是：${pageContext.request.contextPath}：动态获取虚拟目录 JSTL JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 作用用于简化和替换jsp页面上的java代码 使用步骤 导入jstl相关jar包 引入标签库：taglib指令： &lt;%@ taglib %&gt; 使用标签 常用的JSTL标签 if:相当于java代码的if语句 属性：test 必须属性，接受boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用 注意：c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 choose:相当于java代码的switch语句 使用choose标签声明 相当于switch声明 使用when标签做判断 相当于case 使用otherwise标签做其他情况的声明 相当于default foreach:相当于java代码的for语句 软件设计架构之三层架构界面层（表示层） 用户看的得界面。用户可以通过界面上的组件和服务器进行交互 业务逻辑层 处理业务逻辑 数据访问层 操作数据存储文件 Filter：过滤器 生活中的过滤器：净水器，空气净化器，纱窗 web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 作用一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤… 使用步骤 定义一个类，实现接口Filter 复写方法 配置拦截路径 方式一：在web.xml中配置 方式二：使用注解配置（@WebFilter） 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码 过滤器生命周期方法 init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter:每一次请求被拦截资源时，会执行。执行多次 destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 过滤器配置详解web.xml方式配置例子： 123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.skywalker.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 拦截路径配置 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 拦截方式配置 注解配置（设置dispatcherTypes属性）： REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 过滤器链(配置多个过滤器)执行顺序：如果有两个过滤器：过滤器1和过滤器2 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行 过滤器案例使用过滤器对敏感词汇进行处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package cn.skywalker.web.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import java.io.*;import java.lang.reflect.Proxy;import java.util.ArrayList;import java.util.List;import java.util.Map;/** * @author SkyWalker * @create 2019 - 08 - 20 - 18:08 */@WebFilter(value = "/*")public class SensitiveWordsFilter implements Filter &#123; public static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; //解决post请求体的中文乱码 request.setCharacterEncoding("utf-8"); //解决响应体的中文乱码 response.setContentType("text/html;charset=utf-8"); //使用动态代理 HttpServletRequest proxy_req = (HttpServletRequest) Proxy.newProxyInstance(request.getClass().getClassLoader(), request.getClass().getInterfaces(), (proxy, method, args) -&gt; &#123; if (method.getName().equals("getParameter")) &#123; String value = (String) method.invoke(request, args); for (String s : list) &#123; if (value.contains(s)) &#123; value = value.replaceAll(s, "***"); &#125; &#125; return value; &#125; else if (method.getName().equals("getParameterValues")) &#123; String[] values = (String[]) method.invoke(request, args); for (String s : list) &#123; for (int i = 0; i &lt; values.length; i++) &#123; if (values[i].contains(s)) &#123; values[i] = values[i].replaceAll(s, "***"); &#125; &#125; &#125; return values; &#125; else if (method.getName().equals("getParameterMap")) &#123; Map&lt;String, String[]&gt; map = (Map&lt;String, String[]&gt;) method.invoke(request, args); for (String s : list) &#123; for (String key : map.keySet()) &#123; String[] values = map.get(key); for (int i = 0; i &lt; values.length; i++) &#123; if (values[i].contains(s)) &#123; values[i] = values[i].replaceAll(s, "***"); &#125; &#125; &#125; &#125; return map; &#125; else &#123; return method.invoke(request, args); &#125; &#125;); //放行 chain.doFilter(proxy_req, response); &#125; /** * 初始化操作：加载敏感词汇 * * @param config * @throws ServletException */ public void init(FilterConfig config) throws ServletException &#123; /** * 方式1：使用config对象获取ServletContext对象，自定义流方式加载 * @文件存放位置：/web/WEB-INF/sensitive_words.txt */// load(config); /** * 方式2：使用类加载器。 * @文件存放位置：/src/sensitive_words.txt */ load(); &#125; public void destroy() &#123; &#125; /** * 方式1：使用config对象获取ServletContext对象，自定义流方式加载 * &lt;p&gt; * 文件存放位置：/web/WEB-INF/sensitive_words.txt * &lt;/p&gt; * * @param config */ public static void load(FilterConfig config) &#123; try &#123; //获取真实路径 String realPath = config.getServletContext().getRealPath("/WEB-INF/sensitive_words.txt"); //定义缓冲字符流对象 BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(realPath), "utf-8")); //读取文件内容，添加至list集合中 String line = null; while ((line = br.readLine()) != null) &#123; list.add(line); &#125; //释放资源 br.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 方式2：使用类加载器。 * &lt;p&gt; * 注意：文件名不能存在中文 * 文件存放位置：/src/sensitive_words.txt * &lt;/p&gt; */ public static void load() &#123; try &#123; //通过类加载器获取输入流对象 InputStream is = SensitiveWordsFilter.class.getClassLoader().getResourceAsStream("sensitive_words.txt"); //定义缓冲字符流对象 BufferedReader br = new BufferedReader(new InputStreamReader(is, "utf-8")); //读取文件内容，添加至list集合中 String line = null; while ((line = br.readLine()) != null) &#123; list.add(line); &#125; //释放资源 br.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Listener：监听器 web的三大组件之一 事件的监听机制 事件 ：一件事情 事件源 ：事件发生的地方 监听器 ：一个对象 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 ServletContextListener 监听ServletContext对象的创建和销毁 在JavaWeb的监听器中，相对较为常用的一个。不过在开发过程中，框架中都已将监听器内置好了，一般不用我们来写。属于底层实现。 方法 void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 void contextInitialized(ServletContextEvent sce)：ServletContext对象创建后会调用该方法 使用步骤 定义一个类，实现ServletContextListener接口 复写方法 配置 web.xml 12345678910111213&lt;!-- 注册监听 --&gt;&lt;listener&gt; &lt;listener-class&gt; cn.skywalker.web.listener.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 指定初始化参数 --&gt;&lt;context-param&gt; &lt;param-name&gt;参数名&lt;/param-name&gt; &lt;param-value&gt;参数值&lt;/param-value&gt;&lt;/context-param&gt; 注解 1@WebListener]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-JavaWeb -JSP -Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F9999_%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hello Everyone！这是我的第一篇文章。 在老铁的帮助下，我慢慢开始摸索代码世界…… 自己加油吧。 Keep Going！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
