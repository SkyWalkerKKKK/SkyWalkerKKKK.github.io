<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaSE Error Log]]></title>
    <url>%2FJava%2FJavaSE-Error-Log%2F</url>
    <content type="text"><![CDATA[Java中protected方法访问权限的问题在cn.skywalker.test05包下的Student类： 123456789101112package cn.skywalker.test05;/** * @author SkyWalker * @create 2019 - 06 - 29 - 19:40 */public class Student &#123; protected void display()&#123; System.out.println("display....."); &#125;&#125; 在cn.skywalker.test06包下的Test类： 12345678910111213141516171819package cn.skywalker.test06;import cn.skywalker.test05.Student;/** * @author SkyWalker * @create 2019 - 06 - 29 - 20:13 */public class Test extends Student&#123; public static void main(String[] args) &#123; Student student = new Student();// student.display(); //在不同包实例化Student类对象，该对象对Student类中声明的protected方法的调用不属于本类调用 Test t = new Test(); t.display(); &#125;&#125; 这里我用cn.skywalker.test06包下的Test类继承了cn.skywalker.test05包下的Student类，但是在Test类中的main()函数中实例化了一个Student对象，该对象却无法调用Student类中使用protected修饰的方法。 这里再给出《java in a nutshell》中的一段话： protected access requires a little more elaboration. Suppose class A declares a protected field x and is extended by a class B, which is defined in a different package (this last point is important). Class B inherits the protected field x, and its code can access that field in the current instance of B or in any other instances of B that the code can refer to. This does not mean, however, that the code of class B can start reading the protected fields of arbitrary instances of A! If an object is an instance of A but is not an instance of B, its fields are obviously not inherited by B, and the code of class B cannot read them. 翻译：protected访问是需要一些准备的。假如类A定义了一个protected的属性x，并且被定义在不同包中的类B扩展了类A。A和B不再同一个包内这一点非常重要。从而，B继承了A的protected属性x，而且在当前B 的实例中这个属性是能够被访问的又或者其他代码中涉及到访问这个属性的B的实例中也是可以访问这个属性的。然而，这并不表示B 的代码可以任意访问A的实例中protected修饰的属性！如果一个对象是A而不是B的实例，显然B是没有继承该对象的属性的，从而B的代码无法访问它们。 方法的访问控制： public protected default private 同类 ✔ ✔ ✔ ✔ 同包 ✔ ✔ ✔ 子类（不同包） ✔ ✔ 不同包中无继承关系的类 ✔ 使用同名局部变量的问题话不多说，直接上代码： 12345678910111213141516171819public class Test &#123; public int age = 5; //成员变量age，默认初始化值为5 public void setAge(int age)&#123; //成员方法，有一个局部变量形参age age = age; &#125; public int getAge()&#123; //成员方法，返回成员变量age的值 return this.age; &#125; public static void main(String[] args)&#123; //主函数 //创建对象，进行测试 Test t = new Test(); t.setAge(10); System.out.println(t.getAge()); //运行结果为5 &#125;&#125; 很明显，我们能看到在Test类中的setAge(int age)方法中，没有使用this关键字对成员变量age进行赋值。而且从运行结果来看，不难发现，在setAge(int age)方法中age = age;这句代码，两个age均指的是形参age这个局部变量。如没有用this显式指明age，则会遵循就近原则，就会发生局部变量age对自己赋值的情况。 局部变量使用范围问题123456789101112131415161718class Demo&#123; String s = "Outer"; public static void main(String[] args)&#123; S2 s2 = new S2(); s2.display(); &#125;&#125;class S1&#123; String s = "S1"; public void display()&#123; System.out.println(s); &#125;&#125;class S2 extends S1&#123; String s = "S2";&#125; 代码如上所示，最终运行结果为S1。 可以总结出：就近原则在使用时，应注意方法对变量的调用也是遵循就近原则的。 多态中关于变量的使用1234567891011121314151617181920212223public class Demo&#123; public static void main(String[] args)&#123; Fu f = new Zi(); System.out.println(f.a); f.method;//这是子类的method方法 &#125;&#125;class Fu&#123; int a = 1; public void method()&#123; System.out,println("这是父类的method方法"); &#125;&#125;class Zi extends Fu&#123; int a = 2; public void method()&#123; System.out.println("这是子类的method方法"); &#125;&#125; 代码如上所示。 我的错误选项： 如果将父类中的成员变量a删除，修改代码如下： 12345class Fu&#123; public void method()&#123; System.out,println("这是父类的method方法"); &#125;&#125; 则运行结果为： 122这是子类的method方法 上面的选项是错误的。正确的运行结果为：编译器报错。 因为如果将Fu类中的成员变量a删除后，在Demo的主函数中f.a的用法将会无法通过编译。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-ErrorLog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE]]></title>
    <url>%2FJava%2FJavaSE%2F</url>
    <content type="text"><![CDATA[环境变量的配置 右键 “我的电脑” – “属性” – “高级系统设置” – “高级” – “环境变量” 打开环境变量设置。 新建系统变量“JAVA_HOME”，值的内容为JDK的根目录。 在“Path”环境变量的值中，增加“%JAVA_HOME%\bin;” 此时再使用cmd即可直接使用javac和java命令。 JDK9的JShell的简单使用直接在cmd中输入jshell，回车，即可启动JShell。 JShell一般用于极其简单、轻量的情况。 编译器的两点优化（对于变量的赋值）第一个优化对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。 如果没有超过左侧的范围，编译器补上强转。 如果右侧超过了左侧范围，那么直接编译器报错。 123456789101112131415public class Demo01 &#123; public static void main(String[] args) &#123; // 右侧确实是一个int数字，但是没有超过左侧的范围，就是正确的。 // int --&gt; byte, 不是自动类型转换 byte num1 = /*(byte)*/ 30; // 右侧没有超过左侧范围 System.out.println(num1); // 30 // byte num2 = 128; // 右侧超过了左侧的范围，编译器报错 // int --&gt; char, 没有超过范围 // 编译器将会自动补上一个隐含的(char) char c1 = /*(char)*/ 65; System.out.println(c1); // A &#125; &#125; 第二个优化在给变量进行赋值的时候，如果右侧的表达式当中全部都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。 short result = 5 + 8; // 等号右边全部都是常量，没有任何变量参与运算 编译之后，得到的.class字节码文件当中相当于【直接就是】： short result = 13; 右侧的常量结果数值，没有超过左侧范围，所以正确。 这称为“编译器的常量优化” 但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。 12345678910111213141516public class Demo02 &#123; public static void main(String[] args) &#123; short num1 = 10; // 正确写法，右侧没有超过左侧范围 short a = 5; short b = 8; // short + short --&gt; int + int --&gt; int // short result = a + b; // 错误写法！左侧需要是int类型 // 右侧不用变量，而是采用常量，而且只有两个常量，没有别人 short result = 5 + 8; System.out.println(result); short result2 = 5 + a + 8; // 结果应该是18，但是编译器报错 &#125;&#125; switch语句使用的注意事项 多个case后面的数值不可以重复 switch后面小括号当中只能是下列数据类型： 基本数据类型：byte / short / char / int 引用数据类型：String字符串 / enum枚举 switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。 匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者switch的整体结束为止。 数组的定义 方式1： 动态初始化：数据类型[] 数组名称 = new 数据类型[数组长度]; 方式2： 标准的静态初始化：数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … }; 方式3： 省略的静态初始化：数据类型[] 数组名称 = { 元素1, 元素2, … }; 注意事项： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。 静态初始化标准格式可以拆分成为两个步骤。 动态初始化也可以拆分成为两个步骤。 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。 使用建议：如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。 1234567891011121314151617181920public class Demo03 &#123; public static void main(String[] args) &#123; // 省略格式的静态初始化 int[] arrayA = &#123; 10, 20, 30 &#125;; // 静态初始化的标准格式，可以拆分成为两个步骤 int[] arrayB; arrayB = new int[] &#123; 11, 21, 31 &#125;; // 动态初始化也可以拆分成为两个步骤 int[] arrayC; arrayC = new int[5]; // 静态初始化的省略格式，不能拆分成为两个步骤。// int[] arrayD;// arrayD = &#123; 10, 20, 30 &#125;; &#125;&#125; 数组中的内存图 集成开发环境IntelliJ IDEAIDE（Integrated Development Environment）集成开发环境。 IDEA牛逼。。。OK就这样233 继承 格式：public class 子类名 extends 父类名 { } 范例：public class Zi extends Fu { } 代码范例： 1234567891011121314151617181920212223public class Demo04 &#123; public static void main(String[] args) &#123; //创建对象，调用方法 Fu f = new Fu(); f.show(); Zi z = new Zi(); z.method(); z.show();//调用继承于父类的show方法 &#125;&#125;class Fu &#123; public void show()&#123; System.out.println("父类的show方法"); &#125;&#125;class Zi extends Fu &#123; public void method()&#123; System.out.println("子类的method方法"); &#125;&#125; 注意：父类的构造器无法继承下来，如需调用，使用super关键字即可。 继承的好处与弊端 好处： 提高了代码的 复用性（多个类相同的成员可以放到同一个类中） 提高了代码的 维护性（如果方法的代码需要修改，修改一处即可） 弊端： 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性 继承体现的关系： is a 继承中成员变量的访问特点通过子类对象访问一个变量 ，遵循就近原则： 先找局部范围 再找子类成员范围 再找父类成员范围 如果都没有就报错(不考虑父亲的父亲…) 继承中成员方法的访问特点与成员变量的“就近原则”类似。 再找子类成员范围 再找父类成员范围 如果都没有就报错(不考虑父亲的父亲…) 继承中构造函数的访问特点 子类会继承父类的数据，可能还会使用父类的数据。所以子类初始化之前，一定要先完成父类的初始化。 每一个子类构造方法的第一条语句默认都是：super(); 如果想要控制子类的构造方法调用父类的哪一个构造方法，使用super进行调用即可。 示例代码： 1234567891011121314151617181920212223242526272829public class Demo05 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); &#125;&#125;class Fu &#123; public Fu() &#123; System.out.println("Fu的无参"); &#125; public Fu(int age) &#123; System.out.println("Fu的有参"); &#125;&#125;class Zi extends Fu &#123; public Zi() &#123;// super();//调用父类的无参构造函数 super(10);//调用父类的有参构造函数 System.out.println("Zi的无参"); &#125; public Zi(int age) &#123; //默认调用super();即无参构造函数，可以使用super(int值)显式调用父类的有参构造函数 super(10); System.out.println("Zi的有参"); &#125;&#125; Super内存图 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 方法重写 在重写方法时，可以在声明前加入@Override注解，可以帮助我们检查我们要重写的方法声明是否错误 父类中私有的方法不能被重写 子类的方法的声明和父类的方法的声明一般一致，但是有些地方可以不一致，遵循以下原则： 一大：子类重写的方法的权限修饰符必须大于或者等于父类方法的权限修饰符 private &lt; default &lt; protected &lt; public 两同： 方法名必须相同 参数列表必须相同 两小： 子类重写的方法的返回值类型必须小于等于父类方法的返回值类型（针对的是引用类型，一般小于说的是子类与父类的关系，对基本类型无效） 子类重写的方法抛出的异常必须小于等于或者少于等于父类的方法抛出的异常，如果父类方法没有抛出异常，则子类重写之后的方法绝对不能抛出异常 继承的注意事项 Java中的类只支持单继承，不支持多继承（一个类只能有一个父类） Java中的类支持多层继承 final、static修饰符 final修饰符： 修饰方法：该方法无法被重写 修饰变量：该变量无法被赋值 修饰类：该类无法被继承 static修饰符： 被类的所有对象共享 可以通过类名调用 非静态的成员方法 能访问静态的成员变量 能访问非静态的成员变量 能访问静态的成员方法 能访问非静态的成员方法 静态的成员方法 能访问静态的成员变量 能访问静态的成员方法 总结成一句话就是：静态成员方法只能访问静态成员 示例代码： 123456789101112131415161718192021222324class Student &#123; public String name; //姓名 public int age; //年龄 public static String university; //学校 共享数据！所以设计为静态！ public void show() &#123; System.out.println(name + "," + age + "," + university); &#125;&#125;public class Demo06 &#123; public static void main(String[] args) &#123; // 为对象的共享数据赋值 Student.university = "传智大学"; Student s1 = new Student(); s1.name = "林青霞"; s1.age = 30; s1.show(); Student s2 = new Student(); s2.name = "风清扬"; s2.age = 33; s2.show(); &#125;&#125; 多态 概念 一个事物在不同情况下表现出的多种形态 前提 有继承/实现关系 有方法的重写（不一定是必须有） 父类的引用指向子类的对象 多态中成员访问的特点 成员变量：编译看左边（父类），运行看左边（父类） 成员方法：编译看左边（父类），运行看右边（子类） 总结：编译都看左边，运行也都看左边（非静态的成员方法除外）。 多态的好处与弊端 好处：提高了程序的扩展性 弊端：不能使用子类的特有属性、功能 多态的转型（引用类型的转换） 向上转型：小类型（子类）转为大类型（父类），自动转 格式：父类类型 变量名 = 子类对象; 比如：Animal a = new Cat(); 其实多态的体现就是向上转型 向下转型：大类型（父类）转为小类型（子类），强制转 格式：子类类型 对象名 = （子类类型）父类类型的对象名; 比如：Cat c = (Cat)a; 抽象类 概念：使用abstract关键字修饰的类 格式：public abstract class 类名 { } 抽象类的特点 抽象类和抽象方法必须使用 abstract 关键字修饰 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类 抽象类不能实例化 抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态 抽象类的子类 要么重写抽象类中的所有抽象方法 要么是抽象类 抽象类的成员特点 成员变量 既可以是变量 也可以是常量 构造方法 空参构造 有参构造 成员方法 抽象方法 普通方法 接口 概念：公共的规范和标准，只要按照这些规范来就可以正确使用 接口的特点 接口用关键字interface修饰 1public interface 接口名 &#123;&#125; 类实现接口用implements表示 1public class 类名 implements 接口名 &#123;&#125; 接口不能实例化 接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。 多态的形式：具体类多态，抽象类多态，接口多态。 接口的子类 要么重写接口中的所有抽象方法 要么子类也是抽象类]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2Fmarkdown%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 再一次感谢您花费时间阅读，祝您在这里记录、阅读、分享愉快！]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>-markdown -笔记 -工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML/CSS学习笔记]]></title>
    <url>%2FHTML-CSS%2FHTML-CSS%2F</url>
    <content type="text"><![CDATA[HTML/CSS笔记123456789&lt;html&gt; &lt;!--这是根标签 --&gt; &lt;head&gt; &lt;title&gt;这里是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这里是页面体 &lt;/body&gt;&lt;/html&gt; 外部样式表格式： 1&lt;link rel = "stylesheet" type = "text/css" href = "css文件路径" /&gt; 文本标签 1234567891011121314&lt;em&gt;&lt;/em&gt;表示语义上的强调（自动斜体）&lt;strong&gt;&lt;/strong&gt;表示内容上的强调（自动加粗）&lt;i&gt;&lt;/i&gt;i标签的内容会以斜体显示&lt;b&gt;&lt;/b&gt;b标签的内容会以加粗显示&lt;small&gt;&lt;/small&gt;内容以细小的字体显示&lt;cite&gt;&lt;/cite&gt;引用（加书名号的）&lt;q&gt;&lt;/q&gt;行引用&lt;blockquote&gt;&lt;/blockquote&gt;块儿引用&lt;sup&gt;&lt;/sup&gt;上标&lt;sub&gt;&lt;/sub&gt;下标&lt;del&gt;&lt;/del&gt;删除线&lt;ins&gt;&lt;/ins&gt;插入内容&lt;pre&gt;&lt;/pre&gt;预格式&lt;code&gt;&lt;/code&gt;代码块（一般和pre标签一起使用）]]></content>
      <categories>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>-HTML -CSS -H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习笔记]]></title>
    <url>%2FJava%2FJavaWeb%2F</url>
    <content type="text"><![CDATA[ServletServletResoponse 设置响应格式123ServletResponse response = new ServletResponse();response.setContentType("application/msword");//设置响应类型为word文档。//具体可以在tomcat/config/web.xml中查找需要格式对应的值 JSPJSP运行原理 JSP是简Servlet编写的一种技术，他将Java代码和HTML语句混合在同一个文件中编写。只对网页中的要动态产生的内容才用Java代码来编写，而对固定不变的静态内容才用普通静态HTML页面的方式编写。 JSP继承了HttpJspBase类，而HttpJspBase又继承了HttpServlet，即jsp间接继承了HttpServlet，即JSP本质上就是一个Servlet。 JSP八大内置对象（实际上9个） 类名 对象实例名（可直接调用） HttpServletRequest request HttpServletResoponse response PageContext pageContext HttpSession session ServletContext application ServletConfig config JspWriter out Object page Exception exception ① request：HttpServletRequest的一个对象。 ② response：HttpServletResponse的一个对象（在JSP页面中几乎不会调用response的任何方法）。 ③ pageContext：页面的上下文，是PageContext的一个对象。可以从该对象中获取到其他8个隐含对象。亦可以从中获取到当前页面的其他信息。（学习自定义标签时使用他。在JSP页面上很少直接使用他。） ④ session：代表浏览器和服务器的一次会话，是HttpSession的一个对象。 ⑤ application：代表当前Web应用。是ServletContext的一个对象。（可以获取初始化参数等。） ⑥ config：当前JSP对应的Servlet的ServletConfig对象。（开发时几乎不使用。若需要访问当前JSP配置的初始化参数，需要通过映射的地址才可以。） ⑦ out：JspWriter对象。调用out.println()可以直接把字符串打印到浏览器上。（在两次out.println()时，中间不会换行，需要添加HTML的换行标签&lt;br>。） ⑧ page：指向当前JSP对应的Servlet对象的引用，但为Object类型，只能调用Object类的方法（几乎不使用。） ⑨ exception：一定的条件下才可以用。（只有主动声明了isErrorPage=”true”的时候，才可以使用。） 标红均为开发时常用对象。 pageContext，request，session，application对属性的作用域范围从小到大。 JSP表达式​ JSP表达式（expression）提供了将一个java变量或表达式的计算结果输出到客户端的简化方式，他将要输出的变量或表达式直接封装在&lt;%= 和 %&gt;中。 JSP注释的格式：&lt;%– JSP注释 –%&gt; HTML注释的格式：&lt;!– HTML注释 –> 区别 : ​ JSP注释可以阻止Java代码的执行，而HTML注释surround with &lt;% Java代码 %&gt;时，不能阻止Java代码的执行。 域对象的属性操作 ① 和属性相关的方法： Object getAttribute(String name)：获取指定的属性 Enumeration getAttributeNames()：获取所有的属性的名字组成的Enumeration对象 void removeAttribute(String name)：移除指定的属性 void setAttribute(String name, Object obj)：设置属性 ② pageContext，request，session，application对象都有这些方法。这四个对象也成为域对象。 ③ 作用范围 pageContext：属性的作用范围仅限于当前JSP页面。（在Servlet中无法得到pageContext对象。） request：属性的作用范围仅限于同一个请求。 session：属性的作用范围限于一次会话。（会话：浏览器打开直到关闭称之为一次会话。（会话在此期间不失效。）） application：属性的作用范围限于当前Web应用。是范围最大的属性作用范围，只要在一处设置属性，在其他各处的JSP或Servlet中都可以获取到。 请求的转发和重定向 ① 调用HttpServletRequest的getRequestDispatcher(String path)方法获取RequestDispatcher对象。调用方法时，需要传入要转发的地址。 ② 调用 HttpServletRequest的 forward（request，response）进行请求的转发。 ③ 调用sendRedirect(String path) 进行请求的重定向。 ④ 转发与重定向的区别： 本质区别：请求的转发只发出了 一次 请求，而重定向则发出了 两次 请求。 具体： 请求的转发：地址栏是初次发出请求的地址。 请求的重定向：地址栏不再是初次发出的请求地址，地址栏为最后响应的那个地址。 请求的转发：在最终的Servlet中，request对象和中转的那个request是同一个对象。 请求的重定向：在最终的Servlet中，request对象和中转的那个request不是同一个对象。 请求的转发：只能转发到当前Web应用的资源（内部资源）。 请求的重定向：可以重定向到任何资源。 请求的转发：“ / ” 代表的是当前Web应用（localhost:port/WebApps）的根目录。 请求的重定向：“ / ” 代表的是当前Web站点（localhost:port）的根目录。 JSP指令 ①include 用于通知JSP引擎在翻译当前JSP页面时将其他文件中的内容合并进当前JSP页面转换成的Servlet源文件中，这种在源文件级别进行引入的方式称之为静态引入，当前JSP页面与静态引入的页面紧密结合为一个Servlet。 file属性的设置值必须使用相对路径。 如果以“ / ”开头，表示相对于当前Web应用程序的根目录（注意不是站点根目录），否则，表示相对于当前文件。 ②page page指令用于定义JSP页面的各种属性，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面，为了保持程序的可读性和遵循良好的变成习惯，page指令最好是放在整个JSP页面的起始位置。 page指令常用的属性： import属性：指定当前JSP页面对应的Servlet需要导入的类。&lt;%@page import=”全类名”%&gt; session属性：取值为true或false，指定当前页面的session隐藏变量是否可用，也可以说访问当前页面时，是否一定要生成HttpSession对象。 errorPage和isErrorPage：前者表示指定若当前页面出现错误的实际响应页面是什么，其中“ / ” 表示的是当前Web应用的根目录。后者表示指定当前页面是否为错误处理页面，可以说明当前页面是否可以使用exception隐藏内置对象。 需要注意的是：若指定isErrorPage=”true”，并使用exception的方法了，一般不建议能够直接访问该页面。 contentType：指定当前JSP页面的响应类型。实际调用的是response.setContentType(“text/html;charset=UTF-8”);通常情况下，对于JSP页面而言其取值均为 text/html; charset=UTF-8 pageEncoding：指定当前JSP页面的字符编码。通常情况下该值和contentType中的charset一致。 isELIgnored：指定当前JSP页面是否可以使用EL表达式。通常取值为true。 如何使客户不能直接访问一个页面呢？ 1) 对于Tomcat服务器而言，WEB-INF下的文件是不能通过在浏览器中直接输入来访问的。但通过请求的转发是可以访问的！2) 还可以在web.xml文件中配置错误页面。 1234567891011 &lt;!-- 方式1.指定出错的代码，404没有指定资源，500内部错误。 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;!-- 指定响应页面的位置 --&gt;&lt;/error-page&gt; &lt;!-- 方式2.指定异常的类型 --&gt; &lt;error-page&gt;&lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;!-- 指定响应页面的位置 --&gt;&lt;/error-page&gt; ③taglib JSP标签 jsp:include标签： &lt;jsp:include page = &quot;path&quot;&gt; &lt;/jsp:include&gt; 动态引入：并不是像include指令生成一个Servlet源文件，而是生成两个Servlet源文件，然后通过一个方法的方式把目标页面包含进来。 org.apache.jasper.runtime.JspRuntimeLibrary.include(request,response,&quot;path&quot;,out,false); include指令和jsp:include标签： 是在当前JSP页面的执行期间插入被引入资源的输出内容。 被动态引入的资源必须是一个能独立被Web容器调用和执行的资源。 include指令只能引入遵循JSP格式的文件，被引入文件与当前JSP文件共同合被翻译成一个Servlet源文件。 jsp:foward标签： &lt;jsp:forward page = &quot;path&quot;&gt;&lt;/jsp:forward&gt; 相当于request.getRequestDispatcher(&quot;path&quot;).forward(request,response); 但使用jsp:forward可以使用jsp:param子标签向path传入一些参数，同样jsp:include也可以使用jsp:param子标签。 中文乱码编码格式 = 解码格式即可解决乱码问题。 MVC设计模式MVC即Model-View-Controller。模型-视图-控制器。 模型（Model） 模型是应用程序的主体部分。模型表示业务数据和业务逻辑。 一个模型能为多个视图提供数据。 由于应用于模型的代码只需要写一次就可以被多个视图重用，所以提高了代码的可重用性。 视图（View） 视图是用户看到并与之交互的界面，作用如下： 视图向用户显示相关的数据。 接受用户的输入。 不进行任何实际的业务处理。 控制器（Controller） 控制器接受用户的输入并调用模型和视图去完成用户的需求。 控制器接受请求并决定调用哪个模型组建去处理请求，然后决定调用哪个视图来显示模型处理返回的数据。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-JavaWeb -JSP -Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hello Everyone！这是我的第一篇文章。 在老铁的帮助下，我慢慢开始摸索代码世界…… 自己加油吧。 Keep Going！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
