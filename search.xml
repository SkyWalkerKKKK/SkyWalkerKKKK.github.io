<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaSE Error Log]]></title>
    <url>%2FJava%2FJavaSE-Error-Log%2F</url>
    <content type="text"><![CDATA[Java中protected方法访问权限的问题在cn.skywalker.test05包下的Student类： 123456789101112package cn.skywalker.test05;/** * @author SkyWalker * @create 2019 - 06 - 29 - 19:40 */public class Student &#123; protected void display()&#123; System.out.println("display....."); &#125;&#125; 在cn.skywalker.test06包下的Test类： 12345678910111213141516171819package cn.skywalker.test06;import cn.skywalker.test05.Student;/** * @author SkyWalker * @create 2019 - 06 - 29 - 20:13 */public class Test extends Student&#123; public static void main(String[] args) &#123; Student student = new Student();// student.display(); //在不同包实例化Student类对象，该对象对Student类中声明的protected方法的调用不属于本类调用 Test t = new Test(); t.display(); &#125;&#125; 这里我用cn.skywalker.test06包下的Test类继承了cn.skywalker.test05包下的Student类，但是在Test类中的main()函数中实例化了一个Student对象，该对象却无法调用Student类中使用protected修饰的方法。 这里再给出《java in a nutshell》中的一段话： protected access requires a little more elaboration. Suppose class A declares a protected field x and is extended by a class B, which is defined in a different package (this last point is important). Class B inherits the protected field x, and its code can access that field in the current instance of B or in any other instances of B that the code can refer to. This does not mean, however, that the code of class B can start reading the protected fields of arbitrary instances of A! If an object is an instance of A but is not an instance of B, its fields are obviously not inherited by B, and the code of class B cannot read them. 翻译：protected访问是需要一些准备的。假如类A定义了一个protected的属性x，并且被定义在不同包中的类B扩展了类A。A和B不再同一个包内这一点非常重要。从而，B继承了A的protected属性x，而且在当前B 的实例中这个属性是能够被访问的又或者其他代码中涉及到访问这个属性的B的实例中也是可以访问这个属性的。然而，这并不表示B 的代码可以任意访问A的实例中protected修饰的属性！如果一个对象是A而不是B的实例，显然B是没有继承该对象的属性的，从而B的代码无法访问它们。 方法的访问控制： public protected default private 同类 ✔ ✔ ✔ ✔ 同包 ✔ ✔ ✔ 子类（不同包） ✔ ✔ 不同包中无继承关系的类 ✔ 使用同名局部变量的问题话不多说，直接上代码： 12345678910111213141516171819public class Test &#123; public int age = 5; //成员变量age，默认初始化值为5 public void setAge(int age)&#123; //成员方法，有一个局部变量形参age age = age; &#125; public int getAge()&#123; //成员方法，返回成员变量age的值 return this.age; &#125; public static void main(String[] args)&#123; //主函数 //创建对象，进行测试 Test t = new Test(); t.setAge(10); System.out.println(t.getAge()); //运行结果为5 &#125;&#125; 很明显，我们能看到在Test类中的setAge(int age)方法中，没有使用this关键字对成员变量age进行赋值。而且从运行结果来看，不难发现，在setAge(int age)方法中age = age;这句代码，两个age均指的是形参age这个局部变量。如没有用this显式指明age，则会遵循就近原则，就会发生局部变量age对自己赋值的情况。 局部变量使用范围问题123456789101112131415161718class Demo&#123; String s = "Outer"; public static void main(String[] args)&#123; S2 s2 = new S2(); s2.display(); &#125;&#125;class S1&#123; String s = "S1"; public void display()&#123; System.out.println(s); &#125;&#125;class S2 extends S1&#123; String s = "S2";&#125; 代码如上所示，最终运行结果为S1。 可以总结出：就近原则在使用时，应注意方法对变量的调用也是遵循就近原则的。 多态中关于变量的使用1234567891011121314151617181920212223public class Demo&#123; public static void main(String[] args)&#123; Fu f = new Zi(); System.out.println(f.a); f.method;//这是子类的method方法 &#125;&#125;class Fu&#123; int a = 1; public void method()&#123; System.out,println("这是父类的method方法"); &#125;&#125;class Zi extends Fu&#123; int a = 2; public void method()&#123; System.out.println("这是子类的method方法"); &#125;&#125; 代码如上所示。 我的错误选项： 如果将父类中的成员变量a删除，修改代码如下： 12345class Fu&#123; public void method()&#123; System.out,println("这是父类的method方法"); &#125;&#125; 则运行结果为： 122这是子类的method方法 上面的选项是错误的。正确的运行结果为：编译器报错。 因为如果将Fu类中的成员变量a删除后，在Demo的主函数中f.a的用法将会无法通过编译。 关于println()与toString()的联系12345678910111213141516public class ToStringTest &#123; static int i = 1; public static void main(String args[]) &#123; // 调用ToStringTest的 toString方法 System.out.println("love " + new ToStringTest()); ToStringTest a = new ToStringTest(); a.i++; System.out.println("me " + a.i); &#125; public String toString() &#123; System.out.print("I "); return "java "; &#125;&#125; 运行结果： 12I love java me 2 从结果中，猛一下似乎看不太明白，但静下心来仔细分析，我们会发现在主函数的第一句代码 System.out.println(&quot;love &quot; + new ToStringTest()); 执行过程中，JVM优先解析了 “ + “后面的new ToStringTest()，而我们知道，在JVM调用println()时，底层是调用了该Object对象的toString()方法，所以会最先执行ToStringTest类中重写的toString()方法。结果也就在逻辑之中了。 String类型的深度解析String的本质打开String的源码，类注释中有这么一段话 “Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings.Because String objects are immutable they can be shared.”。 这句话总结归纳了String的一个最重要的特点： String是值不可变(immutable)的常量，是线程安全的(can be shared)。 接下来，String类使用了final修饰符，表明了String类的第二个特点：String类是不可继承的。 下面是String类的成员变量定义，从类的实现上阐明了String值是不可变的(immutable)。 private final char value[]; private final int count; 因此，我们看String类的concat方法。实现该方法第一步要做的肯定是扩大成员变量value的容量，扩容的方法重新定义一个大容量的字符数组buf。第二步就是把原来value中的字符copy到buf中来，再把需要concat的字符串值也copy到buf中来，这样子，buf中就包含了concat之后的字符串值。下面就是问题的关键了，如果value不是final的，直接让value指向buf，然后返回this，则大功告成，没有必要返回一个新的String对象。但是。。。可惜。。。由于value是final型的，所以无法指向新定义的大容量数组buf，那怎么办呢？“return new String(0, count + otherLen, buf);”，这是String类concat实现方法的最后一条语句，重新new一个String对象返回。这下真相大白了吧！ ​ 总结：String实质是字符数组，两个特点： 该类不可被继承 不可变性(immutable)。 12345String s1 = "ab";String s2 = "abc";String s3 = s1 + "c";System.out.println(s3 == s2); //falseSystem.out.println(s3.equals(s2)); //true 1234String s1 = "a" + "b" + "c";String s2 = "abc";System.out.println(s1 == s2);//trueSystem.out.println(s1.equals(s2));//true]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-ErrorLog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE]]></title>
    <url>%2FJava%2FJavaSE%2F</url>
    <content type="text"><![CDATA[环境变量的配置 右键 “我的电脑” – “属性” – “高级系统设置” – “高级” – “环境变量” 打开环境变量设置。 新建系统变量“JAVA_HOME”，值的内容为JDK的根目录。 在“Path”环境变量的值中，增加“%JAVA_HOME%\bin;” 此时再使用cmd即可直接使用javac和java命令。 JDK9的JShell的简单使用直接在cmd中输入jshell，回车，即可启动JShell。 JShell一般用于极其简单、轻量的情况。 编译器的两点优化（对于变量的赋值）第一个优化对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。 如果没有超过左侧的范围，编译器补上强转。 如果右侧超过了左侧范围，那么直接编译器报错。 123456789101112131415public class Demo01 &#123; public static void main(String[] args) &#123; // 右侧确实是一个int数字，但是没有超过左侧的范围，就是正确的。 // int --&gt; byte, 不是自动类型转换 byte num1 = /*(byte)*/ 30; // 右侧没有超过左侧范围 System.out.println(num1); // 30 // byte num2 = 128; // 右侧超过了左侧的范围，编译器报错 // int --&gt; char, 没有超过范围 // 编译器将会自动补上一个隐含的(char) char c1 = /*(char)*/ 65; System.out.println(c1); // A &#125; &#125; 第二个优化在给变量进行赋值的时候，如果右侧的表达式当中全部都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。 short result = 5 + 8; // 等号右边全部都是常量，没有任何变量参与运算 编译之后，得到的.class字节码文件当中相当于【直接就是】： short result = 13; 右侧的常量结果数值，没有超过左侧范围，所以正确。 这称为“编译器的常量优化” 但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。 12345678910111213141516public class Demo02 &#123; public static void main(String[] args) &#123; short num1 = 10; // 正确写法，右侧没有超过左侧范围 short a = 5; short b = 8; // short + short --&gt; int + int --&gt; int // short result = a + b; // 错误写法！左侧需要是int类型 // 右侧不用变量，而是采用常量，而且只有两个常量，没有别人 short result = 5 + 8; System.out.println(result); short result2 = 5 + a + 8; // 结果应该是18，但是编译器报错 &#125;&#125; switch语句使用的注意事项 多个case后面的数值不可以重复 switch后面小括号当中只能是下列数据类型： 基本数据类型：byte / short / char / int 引用数据类型：String字符串 / enum枚举 switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。 匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者switch的整体结束为止。 关于switch的穿透代码示例： 123456789101112131415public class Debug01 &#123; public static void main(String[] args) &#123; int a = 1; switch (a) &#123; case 1: System.out.println("1."); case 2: case 3: default: // switch的穿透，所以会执行下面的输出语句。 System.out.println("default."); &#125; &#125;&#125; 代码的运行结果为： 121.default. 数组的定义 方式1： 动态初始化：数据类型[] 数组名称 = new 数据类型[数组长度]; 方式2： 标准的静态初始化：数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … }; 方式3： 省略的静态初始化：数据类型[] 数组名称 = { 元素1, 元素2, … }; 注意事项： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。 静态初始化标准格式可以拆分成为两个步骤。 动态初始化也可以拆分成为两个步骤。 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。 使用建议：如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。 1234567891011121314151617181920public class Demo03 &#123; public static void main(String[] args) &#123; // 省略格式的静态初始化 int[] arrayA = &#123; 10, 20, 30 &#125;; // 静态初始化的标准格式，可以拆分成为两个步骤 int[] arrayB; arrayB = new int[] &#123; 11, 21, 31 &#125;; // 动态初始化也可以拆分成为两个步骤 int[] arrayC; arrayC = new int[5]; // 静态初始化的省略格式，不能拆分成为两个步骤。// int[] arrayD;// arrayD = &#123; 10, 20, 30 &#125;; &#125;&#125; 数组中的内存图 Random类 作用：用于产生一个随机数 所属包：java.util.Random 格式： 12Random random = new Random();int number = random.nextInt(int index); // 获取数据的范围：[0,index) 左闭右开的一个区间。 拓展： Math类下的static double random()方法的返回值为double。值为正号，大于等于 0.0 ，小于 1.0 。 即获取数据的范围：[0.0, 1.0) 左闭右开的一个区间。 常用案例： 生成一个1~100的随机数字 1234int num = (int)(Math.random() * 100) + 1; // 使用Math类下的random()静态方法Random r = new Random();int num1 = r.nextInt(100) + 1; // 使用Random类生成 方法重载的注意点 与返回值类型无关 123456789public class MethodDemo&#123; public static void fn(int a)&#123; //method body &#125; public static int fn(int a)&#123; //method body &#125;&#125; 上面的代码不构成方法的重载：因为形参列表相同。虽然返回值类型不同，但方法重载与返回值类型无关。 集成开发环境IntelliJ IDEAIDE（Integrated Development Environment）集成开发环境。 IDEA牛逼。。。OK就这样233 IDEA中Debug的使用如何加断点选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可。 如何运行加了断点的程序在代码区域右键Debug执行。 看哪里看Debugger窗口 点哪里点Step Into（F7）这个箭头，也可以直接按F7，运行完之后，点击Stop结束。 如何删除断点选择要删除的断点，单击鼠标左键即可。 如果是多个断点，可以每一个再点击一次，也可以一次性全部删除。 注意事项如果数据来自于键盘输入（Scanner），一定要记住输入数据，不然就不能继续往下查看了。 Java中的内存分配JVM简介 Java虚拟机（Java Virtual Machine 简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 一个运行时的Java虚拟机实例的天职是：负责运行一个java程序。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。 JVM的体系结构包含几个主要的子系统和内存区： 垃圾回收器（Garbage Collection）：负责回收堆内存（Heap）中没有被使用的对象，即这些对象已经没有被引用了。 类装载子系统（ClassLoader Sub-System）：除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。 执行引擎（Execution Engine）：负责执行那些包含在被装载类的方法中的指令。 运行时数据区（Java Memory Allocation Area）：又叫虚拟机内存或者Java内存，虚拟机运行时需要从整个计算机内存划分一块内存区域存储许多东西。例如：字节码、从已装载的class文件中得到的其他信息、程序创建的对象、传递给方法的参数，返回值、局部变量等等。 Java内存分区从上节知道，运行时数据区即是java内存，而且数据区要存储的东西比较多，如果不对这块内存区域进行划分管理，会显得比较杂乱无章。 根据存储数据的不同，java内存通常被划分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Method Area）、栈（Stack）、堆（Heap）。 程序计数器（Program Count Register）：又叫程序寄存器。JVM支持多个线程同时运行，当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）。如果线程正在执行的是一个Java方法（非native），那么PC寄存器的值将总是指向下一条将被执行的指令，如果方法是 native的，程序计数器寄存器的值不会被定义。 JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。 栈（Stack）：又叫堆栈。JVM为每个新创建的线程都分配一个栈。也就是说,对于一个Java程序来说，它的运行就是通过对栈的操作来完成的。栈以帧为单位保存线程的状态。JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。我们知道,某个线程正在执行的方法称为此线程的当前方法。我们可能不知道，当前方法使用的帧称为当前帧。当线程激活一个Java方法，JVM就会在线程的 Java堆栈里新压入一个帧，这个帧自然成为了当前帧。在此方法执行期间，这个帧将用来保存参数、局部变量、中间计算过程和其他数据。从Java的这种分配机制来看,堆栈又可以这样理解：栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。 方法区（Method Area）：当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，如下图所示。本地方法区存在一块特殊的内存区域，叫常量池（Constant Pool），这块内存将与String类型的分析密切相关。 堆（Heap）：Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。在此区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存，但是这个对象的引用却是在栈（Stack）中分配。因此，执行String s = new String(“s”)时，需要从两个地方分配内存：在堆中为String对象分配内存，在栈中为引用（这个堆对象的内存地址，即指针）分配内存。 继承 格式：public class 子类名 extends 父类名 { } 范例：public class Zi extends Fu { } 代码范例： 1234567891011121314151617181920212223public class Demo04 &#123; public static void main(String[] args) &#123; //创建对象，调用方法 Fu f = new Fu(); f.show(); Zi z = new Zi(); z.method(); z.show();//调用继承于父类的show方法 &#125;&#125;class Fu &#123; public void show()&#123; System.out.println("父类的show方法"); &#125;&#125;class Zi extends Fu &#123; public void method()&#123; System.out.println("子类的method方法"); &#125;&#125; 注意：父类的构造器无法继承下来，如需调用，使用super关键字即可。 继承的好处与弊端 好处： 提高了代码的 复用性（多个类相同的成员可以放到同一个类中） 提高了代码的 维护性（如果方法的代码需要修改，修改一处即可） 弊端： 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性 继承体现的关系： is a 继承中成员变量的访问特点通过子类对象访问一个变量 ，遵循就近原则： 先找局部范围 再找子类成员范围 再找父类成员范围 如果都没有就报错(不考虑父亲的父亲…) 继承中成员方法的访问特点与成员变量的“就近原则”类似。 再找子类成员范围 再找父类成员范围 如果都没有就报错(不考虑父亲的父亲…) 继承中构造函数的访问特点 子类会继承父类的数据，可能还会使用父类的数据。所以子类初始化之前，一定要先完成父类的初始化。 每一个子类构造方法的第一条语句默认都是：super(); 如果想要控制子类的构造方法调用父类的哪一个构造方法，使用super进行调用即可。 示例代码： 1234567891011121314151617181920212223242526272829public class Demo05 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); &#125;&#125;class Fu &#123; public Fu() &#123; System.out.println("Fu的无参"); &#125; public Fu(int age) &#123; System.out.println("Fu的有参"); &#125;&#125;class Zi extends Fu &#123; public Zi() &#123;// super();//调用父类的无参构造函数 super(10);//调用父类的有参构造函数 System.out.println("Zi的无参"); &#125; public Zi(int age) &#123; //默认调用super();即无参构造函数，可以使用super(int值)显式调用父类的有参构造函数 super(10); System.out.println("Zi的有参"); &#125;&#125; Super内存图 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 方法重写 在重写方法时，可以在声明前加入@Override注解，可以帮助我们检查我们要重写的方法声明是否错误 父类中私有的方法不能被重写 子类的方法的声明和父类的方法的声明一般一致，但是有些地方可以不一致，遵循以下原则： 一大：子类重写的方法的权限修饰符必须大于或者等于父类方法的权限修饰符 private &lt; default &lt; protected &lt; public 两同： 方法名必须相同 参数列表必须相同 两小： 子类重写的方法的返回值类型必须小于等于父类方法的返回值类型（针对的是引用类型，一般小于说的是子类与父类的关系，对基本类型无效） 子类重写的方法抛出的异常必须小于等于或者少于等于父类的方法抛出的异常，如果父类方法没有抛出异常，则子类重写之后的方法绝对不能抛出异常 继承的注意事项 Java中的类只支持单继承，不支持多继承（一个类只能有一个父类） Java中的类支持多层继承 final、static修饰符 final修饰符： 修饰方法：该方法无法被重写 修饰变量：该变量无法被赋值 修饰类：该类无法被继承 static修饰符： 被类的所有对象共享 可以通过类名调用 非静态的成员方法 能访问静态的成员变量 能访问非静态的成员变量 能访问静态的成员方法 能访问非静态的成员方法 静态的成员方法 能访问静态的成员变量 能访问静态的成员方法 总结成一句话就是：静态成员方法只能访问静态成员 示例代码： 123456789101112131415161718192021222324class Student &#123; public String name; //姓名 public int age; //年龄 public static String university; //学校 共享数据！所以设计为静态！ public void show() &#123; System.out.println(name + "," + age + "," + university); &#125;&#125;public class Demo06 &#123; public static void main(String[] args) &#123; // 为对象的共享数据赋值 Student.university = "传智大学"; Student s1 = new Student(); s1.name = "林青霞"; s1.age = 30; s1.show(); Student s2 = new Student(); s2.name = "风清扬"; s2.age = 33; s2.show(); &#125;&#125; 多态 概念 一个事物在不同情况下表现出的多种形态 前提 有继承/实现关系 有方法的重写（不一定是必须有） 父类的引用指向子类的对象 多态中成员访问的特点 成员变量：编译看左边（父类），运行看左边（父类） 成员方法：编译看左边（父类），运行看右边（子类） 总结：编译都看左边，运行也都看左边（非静态的成员方法除外）。 多态的好处与弊端 好处：提高了程序的扩展性 弊端：不能使用子类的特有属性、功能 多态的转型（引用类型的转换） 向上转型：小类型（子类）转为大类型（父类），自动转 格式：父类类型 变量名 = 子类对象; 比如：Animal a = new Cat(); 其实多态的体现就是向上转型 向下转型：大类型（父类）转为小类型（子类），强制转 格式：子类类型 对象名 = （子类类型）父类类型的对象名; 比如：Cat c = (Cat)a; 抽象类 概念：使用abstract关键字修饰的类 格式：public abstract class 类名 { } 抽象类的特点 抽象类和抽象方法必须使用 abstract 关键字修饰 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类 抽象类不能实例化 抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态 抽象类的子类 要么重写抽象类中的所有抽象方法 要么是抽象类 抽象类的成员特点 成员变量 既可以是变量 也可以是常量 构造方法 空参构造 有参构造 成员方法 抽象方法 普通方法 接口 概念：公共的规范和标准，只要按照这些规范来就可以正确使用 接口的特点 接口用关键字interface修饰 1public interface 接口名 &#123;&#125; 类实现接口用implements表示 1public class 类名 implements 接口名 &#123;&#125; 接口不能实例化 接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。 多态的形式：具体类多态，抽象类多态，接口多态。 接口的子类 要么重写接口中的所有抽象方法 要么子类也是抽象类 内部类 概念：就是在一个类中定义一个类 格式 ： 1234public class 类名&#123; 修饰符 class 类名&#123; &#125;&#125; ​ 内部类的访问特点 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 分类 成员内部类 局部内部类 匿名内部类 常用APIjava.util.Arrays static String toString(int[] a) ：将指定给定数组以指定格式的字符串返回 [元素1, 元素2, 元素3] 如果直接打印一个数组，其实得到的是地址值（字符数组除外） static void sort(int[] a) ：将指定的数组元素进行排序，默认升序排列 java.util.Math pow() abs() ceil() floor() max() min() random() round() java.lang.Object toString() equals() java.lang.System exit() currentTimeMillis() java.util.Date void setTime(long millis) long getTime() Date()：代表的当前系统时间 Date(long millis)：代表基准时间+毫秒值落到的时间 java.text.SimpleDateFormat SimpleDateFormat(String str) String format(Date d) Date parse(String str) java.util.Calendar get(int field) void set(int year, int month, int date) setTime(Date date) add(int field,int amount) 注意： 月份是从0~11 ，0表示1月，1表示2月，以此类推… 星期是从1-7，1表示星期日，2表示星期一，以此类推… 包装类 基本类型包装类的作用 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 基本类型对应的包装类 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean Integer经典使用案例（String与int类型转换） int —&gt; String 方式一： 123int num = 100;String s1 = num + "";System.out.println(s1); 方式二： 123int num = 100;String s2 = String.valueOf(num);System.out.println(s2); 方式三： 123int num = 100;String s3 = Integer.toString(num);System.out.println(s3); String —&gt; int 方式一： 1234String s = "100";Integer i = Integer.valueOf(s);int x = i.intValue();System.out.println(x); 方式二： 123String s = "100";int y = Integer.parseInt(s);System.out.println(s); 案例： 需求：有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：“27 38 46 50 91” 思路： 定义一个字符串 把字符串中的数字数据存储到一个int类型的数组中 得到字符串中每一个数字数据？ public String[] split(String regex) 定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中 public static int parseInt(String s) 对 int 数组进行排序 把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现 输出结果 代码： 1234567891011121314151617181920212223242526public class IntegerTest &#123; public static void main(String[] args) &#123; //定义一个字符串 String s = "91 27 46 38 50"; //把字符串中的数字数据存储到一个int类型的数组中 String[] strArray = s.split(" "); int arr[] = new int[strArray.length]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = Integer.parseInt(strArray[i]); &#125; //对 int 数组进行排序 Arrays.sort(arr); //把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现 StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; if (i == arr.length - 1) &#123; sb.append(arr[i]); &#125; else &#123; sb.append(arr[i]).append(" "); &#125; &#125; //输出结果 System.out.println(sb); &#125;&#125; Integer的注意点：在自动装箱与自动拆箱的过程中，同样的赋值语句，可能对应不同的地址。例如： 1234567Integer i1 = Integer.valueOf(100);Integer i2 = Integer.valueOf(100);System.out.println(i1 == i2); // trueInteger i3 = Integer.valueOf(200);Integer i4 = Integer.valueOf(200);System.out.println(i3 == i4); // false 然后我们扒Integer的源码，发现： 123456789101112131415public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; int h = 127; high = h; //然后是其他部分的源码，不再赘述，只取部分说明 ...&#125; 异常异常的概念 程序在编译或者运行的过程中出现的错误 Java中的异常指的都是异常类 异常类的体系 Throwable Error：不研究 Exception 编译时异常（检查异常）：Exception下除了RuntimeException及其子类之外的都是编译时异常 运行时异常（非检查异常）：RuntimeException及其子类都是运行时异常 集合 集合的体系结构： 单列集合： Collection接口 List接口：可以存储重复元素、存取有序、有索引可以根据索引操作元素 ArrayList类 LinkedList类 Set接口：不可以存储重复元素、存取无序、无索引不可以根据索引操作元素 HashSet类 TreeSet类 双列集合： Map接口 HashMap类 单列集合Collection常用方法： 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定的元素 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合中是否存在指定的元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中元素的个数 List接口存储的数据是可重复的、与添加顺序一致的（存取有序） ArrayList集合 ​ 底层是数组结构实现，查询快、增删慢 LinkedList集合 ​ 底层是链表结构实现，查询慢、增删快 ArrayList特有的常用方法： 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 List中，使用迭代器Iterator可能会导致并发修改异常的情况： 出现的原因 ​ 迭代器遍历的过程中，通过集合对象修改了集合中的元素 （添加和删除），造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：ConcurrentModificationException 解决的方案 ​ 用for循环遍历，然后用集合对象做对应的操作即可 示例代码 123456789101112131415161718192021222324252627282930public class ListDemo &#123; public static void main(String[] args) &#123; //创建集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add("hello"); list.add("world"); list.add("java"); //遍历集合，得到每一个元素，看有没有"world"这个元素，如果有，我就添加一个"javaee"元素，请写代码实现// Iterator&lt;String&gt; it = list.iterator();// while (it.hasNext()) &#123;// String s = it.next();// if(s.equals("world")) &#123;// list.add("javaee");// &#125;// &#125; for(int i=0; i&lt;list.size(); i++) &#123; String s = list.get(i); if(s.equals("world")) &#123; list.add("javaee"); &#125; &#125; //输出集合对象 System.out.println(list); &#125;&#125; 列表迭代器 ListIterator介绍 通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器 用于允许程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置 示例代码 1234567891011121314151617181920212223public class ListIteratorDemo &#123; public static void main(String[] args) &#123; //创建集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //添加元素 list.add("hello"); list.add("world"); list.add("java"); //获取列表迭代器 ListIterator&lt;String&gt; lit = list.listIterator(); while (lit.hasNext()) &#123; String s = lit.next(); if(s.equals("world")) &#123; lit.add("javaee"); &#125; &#125; System.out.println(list); &#125;&#125; LinkedList集合的特有功能 特有方法 | 方法名 | 说明 || ————————- | ——————————– || public void addFirst(E e) | 在该列表开头插入指定的元素 || public void addLast(E e) | 将指定的元素追加到此列表的末尾 || public E getFirst() | 返回此列表中的第一个元素 || public E getLast() | 返回此列表中的最后一个元素 || public E removeFirst() | 从此列表中删除并返回第一个元素 || public E removeLast() | 从此列表中删除并返回最后一个元素 | Set接口方法与List接口几乎一模一样。 存储的数据是不可重复的、不保证与添加顺序一致的（存取无序）。 双列集合MapMap集合的特点 键值对映射关系 一个键对应一个值 键不能重复，值可以重复 元素存取无序 方法介绍 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 根据键删除键值对元素 void clear() 移除所有的键值对元素 boolean containsKey(Object key) 判断集合是否包含指定的键 boolean containsValue(Object value) 判断集合是否包含指定的值 boolean isEmpty() 判断集合是否为空 int size()]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2Fmarkdown%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 再一次感谢您花费时间阅读，祝您在这里记录、阅读、分享愉快！]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>-markdown -笔记 -工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML/CSS学习笔记]]></title>
    <url>%2FHTML-CSS%2FHTML-CSS%2F</url>
    <content type="text"><![CDATA[HTML/CSS笔记123456789&lt;html&gt; &lt;!--这是根标签 --&gt; &lt;head&gt; &lt;title&gt;这里是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这里是页面体 &lt;/body&gt;&lt;/html&gt; 外部样式表格式： 1&lt;link rel = "stylesheet" type = "text/css" href = "css文件路径" /&gt; 文本标签 1234567891011121314&lt;em&gt;&lt;/em&gt;表示语义上的强调（自动斜体）&lt;strong&gt;&lt;/strong&gt;表示内容上的强调（自动加粗）&lt;i&gt;&lt;/i&gt;i标签的内容会以斜体显示&lt;b&gt;&lt;/b&gt;b标签的内容会以加粗显示&lt;small&gt;&lt;/small&gt;内容以细小的字体显示&lt;cite&gt;&lt;/cite&gt;引用（加书名号的）&lt;q&gt;&lt;/q&gt;行引用&lt;blockquote&gt;&lt;/blockquote&gt;块儿引用&lt;sup&gt;&lt;/sup&gt;上标&lt;sub&gt;&lt;/sub&gt;下标&lt;del&gt;&lt;/del&gt;删除线&lt;ins&gt;&lt;/ins&gt;插入内容&lt;pre&gt;&lt;/pre&gt;预格式&lt;code&gt;&lt;/code&gt;代码块（一般和pre标签一起使用）]]></content>
      <categories>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>-HTML -CSS -H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb学习笔记]]></title>
    <url>%2FJava%2FJavaWeb%2F</url>
    <content type="text"><![CDATA[ServletServletResoponse 设置响应格式123ServletResponse response = new ServletResponse();response.setContentType("application/msword");//设置响应类型为word文档。//具体可以在tomcat/config/web.xml中查找需要格式对应的值 JSPJSP运行原理 JSP是简Servlet编写的一种技术，他将Java代码和HTML语句混合在同一个文件中编写。只对网页中的要动态产生的内容才用Java代码来编写，而对固定不变的静态内容才用普通静态HTML页面的方式编写。 JSP继承了HttpJspBase类，而HttpJspBase又继承了HttpServlet，即jsp间接继承了HttpServlet，即JSP本质上就是一个Servlet。 JSP八大内置对象（实际上9个） 类名 对象实例名（可直接调用） HttpServletRequest request HttpServletResoponse response PageContext pageContext HttpSession session ServletContext application ServletConfig config JspWriter out Object page Exception exception ① request：HttpServletRequest的一个对象。 ② response：HttpServletResponse的一个对象（在JSP页面中几乎不会调用response的任何方法）。 ③ pageContext：页面的上下文，是PageContext的一个对象。可以从该对象中获取到其他8个隐含对象。亦可以从中获取到当前页面的其他信息。（学习自定义标签时使用他。在JSP页面上很少直接使用他。） ④ session：代表浏览器和服务器的一次会话，是HttpSession的一个对象。 ⑤ application：代表当前Web应用。是ServletContext的一个对象。（可以获取初始化参数等。） ⑥ config：当前JSP对应的Servlet的ServletConfig对象。（开发时几乎不使用。若需要访问当前JSP配置的初始化参数，需要通过映射的地址才可以。） ⑦ out：JspWriter对象。调用out.println()可以直接把字符串打印到浏览器上。（在两次out.println()时，中间不会换行，需要添加HTML的换行标签&lt;br>。） ⑧ page：指向当前JSP对应的Servlet对象的引用，但为Object类型，只能调用Object类的方法（几乎不使用。） ⑨ exception：一定的条件下才可以用。（只有主动声明了isErrorPage=”true”的时候，才可以使用。） 标红均为开发时常用对象。 pageContext，request，session，application对属性的作用域范围从小到大。 JSP表达式​ JSP表达式（expression）提供了将一个java变量或表达式的计算结果输出到客户端的简化方式，他将要输出的变量或表达式直接封装在&lt;%= 和 %&gt;中。 JSP注释的格式：&lt;%– JSP注释 –%&gt; HTML注释的格式：&lt;!– HTML注释 –> 区别 : ​ JSP注释可以阻止Java代码的执行，而HTML注释surround with &lt;% Java代码 %&gt;时，不能阻止Java代码的执行。 域对象的属性操作 ① 和属性相关的方法： Object getAttribute(String name)：获取指定的属性 Enumeration getAttributeNames()：获取所有的属性的名字组成的Enumeration对象 void removeAttribute(String name)：移除指定的属性 void setAttribute(String name, Object obj)：设置属性 ② pageContext，request，session，application对象都有这些方法。这四个对象也成为域对象。 ③ 作用范围 pageContext：属性的作用范围仅限于当前JSP页面。（在Servlet中无法得到pageContext对象。） request：属性的作用范围仅限于同一个请求。 session：属性的作用范围限于一次会话。（会话：浏览器打开直到关闭称之为一次会话。（会话在此期间不失效。）） application：属性的作用范围限于当前Web应用。是范围最大的属性作用范围，只要在一处设置属性，在其他各处的JSP或Servlet中都可以获取到。 请求的转发和重定向 ① 调用HttpServletRequest的getRequestDispatcher(String path)方法获取RequestDispatcher对象。调用方法时，需要传入要转发的地址。 ② 调用 HttpServletRequest的 forward（request，response）进行请求的转发。 ③ 调用sendRedirect(String path) 进行请求的重定向。 ④ 转发与重定向的区别： 本质区别：请求的转发只发出了 一次 请求，而重定向则发出了 两次 请求。 具体： 请求的转发：地址栏是初次发出请求的地址。 请求的重定向：地址栏不再是初次发出的请求地址，地址栏为最后响应的那个地址。 请求的转发：在最终的Servlet中，request对象和中转的那个request是同一个对象。 请求的重定向：在最终的Servlet中，request对象和中转的那个request不是同一个对象。 请求的转发：只能转发到当前Web应用的资源（内部资源）。 请求的重定向：可以重定向到任何资源。 请求的转发：“ / ” 代表的是当前Web应用（localhost:port/WebApps）的根目录。 请求的重定向：“ / ” 代表的是当前Web站点（localhost:port）的根目录。 JSP指令 ①include 用于通知JSP引擎在翻译当前JSP页面时将其他文件中的内容合并进当前JSP页面转换成的Servlet源文件中，这种在源文件级别进行引入的方式称之为静态引入，当前JSP页面与静态引入的页面紧密结合为一个Servlet。 file属性的设置值必须使用相对路径。 如果以“ / ”开头，表示相对于当前Web应用程序的根目录（注意不是站点根目录），否则，表示相对于当前文件。 ②page page指令用于定义JSP页面的各种属性，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面，为了保持程序的可读性和遵循良好的变成习惯，page指令最好是放在整个JSP页面的起始位置。 page指令常用的属性： import属性：指定当前JSP页面对应的Servlet需要导入的类。&lt;%@page import=”全类名”%&gt; session属性：取值为true或false，指定当前页面的session隐藏变量是否可用，也可以说访问当前页面时，是否一定要生成HttpSession对象。 errorPage和isErrorPage：前者表示指定若当前页面出现错误的实际响应页面是什么，其中“ / ” 表示的是当前Web应用的根目录。后者表示指定当前页面是否为错误处理页面，可以说明当前页面是否可以使用exception隐藏内置对象。 需要注意的是：若指定isErrorPage=”true”，并使用exception的方法了，一般不建议能够直接访问该页面。 contentType：指定当前JSP页面的响应类型。实际调用的是response.setContentType(“text/html;charset=UTF-8”);通常情况下，对于JSP页面而言其取值均为 text/html; charset=UTF-8 pageEncoding：指定当前JSP页面的字符编码。通常情况下该值和contentType中的charset一致。 isELIgnored：指定当前JSP页面是否可以使用EL表达式。通常取值为true。 如何使客户不能直接访问一个页面呢？ 1) 对于Tomcat服务器而言，WEB-INF下的文件是不能通过在浏览器中直接输入来访问的。但通过请求的转发是可以访问的！2) 还可以在web.xml文件中配置错误页面。 1234567891011 &lt;!-- 方式1.指定出错的代码，404没有指定资源，500内部错误。 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;!-- 指定响应页面的位置 --&gt;&lt;/error-page&gt; &lt;!-- 方式2.指定异常的类型 --&gt; &lt;error-page&gt;&lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;!-- 指定响应页面的位置 --&gt;&lt;/error-page&gt; ③taglib JSP标签 jsp:include标签： &lt;jsp:include page = &quot;path&quot;&gt; &lt;/jsp:include&gt; 动态引入：并不是像include指令生成一个Servlet源文件，而是生成两个Servlet源文件，然后通过一个方法的方式把目标页面包含进来。 org.apache.jasper.runtime.JspRuntimeLibrary.include(request,response,&quot;path&quot;,out,false); include指令和jsp:include标签： 是在当前JSP页面的执行期间插入被引入资源的输出内容。 被动态引入的资源必须是一个能独立被Web容器调用和执行的资源。 include指令只能引入遵循JSP格式的文件，被引入文件与当前JSP文件共同合被翻译成一个Servlet源文件。 jsp:foward标签： &lt;jsp:forward page = &quot;path&quot;&gt;&lt;/jsp:forward&gt; 相当于request.getRequestDispatcher(&quot;path&quot;).forward(request,response); 但使用jsp:forward可以使用jsp:param子标签向path传入一些参数，同样jsp:include也可以使用jsp:param子标签。 中文乱码编码格式 = 解码格式即可解决乱码问题。 MVC设计模式MVC即Model-View-Controller。模型-视图-控制器。 模型（Model） 模型是应用程序的主体部分。模型表示业务数据和业务逻辑。 一个模型能为多个视图提供数据。 由于应用于模型的代码只需要写一次就可以被多个视图重用，所以提高了代码的可重用性。 视图（View） 视图是用户看到并与之交互的界面，作用如下： 视图向用户显示相关的数据。 接受用户的输入。 不进行任何实际的业务处理。 控制器（Controller） 控制器接受用户的输入并调用模型和视图去完成用户的需求。 控制器接受请求并决定调用哪个模型组建去处理请求，然后决定调用哪个视图来显示模型处理返回的数据。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-JavaWeb -JSP -Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hello Everyone！这是我的第一篇文章。 在老铁的帮助下，我慢慢开始摸索代码世界…… 自己加油吧。 Keep Going！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
